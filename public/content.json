{"meta":{"title":"愛吃東西的RD","subtitle":"Node.js、JavaScript、好書筆記、吃吃喝喝","description":"Node.js、JavaScript、好書筆記、吃吃喝喝","author":"AndrewChen","url":"http://www.andrewchen.tw"},"pages":[{"title":"","date":"2017-03-10T23:35:05.000Z","updated":"2017-02-16T16:51:57.000Z","comments":true,"path":"googlea2a58f76829b43fb.html","permalink":"http://www.andrewchen.tw/googlea2a58f76829b43fb.html","excerpt":"","text":"google-site-verification: googlea2a58f76829b43fb.html","raw":null,"content":null},{"title":"Categories","date":"2017-02-02T11:31:23.000Z","updated":"2017-02-04T06:59:56.000Z","comments":false,"path":"categories/index.html","permalink":"http://www.andrewchen.tw/categories/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"","date":"2017-02-16T18:24:28.000Z","updated":"2017-02-16T18:24:28.000Z","comments":true,"path":"scripts/icon_fa-arrow-right.js","permalink":"http://www.andrewchen.tw/scripts/icon_fa-arrow-right.js","excerpt":"","text":"var article=$(\"#main\").html();var scriptStart=article.indexOf(\"\");article=article.substring(0,scriptStart);article=article.replace(/-&gt;/g,'');$(\"#main\").html(article);","raw":null,"content":null},{"title":"About","date":"2017-01-31T01:40:49.000Z","updated":"2017-03-10T23:35:23.000Z","comments":true,"path":"about/index.html","permalink":"http://www.andrewchen.tw/about/index.html","excerpt":"","text":"Node.js backend developer &nbsp;&nbsp;&nbsp; Taipei, Taiwan &nbsp;&nbsp; chenpoanandrew@gmail.com嗨，先謝謝您願意點進來看我的部落格。如果對部落格內容有任何疑問，或是發現錯誤歡迎透過 Facebook 或是 Gamil 聯絡，請各位多指教。更多關於工作經歷、個人接案經驗也會在日後逐步更新到部落格中。","raw":null,"content":null},{"title":"Tags","date":"2017-02-02T11:31:23.000Z","updated":"2017-02-04T06:59:56.000Z","comments":false,"path":"tags/index.html","permalink":"http://www.andrewchen.tw/tags/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"Console 使用技巧","slug":"20170601_JS_console","date":"2017-06-01T07:34:00.000Z","updated":"2017-06-01T09:10:33.000Z","comments":true,"path":"2017/06/01/20170601_JS_console/","link":"","permalink":"http://www.andrewchen.tw/2017/06/01/20170601_JS_console/","excerpt":"","text":"在一陣忙碌之後終於又有時間能靜下來寫篇 Blog 的文章，這次筆記的重點是 Front-end 開發時能時常使用的 console.log() 這個 API。最基本的 console.log() 使用基本的兩種輸出方式, 第一種的使用重點是 console.log 本身可以傳入複數個參數，之後會自動一併顯示。第二種寫法是更好更清楚的寫法，而 console.log 的 string formatter 基本上是跟 C++ 中的 printf 相同的用法。而需要注意的是 %s 這個欄位並沒有辦法直接印出 array 或是 json 資料格式對應的字串，會印出該資料的結構是哪種而已，如果想要印出 json 字串仍然需要自己進行 JSON.stringify 的操作。\b\b1234567891011121314151617181920var a = 1;var b = 2;var data = &#123; c: 3, d: 4, &#125;;var arr = [1, 2, 3, ];// #1 // a = 1 , b = 2console.log('a =', a, ', b =', b);// #2 // a = 1, b = 2console.log('a = %s, b = %s', a, b);// %s with JSON// data = Objectconsole.log('data = %s', data); // %s with Array// arr = Array(3)console.log('arr = %s', arr);基本上上述的部分應該沒什麼大的問題，多用幾次就會抓到自己的習慣了，也沒有什麼絕對正確的操作方式。同時 console.log 這個 API 是可以操作顏色的，在 Node.js Console 中為輸出的文字添加顏色的方式跟 \\n 換行符號的概念是一樣的，而顏色的概念是 切換輸出顏色，意即當你切換成紅色時，之後輸出的結果就都是紅色，要透過重置或是切換成其他顏色才會改變。而 Chrome 的方式則與 Web 相似12345// Chrome console.log('%c %s', 'background: #222; color: Red;', 'background is black and font color is red');// Node.jsconsole.log('\\x1b[31m %s', 'this is color red');Node.js console 顏色對照表參考資料顏色程式碼重置“\\x1b[0m”明亮“\\x1b[1m”Dim“\\x1b[2m”下底線“\\x1b[4m”閃爍“\\x1b[5m”反轉“\\x1b[7m”隱藏“\\x1b[8m”文字顏色—–Black“\\x1b[30m”Red“\\x1b[31m”Green“\\x1b[32m”Yellow“\\x1b[33m”Blue“\\x1b[34m”Magenta“\\x1b[35m”Cyan“\\x1b[36m”White“\\x1b[37m”背景顏色—–Black“\\x1b[40m”Red“\\x1b[41m”Green“\\x1b[42m”Yellow“\\x1b[43m”Blue“\\x1b[44m”Magenta“\\x1b[45m”Cyan“\\x1b[46m”White“\\x1b[47m”以上部分在 Node.js 和 Browser 中是雷同的，而 Browser console 的部分可能因為不同的瀏覽器不同而無法產生想要的結果，不過大致上是可以視為相同的邏輯與概念。console.dir()console.dir 跟 console.log 最大的差別在於， console.dir 主要適用於顯示物件，會顯示物件中詳細的每個屬性及 prototype 的資訊。嘗試在 Chrome 中輸入下列兩種指令就會看到基本的差異。12345// 一般常用console.log([1, 2])// 更進階一點的使用console.dir([1, 2])當然一開始會覺得其實現在 Chrome 的 console.log 也能展開物件中對應的資訊了，感覺差異不大。那嘗試一下針對 DOM 的操作，console.log 針對 DOM 是印出該元素，而 console.dir 則是完整的顯示出該物件的所有的資訊。12345// 僅顯示該元素 HTML 的程式碼console.log(document.body);// 顯示 javascript 中 DOM 完整的物件資訊console.dir(document.body);上述主要是在 Browser 中的操作，而 Node.js 中也有 console.dir 喔。嘗試下列程式碼就能看到更細節的東西。Node.js 官方文件123456789101112131415// node version 8.0.0// 一般的 console.logconsole.log(console); // 顯示更多的細節var options = &#123; // 是否顯示被隱藏的細節 showHidden: true, // 是否著色 colors: true, // 在該物件中遞迴向下檢查的層數 // depth: 1, &#125;;console.dir(console, options);console.table()console.table 是一個相當有趣的功能，能將陣列物件以表格的方式顯示，在 Chrome console 中執行下列程式碼即可看到結果。12345678910111213141516171819var menu = [ &#123; title: '香雞排', price: '70', &#125;, &#123; title: '牛排', price: '350', &#125;, &#123; title: '多拿滋', price: '55', &#125;, &#123; title: '可樂', price: '29', &#125;,];console.table(menu);最重要的 console.time() 和 console.timeEnd()我個人認為這是前端開發中最重要的技能，透過這兩個 API 能協助自己尋找頁面載入時真正拖住速度的地方。透過設立起點跟中點，來偵測這段程式碼執行的時間。1234// flagA: 12.35400390625msconsole.time('flagA');for(var i = 0; i &lt; 100; i++) &#123; console.log(i) &#125;console.timeEnd('flagA');測試後知道了這個 for 迴圈總共花了約 12ms。結語以上幾個是我自己比較常用到的 console API，而事實上是 Browser 和 Node.js 中的 console API 本身就存在著許多差異，只是 API 名稱設計時盡可能取得同步。使用這些 API 主要的重點還是讓開發者看到更正確的訊息，例如 console.log 、 console.error 和 console.warning 儘管顯示同一個字串，就存在著根本的差異，運用正確的 API 去顯示正確的值，避免自己混亂的同時也更有助於他人裡寫我們想要表達的東西。","raw":null,"content":null,"categories":[{"name":"做個筆記怕忘記","slug":"做個筆記怕忘記","permalink":"http://www.andrewchen.tw/categoriesl/做個筆記怕忘記/"}],"tags":[{"name":"學習筆記","slug":"學習筆記","permalink":"http://www.andrewchen.tw/tags/學習筆記/"},{"name":"javascript","slug":"javascript","permalink":"http://www.andrewchen.tw/tags/javascript/"},{"name":"frontend","slug":"frontend","permalink":"http://www.andrewchen.tw/tags/frontend/"}]},{"title":"Docker 安裝 Mysql + Phpmyadmin","slug":"20170505_NOTE_DOCKER_MYSQL","date":"2017-05-05T04:50:00.000Z","updated":"2017-06-01T07:34:28.000Z","comments":true,"path":"2017/05/05/20170505_NOTE_DOCKER_MYSQL/","link":"","permalink":"http://www.andrewchen.tw/2017/05/05/20170505_NOTE_DOCKER_MYSQL/","excerpt":"紀錄今天早上安裝 mysql 和 phpadmin 時所處理掉的伊些小問題mysql docker hub - https://hub.docker.com/r/mysql/mysql-server/phpmyadmin docker hub - https://hub.docker.com/r/phpmyadmin/phpmyadmin/建立 Mysql docker 容器 (container)","text":"紀錄今天早上安裝 mysql 和 phpadmin 時所處理掉的伊些小問題mysql docker hub - https://hub.docker.com/r/mysql/mysql-server/phpmyadmin docker hub - https://hub.docker.com/r/phpmyadmin/phpmyadmin/建立 Mysql docker 容器 (container)--name 可以指定容器名稱-p 將外部的 3306 port 與內部的對照起來這邊我指定 tag 為 5.7 版本同時設定 root 的密碼1docker run --name mysql -e MYSQL_ROOT_PASSWORD=MY_PASSWORD -p 127.0.0.1:3306:3306 -d mysql/mysql-server:5.7進入 mysql 命命列模式確認安裝成功下方指令的第一個 mysql 為容器名稱, 也就是上方指令所指定的 --name 的參數1docker exec -it mysql mysql -u root -p建立 phpmyadmin 容器透過 --link 將剛剛建立的容器與 db 對照同時重新對照阜號1docker run --name myadmin -d --link mysql_db_server:db -p 9100:80 phpmyadmin/phpmyadmin開啟 http://localhost:9100/index.php 能看到 phpadmin 的登入介面，輸入帳密後正常來說會登入失敗，因為還沒開啟 mysql 跨網域的登入功能，現在的 mysql 只能在容器內部 local 登入。調整 mysql 的登入網域限制依序執行下列指令：檢視資料庫清單選擇 user 資料庫修改指定的帳號登入區域限制，改為無限制刷新1234SHOW DATABASES;USE user;UPDATE user SET host = '%' WHERE user = 'root';FLUSH PRIVILEGES;重新嘗試登入即可看到 phpmyadmin 的介面囉。","raw":null,"content":null,"categories":[{"name":"做個筆記怕忘記","slug":"做個筆記怕忘記","permalink":"http://www.andrewchen.tw/categoriesl/做個筆記怕忘記/"}],"tags":[{"name":"學習筆記","slug":"學習筆記","permalink":"http://www.andrewchen.tw/tags/學習筆記/"},{"name":"教學","slug":"教學","permalink":"http://www.andrewchen.tw/tags/教學/"},{"name":"docker","slug":"docker","permalink":"http://www.andrewchen.tw/tags/docker/"},{"name":"mysql","slug":"mysql","permalink":"http://www.andrewchen.tw/tags/mysql/"}]},{"title":"Function - JavaScript 細節部分","slug":"20170504_JS_細節部分1","date":"2017-05-04T06:51:00.000Z","updated":"2017-05-04T06:52:08.000Z","comments":true,"path":"2017/05/04/20170504_JS_細節部分1/","link":"","permalink":"http://www.andrewchen.tw/2017/05/04/20170504_JS_細節部分1/","excerpt":"Function 在 JavaScript 的重要性不言而喻，下面將針對不同的宣告與範疇逐一做介紹。一般宣告 Function12345678910// 可以在撰寫該 function 程式碼的區塊之前就使用foo();function foo() &#123;    console.log('bar');&#125;// 後面當然也是沒問題的foo();這是最單純的宣告函數的方式，會在 JavaScript 執行前第一次載入就直接宣告完成。這種宣告的方式屬於痊域的宣告，宣告之後在任何地方都可以使用。而在前端瀏覽器的環境下 foo 中的 this 則是代表全域的 windows 物件。在物件中的 Function","text":"Function 在 JavaScript 的重要性不言而喻，下面將針對不同的宣告與範疇逐一做介紹。一般宣告 Function12345678910// 可以在撰寫該 function 程式碼的區塊之前就使用foo();function foo() &#123; console.log('bar');&#125;// 後面當然也是沒問題的foo();這是最單純的宣告函數的方式，會在 JavaScript 執行前第一次載入就直接宣告完成。這種宣告的方式屬於痊域的宣告，宣告之後在任何地方都可以使用。而在前端瀏覽器的環境下 foo 中的 this 則是代表全域的 windows 物件。在物件中的 Function1234567var user = &#123; name: \"AndrewChen\", selfIntro: function() &#123; console.log('My name is :', this.name); // My name is AndrewChen &#125;,&#125;;user.selfIntro(); // this === name在物件中掛載函數，如同物件導向中的方法，this 則是 user 這個物件的本身，理所當然的 this.name 就是呼叫到 &quot;AndrewChen&quot; 這個字串。這邊有另一個寫法很容易造成混淆。1234567891011var user = &#123; name: \"AndrewChen\", foo: foo,&#125;function foo() &#123; console.log('bar', this);&#125;user.foo(); // this === userfoo(); // this === window基本上就是同時結合上述兩種概念，真正影響 Function 的範疇判定是在 Function 呼叫的方式。當然還有其他的方式可以手動修改 Function 定義的範疇，這個我會在之後的篇幅中提到。[ ] prototype 是否也是相同的[ ] 注意 prototype 的宣告方式有很多種那我們針對這邊做個遞迴的小實驗，首先這個寫法是比較有瑕疵的，直接在函數 foo 中呼叫 foo 會造成 foo 本身的範疇到第二層遞迴時就走樣的情況，不過在全域的環境下是沒有差別的：12345678910111213141516var counter = 0;var user = &#123; name: 'AndrewChen', foo: foo,&#125;;function foo() &#123; if(counter &gt; 2) return; console.log(counter + ' this === window', this === window); counter++; foo();&#125;user.foo(); // false, true, truecounter = 0;foo(); // true, true, true呼叫 user.foo() 時產生很明顯的問題，第一次的範疇還是 user 本身，而後續的呼叫都是呼叫到全域的 foo 函數。這種情況本身就不是很好的用法，因為這讓函數產生了兩種不同的作用區域，甚至是兩種不同的功能，這邊單純是因為要湊出這個範例凸顯這個問題而已，要修正的方式也相當單純：將遞迴呼叫函數的方式修改成 this.foo() 及可，重申一次，個人認為這個寫法相當的不可取。當作類別來使用123456789101112function User(name, age) &#123; this.name = name; this.age = age; this.selfIntro = function() &#123; console.log('My name is ' + this.name); &#125;&#125;var userA = new User('AndrewChen', '24');userA.selfIntro();console.log('userA ', userA);與物件導向中的類別作用方式雷同，這個函數會獲得並定義自己的 this，自立門派成為一個新的物件，而這種作法屬於比較舊的撰寫方式了，在 2015 年的 ES2015 規範中，es6 中有直接定義了 class 的語法糖，不必再用這種曖昧函數來撰寫類別了，實作一模一樣的東西，撰寫方式如下：123456789class User &#123; constructor(name, age) &#123; this.name = name; this.age = age; &#125; selfIntro() &#123; console.log('My name is ' + this.name); &#125;&#125;明顯撰寫的格式清楚很多，有獨立的建構子和掛載方法的方式，而這些方法中的 this 物件就很直觀的隸屬於這個類別的實例。Arrow Function 箭頭函數上述所有的函數再宣告的時候都採用了比較正式的宣告方式，使用了 function 這個名詞，而實際在撰寫時會頻繁的使用 () =&gt; {} 箭頭函數這種方式，而箭頭函數宣告出來的函數事實上是沒有自己的 this 物件，是直接繼承上一層的範疇。這個狀況很明顯的是用在有傳遞 function 的地方。如果是一般 Function 然後不使用改變範疇的寫法的話，會寫成這樣，需要事先複製 this 的物件。123456789101112131415var user = &#123; name: 'AndrewChen', onlineTime: 0, startCounter: function() &#123; var self = this; setInterval(function() &#123; console.log('curr onlineTime :', ++self.onlineTime) &#125;, 1000); &#125;,&#125;;user.startCounter();setTimeout(function() &#123; console.log('checker : ', user.onlineTime);&#125;, 5000);這邊的問題就是 setInterval 中的函數有自己的範疇，因此無法透過 this.onlineTime 直接取用 user 物件中的欄位， 而如上述所說，箭頭函數是沒有自己的範疇，因此可以為避掉","raw":null,"content":null,"categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://www.andrewchen.tw/categoriesl/Node-js/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.andrewchen.tw/tags/JavaScript/"},{"name":"Node.js","slug":"Node-js","permalink":"http://www.andrewchen.tw/tags/Node-js/"},{"name":"學習筆記","slug":"學習筆記","permalink":"http://www.andrewchen.tw/tags/學習筆記/"},{"name":"教學","slug":"教學","permalink":"http://www.andrewchen.tw/tags/教學/"}]},{"title":"Next.js 2 走馬看花","slug":"20170410_NOTE_Next.js走馬看花","date":"2017-04-10T12:52:00.000Z","updated":"2017-04-10T13:39:32.000Z","comments":true,"path":"2017/04/10/20170410_NOTE_Next.js走馬看花/","link":"","permalink":"http://www.andrewchen.tw/2017/04/10/20170410_NOTE_Next.js走馬看花/","excerpt":"這幾天 Next.js 2 在台灣的技術圈洗了一輪版，讓我們花一點點時間快速看看 Next.js 到底在做什麼。Next.js GithubNext 算是對一般網站使用 React 高成本問題提出了解決方案，明確地簡化了環境建置和最基本的 routing。如果使用 Next 內建的 routing 機制，吃 ./pages 資料夾中的檔案決定 router 時， 開發者能對 router 動得手腳就相對有限，（在 demo 中看到的，大部分需求應該都沒問題 的），但 Next 中仍然有相當的彈性能導入其他 routing 的框架，所以對於延展性的需求是無庸置疑的，而且官方有佛心的提供大量與其他框架結合的範例。重點打包了大部分 React server rendering 基本會用到的 packagenpm run xxx 就建置完成了，webpack 什麼的都省了Next 包 babel, webpack進去, 包了很多東西就對了Next 直接實作了 server rendering, 這點大概就是 Next 最大的價值, 包括有針對做一套對應的機制因為實作了 server rendering, Next 中有自己的撰寫風格, 有一個 getInitialProps 的 func，且 getInitialProps 是 async functionNext 裡面寫的 code 基本上就是 react code，他並不是一個全新的框架，因此學習成本是有限的。通常這種好棒棒的工具都有很肥的問題, Next 官方表示沒有, client 只會有 65kb 負擔 ( 因為是 server rendering, 肥的是 server 端 )Next 彈性還是相當大的, graphQL, express, koa, typescript, reduxt 想跟誰結婚就跟誰結婚","text":"這幾天 Next.js 2 在台灣的技術圈洗了一輪版，讓我們花一點點時間快速看看 Next.js 到底在做什麼。Next.js GithubNext 算是對一般網站使用 React 高成本問題提出了解決方案，明確地簡化了環境建置和最基本的 routing。如果使用 Next 內建的 routing 機制，吃 ./pages 資料夾中的檔案決定 router 時， 開發者能對 router 動得手腳就相對有限，（在 demo 中看到的，大部分需求應該都沒問題 的），但 Next 中仍然有相當的彈性能導入其他 routing 的框架，所以對於延展性的需求是無庸置疑的，而且官方有佛心的提供大量與其他框架結合的範例。重點打包了大部分 React server rendering 基本會用到的 packagenpm run xxx 就建置完成了，webpack 什麼的都省了Next 包 babel, webpack進去, 包了很多東西就對了Next 直接實作了 server rendering, 這點大概就是 Next 最大的價值, 包括有針對做一套對應的機制因為實作了 server rendering, Next 中有自己的撰寫風格, 有一個 getInitialProps 的 func，且 getInitialProps 是 async functionNext 裡面寫的 code 基本上就是 react code，他並不是一個全新的框架，因此學習成本是有限的。通常這種好棒棒的工具都有很肥的問題, Next 官方表示沒有, client 只會有 65kb 負擔 ( 因為是 server rendering, 肥的是 server 端 )Next 彈性還是相當大的, graphQL, express, koa, typescript, reduxt 想跟誰結婚就跟誰結婚快速起手透過 npm 安裝 next.js 以及 react1npm install next react react-dom --save初始化 package.json1npm init在 package.json 中的 scripts 中加上對應的指令1234567&#123; \"scripts\": &#123; \"dev\": \"next\", \"build\": \"next build\", \"start\": \"next start\" &#125;,&#125;建立資料夾結構12345.├── node_modules/├── pages/├── static/├── package.json./pages/ Next 會針對這個資料夾做路由，每個檔案都是一個獨立的頁面，舉例來說有 home.js 和 about.js 兩個檔案，那 Next 就會自動導出 http://{hostname}/home 和 http://{hostname}/about 這兩個頁面出來，而這個頁面對於 Next 又有一些細節要注意，這個會在後面說到。./static/ 很直觀的就是靜態檔案的放置資料夾，透過 /static/{filename} 可以直接在前端使用檔案。新增第一個頁面檔案官方給的範例是這個123export default () =&gt; ( &lt;div&gt;Welcome to next.js!&lt;/div&gt;)啟動 server1npm run dev前往 http://localhost:3000 就可以看到最基礎的建置成果了。","raw":null,"content":null,"categories":[{"name":"做個筆記怕忘記","slug":"做個筆記怕忘記","permalink":"http://www.andrewchen.tw/categoriesl/做個筆記怕忘記/"}],"tags":[{"name":"程式設計","slug":"程式設計","permalink":"http://www.andrewchen.tw/tags/程式設計/"},{"name":"重點筆記","slug":"重點筆記","permalink":"http://www.andrewchen.tw/tags/重點筆記/"},{"name":"心得分享","slug":"心得分享","permalink":"http://www.andrewchen.tw/tags/心得分享/"}]},{"title":"設計模式創建型模式 Creational Pattern","slug":"20170410_NOTE_DesignPatternCreational","date":"2017-04-10T05:10:00.000Z","updated":"2017-04-10T12:44:54.000Z","comments":true,"path":"2017/04/10/20170410_NOTE_DesignPatternCreational/","link":"","permalink":"http://www.andrewchen.tw/2017/04/10/20170410_NOTE_DesignPatternCreational/","excerpt":"設計模式主要被分為三大類：創建型模式 Creational Pattern結構型模式 Structural Pattern行為型模式 Behavioral pattern工廠模式 Factory pattern","text":"設計模式主要被分為三大類：創建型模式 Creational Pattern結構型模式 Structural Pattern行為型模式 Behavioral pattern工廠模式 Factory pattern透過新增不同的類別來達成延展或修改功能的需求。在實例化類別前因應需求決定實例化的對象，而這幾個類別在接下來的程式碼中，可能都有差不多的操作。舉例來說：宣告 user 時，透過條件判定噓要實例化 user、vip 或是 admin 的類別，而在之後操作時可直接透過 user.login() 直接進行想要的操作，因為在一開始實例化類別時已經處理完成需求的擴充或更改了。12345678910User user;if(isAdmin) &#123; user = Admin();&#125;else if(isVIP) &#123; user = VIP();&#125;else &#123; user = User();&#125;工廠模式有很多種實作方式：簡單工廠、抽象工廠、方法工廠等等。都是用相同的邏輯在運作，只是切分的層面或方式不同。建造者模式 Builder PatternBuilder Pattern 我個人認為可以直接視為工廠模式的一種，如果再細分的話更接近抽象工廠模式。Builder Pattern 的重點在於抽取出程式碼中最終實作的某部分，透過一個抽象類別來規範這些實作的方式，而之後若有擴充的需求，直接依賴於抽象類別再行新增，然後在實例化時切換即可。可以想像成網頁中模組化的 footer 當你抽換 footer 時，整個網站的 footer 都可以跟著抽換。雛形模式 Prototype Pattern在新建立物件時，透過複製現有的物件來建立。單例模式 Singleton Pattern一個類別就只擁有一個實例化，如果再次進行實例化，就直接回傳原先已實例化的物件。Single Pattern 中又細分成兩種操作模式，一種是在整個系統初始化或是啟動時就直接對該類別實例化，另一則是在第一次宣告時才實例化。差別在於佔用記憶體和初始化的效能。","raw":null,"content":null,"categories":[{"name":"Code要好好寫","slug":"Code要好好寫","permalink":"http://www.andrewchen.tw/categoriesl/Code要好好寫/"}],"tags":[{"name":"程式設計","slug":"程式設計","permalink":"http://www.andrewchen.tw/tags/程式設計/"},{"name":"重點筆記","slug":"重點筆記","permalink":"http://www.andrewchen.tw/tags/重點筆記/"},{"name":"心得分享","slug":"心得分享","permalink":"http://www.andrewchen.tw/tags/心得分享/"}]},{"title":"設計模式五大基本原則 SOLID","slug":"20170409_NOTE_設計模式五大基本原則SOLID","date":"2017-04-09T09:49:00.000Z","updated":"2017-04-10T12:44:51.000Z","comments":true,"path":"2017/04/09/20170409_NOTE_設計模式五大基本原則SOLID/","link":"","permalink":"http://www.andrewchen.tw/2017/04/09/20170409_NOTE_設計模式五大基本原則SOLID/","excerpt":"最近複習 Design Pattern 順手做個筆記，Design Pattern 的是基本 5 大原則 SOLID。先說明這部分的名詞翻譯，中文翻譯我是查詢 維基百科 的翻譯，畢竟中文翻譯方式本身就是一個約定成俗即可的東西。縮寫英文全名中譯SRPSingle Responsibility Principle單一職責原則OCPOpen Closed Principle開閉原則LSPLiskov Substitution Principle里氏替換原則ISPInterface Segregation Principles介面隔離原則DIPDependency Inversion Principle依賴反轉原則讓我們針對這幾個逐一做介紹：","text":"最近複習 Design Pattern 順手做個筆記，Design Pattern 的是基本 5 大原則 SOLID。先說明這部分的名詞翻譯，中文翻譯我是查詢 維基百科 的翻譯，畢竟中文翻譯方式本身就是一個約定成俗即可的東西。縮寫英文全名中譯SRPSingle Responsibility Principle單一職責原則OCPOpen Closed Principle開閉原則LSPLiskov Substitution Principle里氏替換原則ISPInterface Segregation Principles介面隔離原則DIPDependency Inversion Principle依賴反轉原則讓我們針對這幾個逐一做介紹：單一職責原則 Single Responsibility Principle從最高維的系統角度來看，每個系統該明確規劃並解決某中問題，或是針對某個功能的實作，而不是一個功能複雜卻難用的系統，可以想像成一個 APP 就是做一件事情，日曆就是日曆，過多的功能只會導致開發上的複雜或是需求定位不夠明確的問題。若是從低維度往上看，程式碼中的 Function 應該遵循所謂的 Pure Function，每個函數負責好自己做的事情，一次只做一件事情，不依賴於外界任何的東西，也不多做任何其他的手腳。單一職責原則最終的目的是 高內聚。一次做一件事情，並移除與這件事情無關的程式碼和變數，整體程式碼中的每個部分都與自己實作的功能相關，並沒有冗余的程式碼或功能。可以將單一職責原則視為樂高的每一塊積木，積木就做好一塊正方型積木堆疊的工作，草形狀的積木就是裝飾草形狀的工作，要是有一塊積木是正方形的同時上面又長草，或許在某些情境下特別好用，但這也代表他在其他地方不適用，因為他組合了兩個不同的功能，並非單一職責原則。開閉原則 Open Closed Principle一個模組應該是透過延展功能的彈性來獲得更多功能上的變化，而並非直接修改內部的程式碼。將模組設計的易於延展功能，實務上的困難就是難以預測，到底模組中的哪些功能有可能會面對到修改。目的是避免最原始的模組被頻繁的修改，基層模組被頻繁修改時相當難維護其穩定性，OCP 希望直接避免掉修改的機會，使用延展新功能的方式來達成不同的需求。而新的需求就從新延展出來的模組中來實作，這樣維持舊有程式碼的安定性和新需求的彈性。明顯的，延展模組就是說物件導向中的繼承，而針對延展方式也有不同的手法，如直接繼承就有的模組並覆蓋新功能上去、繼承抽象類別、透過抽象類別的規範來實作新功能、透過多行來實作不同的新功能。里氏替換原則 Liskov Substitution Principle在繼承中衍生出來的子類別，能完全支援父類別的功能。之所以稱做替換原則，就是指腹類別成出現的地方，一定能替換成衍生類別來使用。這中間其實多少有牽扯到 SRP 的原則，當你的模組或衍生的模組夾雜太多功能時，儘管依照著 LSP 的原則元整的實作了上一階的所有功能是相當不錯的方式，但這樣會造成這個類別或是模組越來越複雜，而當面臨下一次的功能擴充時，這個狀況會越來越明顯的陷入泥濘。因此在嘗試 LSP 時，必定要注意到不能忽略了 SRP 的觀念，避免在多次的升級或是改版中，最終導致整個系統極低的內聚力，並且相當不易拆分或刪減功能維護。介面隔離原則 Interface Segregation Principles設計模組時避免設計龐大且同時多功能的單一介面，我們不應該大規模的假設使用者會完全符合這樣的需求。介面設計時應該力求介面的功能單一化，分割出多個單一功能的碎片，而眾多的功能介面中，使用者只需要挑出幾個符合需求的，並了解之後拼裝成對應的功能。同樣與 SRP 有類似的觀念，當某個 API 設計越複雜越完整時，這只會導致該 API 能適用的場合越來越少，多做了不該做的事情。ISP 即是esign Pattern 中的 低耦合 目標。依賴反轉原則 Dependency Inversion Principle重點在於誰依賴誰，是設計模式中相當重要的事情，子類別肯定依賴父類別的，而父類別不能去依賴子類別實作功能。另一個重點是抽象類別，抽象類別不應該有太多細節，而實作類別依賴抽象細節，這之間的重點是，依賴應該是單向的，當然最好的目標是完全的沒有耦合，但繼承這個行為本身就讓某個類別依賴另一個類別，因此單向的依賴是最乾淨的，雙向的依賴，或是違反常理的依賴，會導致程式碼相當難追蹤。結語五個基本原則大致上勾勒出：低耦合、高內聚、介面設計方式、繼承方式、兼容。而實作設計模式的方式與細節重點在於讓程式碼更乾淨，更能讓後者完全了解前者所撰寫的功能，也降低在後續修改上的成本。","raw":null,"content":null,"categories":[{"name":"Code要好好寫","slug":"Code要好好寫","permalink":"http://www.andrewchen.tw/categoriesl/Code要好好寫/"}],"tags":[{"name":"程式設計","slug":"程式設計","permalink":"http://www.andrewchen.tw/tags/程式設計/"},{"name":"重點筆記","slug":"重點筆記","permalink":"http://www.andrewchen.tw/tags/重點筆記/"},{"name":"心得分享","slug":"心得分享","permalink":"http://www.andrewchen.tw/tags/心得分享/"}]},{"title":"CleanCode 無瑕的程式碼-番外篇","slug":"20170313_BOOKS_CleanCode2","date":"2017-03-13T01:17:10.000Z","updated":"2017-05-04T23:39:58.000Z","comments":true,"path":"2017/03/13/20170313_BOOKS_CleanCode2/","link":"","permalink":"http://www.andrewchen.tw/2017/03/13/20170313_BOOKS_CleanCode2/","excerpt":"無瑕的程式碼番外篇其實可以看作是現代版的人月神話，談到了現在軟體開發的核心觀念，無論是資訊和觀念都較為新穎，當然人月神話是不可否認的經典，但比起來，我更推薦這本人月神話-番外篇的觀念。作者：Robert C. Martin譯者：戴于晉、博碩文化審校：陳錦輝出版社：博碩文化CleanCode 無瑕的程式碼 (上篇)CleanCode 無瑕的程式碼 (下篇)專業主義書中談論到何謂尊重自己的專業，專業並不是單純維持自己的技術能力，或擁有高超的程式撰寫技巧。作者所言的專業是，穩定並細心地完成工作，在遭遇到問題時能冷靜地解決。專案開發的過程中不可避免的會有延宕、或不可預期的狀況發生，專業的開發者應該扛下這個責任，並確實的跟主管或客戶說明情況，不僅是需要優秀的溝通技巧，更需要的是能承擔責任的心。承擔開發的錯誤也是專業的一環，從錯誤中學習不僅重要，不要給對方超出實際狀況的期待並忠實告知情況是對自己專業的負責。","text":"無瑕的程式碼番外篇其實可以看作是現代版的人月神話，談到了現在軟體開發的核心觀念，無論是資訊和觀念都較為新穎，當然人月神話是不可否認的經典，但比起來，我更推薦這本人月神話-番外篇的觀念。作者：Robert C. Martin譯者：戴于晉、博碩文化審校：陳錦輝出版社：博碩文化CleanCode 無瑕的程式碼 (上篇)CleanCode 無瑕的程式碼 (下篇)專業主義書中談論到何謂尊重自己的專業，專業並不是單純維持自己的技術能力，或擁有高超的程式撰寫技巧。作者所言的專業是，穩定並細心地完成工作，在遭遇到問題時能冷靜地解決。專案開發的過程中不可避免的會有延宕、或不可預期的狀況發生，專業的開發者應該扛下這個責任，並確實的跟主管或客戶說明情況，不僅是需要優秀的溝通技巧，更需要的是能承擔責任的心。承擔開發的錯誤也是專業的一環，從錯誤中學習不僅重要，不要給對方超出實際狀況的期待並忠實告知情況是對自己專業的負責。換個角度來說，這份專業主義含有大量職業道德的成份，除了正確的匯報工作狀況之外，堅持學習、練習、與他人合作等等都是屬於專業領域中需要維持的部分，而並不是單單的只有寫程式敲鍵盤而已。最終作者說道：謙遜，謙遜屬於職業道德中的一部分，除了能妥善地跟人溝通，謙遜的對人是相當重要的，這並不是管理技巧或是溝通技巧，而是身為個程式設計師該有的樣子，對自己謙遜也對別人謙遜，越是強大越需要謙遜。承諾與拒絕承諾與拒絕與前一章節談到的專業息息相關，非技術專業的客戶或是主管可能提出無法實現的需求，或是該需求可能要付出極大的代價，對方卻完全不自知。此時告知整體情況是工程師的責任，有必要告訴他們這個需求對應的風險和成本，而不是單純的用曖昧的回答來拖延開發時間：”我試試看…”、”那可能需要更多的時間”，無意義的拉長開發時間或用曖昧的字詞肯定這份需求之類的。明白的告知對方這是不可能、無法進行開發，避免資金和時間浪費，保護資方的利益。正確的檢視自己的工作和開發過程，了解自己能做出什麼樣的承諾，當然可以在中間預留風險管控的時間，但給予需求方客觀且確切的狀況是工程師的職責，不要浮誇的虛報工作時間換取更多安全感或信任。也可能這整個開發過程需要仰賴對應的團隊完成，我們才能接手，那工程師在答應對發這個功能時，就應該一並告知需求方。而相反的狀況，當我們在承諾對方時，給出確切的承諾是對自己的責任表態，應該避免用曖昧的口吻來迴避失敗的風險，我們應該將程式設計看為工具，我們能達成什麼，就老實的說明出來，而不是利用狀況不明的方式來答應對方，避免自己在事後開發遭遇問題時可以否認，尤其是 “我試試看” 這種說法，成功時當然沒有問題，失敗時卻以當初沒有完全答應、嘗試性的答應來迴避失敗，這種逃避的心態除了對工作上不負責任之外，也是對自己專業的一種羞辱，甚至是放寬對自己的自我要求。測試測試在 CleanCode 1 中被大大地強調過數次，用測試來保證自己程式碼的品質，並同時對自己的程式碼負責任。測試是在為自己工作負責的同時，也是給予其他人信心，我們親手測試過的程式碼，在繳交給別人如果仍然出現錯誤，那會比完全沒有測試過還來來得能容忍。當然最好的狀況是完全沒有錯誤。時間管理時間管理不單單是自己工作的效率。工程師需要意識到自己工作的範疇，高階工程師的薪資相當可觀，相當可觀的數字代表著當工程師每浪費的一點時間，對企業來說都是一筆巨大的支出。什麼東西對公司來說是無形的內耗成本？包括無意義的會議、明顯會失敗的計畫、不合理的需求等等，工程師要能提出來並且解決這些狀況，對自己的薪資負責，釐清工作中的繁忙是否有真正的價值。在這部分的章節，作者也提出一些輔助的方式來提高工作效率，包括喝咖啡、音樂、短暫的睡眠等等，工程師增加自己的工作效率也是工作的責任之一。小結書本後半段談論比較多關於工具、和工作小細節的東西，基本上都類似於工作效率的問題。我認為核心是自我反省，工程師的工作是大量消耗腦力的，在一整天高強度的思考之後，很有可能覺得很扎實的工作，覺得自己是個高效率的開發者。而這時是我們能不能在這個時候審視自己，自己是否有沒做好或是欠下技術債的地方，甚至是虛晃了時間，以為自己很努力。這中間也包括是否能簡化自己開發的流程、提高溝通效率，就如同常聽到的一句話：工程師的工作就是讓自己失業。做的好壞明顯地由此而知。整本書核心的內容我自己分類成兩大觀念：自省和溝通。自省包括了檢討自己的錯誤、自我成長、誠實，而溝通則是對外的應對、承諾、交換資訊的效率率、工作匯報等，重複加上自省的觀念之後就是找出讓自己更有效率的方式，能讓對方更快速的理解現狀。透過這兩大觀念，將原先的專業技術領域拓展到更全面的專業開發者，專業的溝通與信任，而不是當一個難以溝通的技術怪咖。","raw":null,"content":null,"categories":[{"name":"Code要好好寫","slug":"Code要好好寫","permalink":"http://www.andrewchen.tw/categoriesl/Code要好好寫/"}],"tags":[{"name":"讀書心得","slug":"讀書心得","permalink":"http://www.andrewchen.tw/tags/讀書心得/"},{"name":"程式設計","slug":"程式設計","permalink":"http://www.andrewchen.tw/tags/程式設計/"},{"name":"重點筆記","slug":"重點筆記","permalink":"http://www.andrewchen.tw/tags/重點筆記/"},{"name":"心得分享","slug":"心得分享","permalink":"http://www.andrewchen.tw/tags/心得分享/"}]},{"title":"分享：給年輕程式設計的忠告","slug":"20170312_NOTE_翻譯分享NoteForYougerProgramer","date":"2017-03-12T01:11:20.000Z","updated":"2017-03-13T00:48:41.000Z","comments":true,"path":"2017/03/12/20170312_NOTE_翻譯分享NoteForYougerProgramer/","link":"","permalink":"http://www.andrewchen.tw/2017/03/12/20170312_NOTE_翻譯分享NoteForYougerProgramer/","excerpt":"當你遇到問題時，花個 15 分鐘常識尋找答案。如果還是不行，就問問別人吧。問問題並不是丟臉的事情。但如果你因為你問問而感到自豪，這就不太對了。每次修改程式碼都要讓它變得更好，無論是增修文件的說明、語法細節、設計模式或補上測試程式碼。都會有人相當感激你，而這個人也可能是未來的自己。","text":"當你遇到問題時，花個 15 分鐘常識尋找答案。如果還是不行，就問問別人吧。問問題並不是丟臉的事情。但如果你因為你問問而感到自豪，這就不太對了。每次修改程式碼都要讓它變得更好，無論是增修文件的說明、語法細節、設計模式或補上測試程式碼。都會有人相當感激你，而這個人也可能是未來的自己。測試程式碼也需要註解。找到仍讓自己抽離工作的方式，堅持下去。程式設計師最好的進步方式就是寫是程式。別忘了，閱讀程式碼也是使用軟體的一種方式。不要排斥程式碼複查、討論設計架構，這是團隊合作讓程式碼更精進最好的方式。單純的解讀每個人的想法，儘管對方可能並不單純，但這會讓你活得快樂一點。爭論時，問問自己這個問題是否值得，否則你將會花許多時間在爭論一個函數的命名。命名仍然是相當重要的，約定成俗也是相當重要的。溝通的軟實力比你撰寫程式碼的硬實力還來的重要，注意任何人或是事的暗示。為自己做的事情感到驕傲，但失敗時會一次摧毀這份自豪。你將會失敗，恩對，而且很常這樣。測試的範圍不夠廣泛，會忽略掉一些細節，會完全錯過掉某個使用案例，你的工作將會搖搖欲墜。別小看自己，學習犯錯也是一種學習。想法 &gt; 對話 &gt; 電子郵件 &gt; 文件 &gt; 程式碼。按上述的順序改善或加強。所有的文件都應同步被更新。就算要來不及了也別忘了程式碼的可靠度。凡事都有原因：一個六年前撰寫、功能不明的爬蟲程式，有可能當時他們只有兩天的開發時間。在遇到這種情況是請先假設這個開發人員不是無藥可救的大笨蛋，這樣會讓你好受一些。“無聊” 比 “聰明” 更能提升程式碼的品質。任何程式碼都有技術債，就算是一個只用一次就會刪掉的指令，或是維持現狀並不會再改變的程式碼，都是未來的技術債。自己衡量自己的實力，並投入時間在你覺得正確的方向上。每個人都有自己的優缺點，空泛且不專精的學習和鑽牛角尖在某項技術上都不是好事情。花時間學習使用各種工具並不丟臉。任何能幫助你工作的東西：程式語言、既定的程式碼風格、編輯器，甚至耳機、椅子、終端機的字體、桌面背景、咖啡等。盡可能地幫助更多人。翻譯自：jmduke 部落格：If you are faced with a question to which you don’t know the answer, spend fifteen minutes looking for the answer yourself. Then ask someone else.There is no shame in asking questions.There is a great deal of shame in being too proud to ask questions.Always leave a codebase cleaner than you found it — whether it’s adding documentation, cleaning up syntax, or fixing an edge case. Someone will be grateful, even if that someone is Future You.Tests deserve comments, too.Decide what you’re willing to leave at work. Stick to it.The best way to improve as a programmer is to program; the best way to improve as a software developer is to use software.Never forget that one can use software by reading it.Don’t treat code reviews or design critiques as a adversarial process; recognize that its a cooperative effort to refine artifacts into their best possible form.Assume that everyone has the best intentions. Even if they don’t, it’ll make your life easier.When debating an issue, ask yourself “how much do I really care about this?” Otherwise, you will inevitably spend time and energy debating whether something should be named FooWidgetProcessor or FooWidgetHandler.Sometimes, though, it’s important to decide whether or not something should be FooWidgetProcessor versus FooWidgetHandler. Naming is important; conventions are important.Communication is a more important skill than code. Be cautious of anyone or anything that implies otherwise.Take enough pride in your work to be happy when it succeeds but not enough to be destroyed when it fails.Your stuff will fail, like, a lot. The test data won’t be extensive enough; there will be an edge case you missed; you will miss a use case; your work will not be resilient enough or robust enough or gracious enough.Don’t think less of yourself for it; learning through error is still learning.In ascending order of robustness: thought, conversation, email, documentation, code.Optimize for robustness.All documents are living documents.Don’t confuse reliability with uptime.Everything happened for a reason, even if it’s that six-year-old cron job that checks for emails containing the word “yes”, and even if the reason was “we had to ship this feature in two days.” Pretending that past developers are incorrigible bogeymen is only going to cause you more grief.“Boring” is a better heuristic for code quality than “clever”.All code is technical debt. Even if its a CLI that you think you’ll use for a one-off job and then delete; even if its a ‘stop-gap measure’. (Stop-gap measures stop being stop-gap measures as soon as they’re promoted to prod, at which point they become the status quo.)You make what you measure. Invest a lot of time in making sure that you’re measuring the right things.Everyone knows some things better than you and some things worse than you. Investing too much in either is a bad idea.There is no shame in investing in your tools.Consider everything that helps you work as a tool: your language, your code conventions, your IDE, your headphones, your chair, your iTerm font, your desktop background, your coffee.Help as many people as possible.","raw":null,"content":null,"categories":[{"name":"做個筆記怕忘記","slug":"做個筆記怕忘記","permalink":"http://www.andrewchen.tw/categoriesl/做個筆記怕忘記/"}],"tags":[{"name":"程式設計","slug":"程式設計","permalink":"http://www.andrewchen.tw/tags/程式設計/"},{"name":"重點筆記","slug":"重點筆記","permalink":"http://www.andrewchen.tw/tags/重點筆記/"}]},{"title":"領導的品格","slug":"20170303_BOOKS_領導的品格","date":"2017-03-03T15:12:00.000Z","updated":"2017-03-03T15:37:15.000Z","comments":true,"path":"2017/03/03/20170303_BOOKS_領導的品格/","link":"","permalink":"http://www.andrewchen.tw/2017/03/03/20170303_BOOKS_領導的品格/","excerpt":"兼具情與理的傳達的作者領導者系列之一，透過 51 句話描述成為一個願意讓人追隨的領導者的重點。討論的面相相當廣泛，包括管理者的自我思考、溝通技巧、領導人的真正目的、自我成長的重點，儘管說是成為一個領導者的重點，這反而是自我成長的重點。每個人其實都是領導者，領導著自己在短暫的人生中發光發熱。作者同系列的書：兼具情與理的傳達力-心得分享這本書最大的特色就是核心的 51 句話，每句話大概由 4 到 6 頁的篇幅來更近一步的解釋概念，相當推薦大家一開始看這本書的時候，先快速的瀏覽過每個篇幅的標題，再逐一深入，我個人認為整本書有四大核心概念：","text":"兼具情與理的傳達的作者領導者系列之一，透過 51 句話描述成為一個願意讓人追隨的領導者的重點。討論的面相相當廣泛，包括管理者的自我思考、溝通技巧、領導人的真正目的、自我成長的重點，儘管說是成為一個領導者的重點，這反而是自我成長的重點。每個人其實都是領導者，領導著自己在短暫的人生中發光發熱。作者同系列的書：兼具情與理的傳達力-心得分享這本書最大的特色就是核心的 51 句話，每句話大概由 4 到 6 頁的篇幅來更近一步的解釋概念，相當推薦大家一開始看這本書的時候，先快速的瀏覽過每個篇幅的標題，再逐一深入，我個人認為整本書有四大核心概念：品德身為領導者最重要的就是品德，這個品德包括呈現在別人面前的氣度、私底下為他人思考的同理心和修身養性的品德。品德不僅僅牽扯的是重要的道德觀念，同時是類似正能量的道理，領導者需要良好的品德來推動者個團隊的運作，用清新的風氣感化大家、帶領著整體的工作氣氛。儘管領導者的品德影響是很難量化的，但總體來說，正向的風氣與正向的企業經營方向才會帶來好的結果，而不是充滿了小人心態或是政治鬥爭的手段長存於企業中。清晰的目標動力來自於：願景、志向、熱情、危機意識、使命感。動力最明顯的地方就是工作，除了給自己有理由工作之外，讓自己高效率也是以身作則的方式，給予大家一起努力的動力。而管理者最重要的事情就是驅動部署做事情，而除了單純的薪水之外，能給予更多的願景、志向、熱情、使命感都能讓員工為自己在做的工作感到具有意義或是價值，而同時作者也提到要為部屬著想，給予對方的願景不單單是企業單方面的發展願景，也需要考量到對方的未來、對方的感受。整體來說是需要多方面考慮的，而不是單方面地給出宏大的目標，就會讓人感受到充滿動力的向前。另外，危機意識是一個需要高度掌握技巧的管理手段，洽當的運用配合工作時間和任務的分配，也能提高生產的效率，但應避免濫用或是參雜著個人情緒或是讓人感到負面的未來。自我成長領導者本身最重要的就是自我成長。自我成長不僅是專業技巧，同時包含了：管理技巧、為人處事、品德和個人思維的成長，領導者不斷的成長除了讓自己有更高維度的思考方式能判斷決策之外，目的也是要影響部署，讓部屬覺得領導者是有方向性的，有成長性的，工作環境是充滿未來的，某種意義上也是提供了一個隱性的目標給大家。而這中間最重要的就是自省，和廣納鍊言。身居高位的管理者或是獨處的人，相當難獲得直接性的成長，許多事情是沒有辦法短期評量的，所以不斷的內化各方面的知識、嘗試自我成長，其實是領導者看清現狀最好的方式，由未來更成熟的自己來判斷現在的自己，是否有沒有需要改進的地方，自己發現自己所犯下的決策或人際錯誤。行動力領導者的行動利和規劃能力是最直接影響整個組織運作，善用時間和適當的配置都相當重要。作者提出一種方式我個人非常喜歡，姑且就稱 10秒啟動 的行動力。生活中往往有許多簡單的事情，卻相當難有果斷的行動歷來開始或完成。舉例來說冬天洗澡、早上起床這種簡單的事情，常常讓我猶豫非常久，當然我知道拖延 30 分鐘再洗澡狀況也不會改善，但是卻缺乏了立即行動的能力。而這些事情又單純到很難給予願景、志向等等方式。作者題書的方式是，在遇到類似的狀況時，由 10 開始倒數到 1，給自己的制約就是倒數時間到時，一定要開始做這件事情，這個制約當然也需要自律性來達成，但經過嘗試之後，我發現比真正的”立即”開始行動輕鬆得多，給自己 10 秒的緩衝時間，接著立即開始做該做的事情。結語領導的品格是一本相當正能量且看起來沒什麼負擔的書，我個人覺得短篇張的敘述讓論點變得清晰，許多複雜的感受被拆成一小片一小片的觀點，相對的也更容易去印證書中內容所說的。而作者的出發點都相當的基本，都是我們能從自身改變的東西，改變自己並讓自己成為更好的人。並不單單只領導者，可能是一個人自我的成長過程，自我思辯的一部分。","raw":null,"content":null,"categories":[{"name":"好書筆記","slug":"好書筆記","permalink":"http://www.andrewchen.tw/categoriesl/好書筆記/"}],"tags":[{"name":"重點筆記","slug":"重點筆記","permalink":"http://www.andrewchen.tw/tags/重點筆記/"},{"name":"心得分享","slug":"心得分享","permalink":"http://www.andrewchen.tw/tags/心得分享/"},{"name":"自我成長","slug":"自我成長","permalink":"http://www.andrewchen.tw/tags/自我成長/"},{"name":"溝通技巧","slug":"溝通技巧","permalink":"http://www.andrewchen.tw/tags/溝通技巧/"}]},{"title":"建立自己的 Telegram ChatBot","slug":"20170218_NOTE_建立自己的TelegramBot","date":"2017-02-18T02:25:35.000Z","updated":"2017-02-19T03:41:50.000Z","comments":true,"path":"2017/02/18/20170218_NOTE_建立自己的TelegramBot/","link":"","permalink":"http://www.andrewchen.tw/2017/02/18/20170218_NOTE_建立自己的TelegramBot/","excerpt":"申請 TelegramBot 的帳號透過 Node/telegraf.js 撰寫 ChatBot申請 TelegramBot 的帳號1.透過 @BotFather 申請在 Telegram APP 中找到 @BotFather 這個官方的 BOT：","text":"申請 TelegramBot 的帳號透過 Node/telegraf.js 撰寫 ChatBot申請 TelegramBot 的帳號1.透過 @BotFather 申請在 Telegram APP 中找到 @BotFather 這個官方的 BOT：開始跟 @BotFather 對話，按下 start 之後會出現簡易的功能列表：選擇 /newbot：首先 @BotFather 會詢問 bot 的名稱和使用者名稱，首先詢問的名稱就是一般聊天視窗上方看到的名稱，而使用者名稱是在搜尋時會出現的名稱。Telegram 針對 ChatBot 規範：必須使用 _bot 做為結尾，舉例來說我選擇了 AC 當名稱，而使用者名稱則是 AC_bot，如果 @BotFather 回答 “Sorry, this username is already tacken.” 代表已經有人註冊該使用者名稱，請嘗試取其他的名字。基本設定完成，@BotFather。基本設定完成之後，在 @BotFather 回覆的長長的訊息中，有兩個重點：第一個是 t.me/&lt;剛剛取的使用者名稱&gt; 的 ChatBot 聊天鏈結，和一個 HTTP API token， token 大致上長這樣：2345162:DFAGSsfd2312LK2JDAL_ASL23L5KJ，由 數字 + ： + 英文數字 所組成，這組 token 相當重要，是建立 ChatBot 最重要的東西，同時請注意不要外流。2.測試 Token接著我們測試 Token 是否已經開始運作。透過 HTTP 請求即可完成。將下述網址中的 {ChatBot token} 更換成剛剛從 @BotFather 那邊拿到的 token 即可。1https://api.telegram.org/bot&#123;ChatBot token&#125;/getMe接著就會看到驗證成功的訊息：12345678&#123; ok: true, result: &#123; id: 324237649, first_name: \"AC\", username: \"ACkeeper_bot\" &#125;&#125;接著我們就可以繼續往下建置 ChatBot 核心的 Bot 的部分。3.Node.js 建立 Bot server其實也有其他的第三方服務可以串接 ChatBot，諸如：chatfuel，但如果你跟我一樣有比較客製化的分析需求，或是想要串接自己的 DB 等狀況，自建 Node.js Bot server 是一個比較方便的選擇。Node.js 中使用的套件是：telegraf.js，官方推薦，支援最完整的套件。telegraf.js 自己官方是號稱Telegram Chat API 有 100% 支援：”Full Telegram Bot API support”。安裝 telegraf.js。這邊需要注意的是 Node.js 的版本，telegraf 所要求的版本為 &gt;=6.2.0，而我在開發時使用的事 v6.9.5。1$ npm install telegraf --save這個是 telegraf 的基本範例：process.env.BOT_TOKEN 要更換成從 @BotFather 那邊取得的 token，或是執行 Node 前透過全域變數先設定好，如果你的專案有放在 Github 上的話，這邊請注 token 寫在當案中時，不要順手的就 commit push，這樣 token 就外流了！事後可能造成不必要的麻煩。基本的範例功能非常簡單：一開始進入會說：”Welcome!”說：”hi”，會回覆：”hey there!”傳送貼圖，會回覆：”👍”1234567891011121314const Telegraf = require('telegraf')const app = new Telegraf(process.env.BOT_TOKEN)app.command('start', (ctx) =&gt; &#123; console.log('start', ctx.from) ctx.reply('Welcome!')&#125;)app.hears('hi', (ctx) =&gt; ctx.reply('Hey there!'))app.on('sticker', (ctx) =&gt; ctx.reply('👍'))app.startPolling()測試結果這樣就完成了初步的 Telegram ChatBot 基本建置。測試結果如下：另外是在與自己的 ChatBot 連線時，可以獲得 ChatID，這個在之後的操作會相當常用到。上方程式碼第 6 行的， console.log(&#39;start&#39;, ctx.from) 所輸出的資料：123456start &#123; id: 123123123, first_name: 'Andrew', last_name: 'Chen', username: 'AndrewChenTW'&#125;參考文件Telegram Bot revolutiontelegraf.js","raw":null,"content":null,"categories":[{"name":"做個筆記怕忘記","slug":"做個筆記怕忘記","permalink":"http://www.andrewchen.tw/categoriesl/做個筆記怕忘記/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://www.andrewchen.tw/tags/Node-js/"},{"name":"程式設計","slug":"程式設計","permalink":"http://www.andrewchen.tw/tags/程式設計/"},{"name":"重點筆記","slug":"重點筆記","permalink":"http://www.andrewchen.tw/tags/重點筆記/"},{"name":"TelegramBot","slug":"TelegramBot","permalink":"http://www.andrewchen.tw/tags/TelegramBot/"},{"name":"ChatBot","slug":"ChatBot","permalink":"http://www.andrewchen.tw/tags/ChatBot/"},{"name":"Telegram","slug":"Telegram","permalink":"http://www.andrewchen.tw/tags/Telegram/"},{"name":"telegraf.js","slug":"telegraf-js","permalink":"http://www.andrewchen.tw/tags/telegraf-js/"}]},{"title":"ATOM無痛轉移至VSCode","slug":"20170217_NOTE_ATOM無痛轉移至VSCode","date":"2017-02-17T00:13:20.000Z","updated":"2017-05-04T23:39:28.000Z","comments":true,"path":"2017/02/17/20170217_NOTE_ATOM無痛轉移至VSCode/","link":"","permalink":"http://www.andrewchen.tw/2017/02/17/20170217_NOTE_ATOM無痛轉移至VSCode/","excerpt":"隨這過去這一年 VS Code 的使用者增加，Atom vs Sublime vs VSCode 相關的討論炒得越來越火熱，也有越來越多社群上的大大表示跳槽到 VSCode 的圈內。以我個人來說，我是從 Atom 跳槽到 VSCode ，剛跳槽的時候也遇到了不少的問題，以下介紹了 Atom 跟 VSCode 跳槽的細節過程：如何將快捷鍵全部調整成與 Atom 相同？VSCode 安裝 ThemeVSCode 調整設定的方式常用套件推薦將快捷鍵全部調整成跟 Atom 一樣","text":"隨這過去這一年 VS Code 的使用者增加，Atom vs Sublime vs VSCode 相關的討論炒得越來越火熱，也有越來越多社群上的大大表示跳槽到 VSCode 的圈內。以我個人來說，我是從 Atom 跳槽到 VSCode ，剛跳槽的時候也遇到了不少的問題，以下介紹了 Atom 跟 VSCode 跳槽的細節過程：如何將快捷鍵全部調整成與 Atom 相同？VSCode 安裝 ThemeVSCode 調整設定的方式常用套件推薦將快捷鍵全部調整成跟 Atom 一樣換編輯器最痛的苦莫過於快捷鍵的改變，VSCode 中有 Atom Keymap 的套件，安裝後可以直接將大部分的 VSCode 快捷鍵改得跟 Atom 差不多，個人覺得這是最重要的的！調整快捷鍵設定之後，對整個 VSCode 的熟悉度 +100 😄VSCode 安裝 Theme 不同的小細節VSCode 安裝後的 Theme 請去 Code &gt; 喜好設定 &gt; 彩色佈景主題 ，與 Atom 最重要的差異是 Theme 和 Syntax Color 是綁定的，不相 Atom 可以分開選則 (或許要去設定中調整細節才行了)。調整設定個人覺得這部分 VSCode 過一陣子之後就會改掉，VSCode 目前的設定並沒有比較好的 GUI 介面可以手用，要透過 JSON 檔案來維護，不過幾乎是全部的設定都已經偶中文翻譯了，並沒有太大的問題，只要複製做邊需要的片段程式碼到右邊就好了。話說調整設定的時候，VSCode 很貼心的主動開啟雙視窗，貼心++。個人常用的 VSCode 套件首推當然是：Atom KeymapTheme 的部分我是使用：Theme-atom-one-dark因為先前我在 Atom 是使用 Git-Plus，如果你也喜歡用 cmd + shift + p 來執行 Git 相關的指令的話推薦使用 Git Easy必備的 Git Log 查看工具 Git History，而且相當美觀呢小結先前覺得 VSCode 的社群資源並不如 Atom 龐大，事實也是如此，但以我個人使用的功能來說，最基本的功能已經齊全了！而因為 Atom 在我的 Mac 上打字總是慢半拍的原因 (而且更新到 1.14 以上的版本仍然沒有改善)，讓我更積極主動地想要脫離 Atom 跳槽的 VSCode。","raw":null,"content":null,"categories":[{"name":"做個筆記怕忘記","slug":"做個筆記怕忘記","permalink":"http://www.andrewchen.tw/categoriesl/做個筆記怕忘記/"}],"tags":[{"name":"程式設計","slug":"程式設計","permalink":"http://www.andrewchen.tw/tags/程式設計/"},{"name":"重點筆記","slug":"重點筆記","permalink":"http://www.andrewchen.tw/tags/重點筆記/"},{"name":"atom2vscode","slug":"atom2vscode","permalink":"http://www.andrewchen.tw/tags/atom2vscode/"},{"name":"atom","slug":"atom","permalink":"http://www.andrewchen.tw/tags/atom/"},{"name":"vscode","slug":"vscode","permalink":"http://www.andrewchen.tw/tags/vscode/"}]},{"title":"兼具情與理的傳達力(下篇) 管理的表達與工作外的事","slug":"20170211_BOOKS_兼具情與理的傳達力-2","date":"2017-02-11T12:00:00.000Z","updated":"2017-03-03T15:37:20.000Z","comments":true,"path":"2017/02/11/20170211_BOOKS_兼具情與理的傳達力-2/","link":"","permalink":"http://www.andrewchen.tw/2017/02/11/20170211_BOOKS_兼具情與理的傳達力-2/","excerpt":"成爲讓部屬願意追隨的上司，51個帶人先帶心的領導力。作者：岩田松雄譯者：劉格安、黃薇嬪出版社：悅知文化兼具情與理的傳達力 (上篇) 團隊的向心力作者同系列的書：領導的品格-心得分享如何在管理上面表達自己的想法笨拙卻極具說服力的法則溝通重要的是值跟量隨時把狀況、對象、內容放在心上，簡單地列出重點，如果是多個訊息，請認真的考慮對方接收訊息的順序。嘗試去減少對方接收訊息時需要思考的量，盡可能地給予結論、重點摘要。使用對方能聽懂的慣用語，別自以為是或是說很難懂的話，工程師思維、工程師邏輯等等。並不是說出來的內容特別專業、別人聽不懂，就代表很厲害。彰顯自己的專頁也無濟於事，更有可能引來對方的反感，真正的專業是能完整的表達內容，並且說服對方同意。傳達壞消息是該如何開口","text":"成爲讓部屬願意追隨的上司，51個帶人先帶心的領導力。作者：岩田松雄譯者：劉格安、黃薇嬪出版社：悅知文化兼具情與理的傳達力 (上篇) 團隊的向心力作者同系列的書：領導的品格-心得分享如何在管理上面表達自己的想法笨拙卻極具說服力的法則溝通重要的是值跟量隨時把狀況、對象、內容放在心上，簡單地列出重點，如果是多個訊息，請認真的考慮對方接收訊息的順序。嘗試去減少對方接收訊息時需要思考的量，盡可能地給予結論、重點摘要。使用對方能聽懂的慣用語，別自以為是或是說很難懂的話，工程師思維、工程師邏輯等等。並不是說出來的內容特別專業、別人聽不懂，就代表很厲害。彰顯自己的專頁也無濟於事，更有可能引來對方的反感，真正的專業是能完整的表達內容，並且說服對方同意。傳達壞消息是該如何開口越糟的消息，越該從結論說起，不慌張的態度會讓你顯露出不同的氣度，也會讓對方後續的反應大不相同。記得注意氣氛，氣氛很重要，當下的氣氛會影響對方針對事情的接受度，甚至影響整件事情的判讀能力。讓對方能順利地接受情況，並且做出適當的反應後，再逐步拆解工作或是分析現況，不要一拖拉谷的強押，必且希望對方趕快解決。在解決糟糕又緊急的情況時，更必須注重對方的感受問題。在轉述情況時，精確地調整細節資訊，讓對方以最舒服的方式聽懂我們的論述。整個過程中，闡述事情不是最終目的，讓對方完全接納才是。如何讓人成長讚美和責罵時，如何讓人都能感受到你的真誠？許多人會排斥別人的訓斥，應當嘗試用更為晚的方式說服，讓對方完成事情即可，不需要汲汲營營地證明自己是對的，就算自己擁有完全正確的邏輯立場，讓對方屈服，也不會改善事情的進展。身段放軟，並嘗試讓事情的結果導向自己希望的可能。不要出其不意的訓斥他人，主要是為了避免激起對方情緒，激起情緒後會使事情相當難處理，在對方做好心理準備的情況下指出不正確的地方。先說好聽的，在說不好聽的話。先嘗試找到改善的方式。最好的開頭句子：”這不像是你會做的事”。基於人性，誇獎的時候在眾人面前表揚，責備的情況則盡量私下解決。讓人心悅誠服的指點罵人時不要用情緒去表達，而是表達解決方案即可。利用自己的氣度說話，而不是利用官階押人。同時避免情況轉述成情況糟糕的那面，專注於解釋事情為何要如此進行，讓團隊有繼續前進的動力。不要一昧地否定過去的錯誤，看見未來的機會才是重點。從心溢出來的東西，會灌注到心裡去。盡可能的不要用用悲觀的方式傳達給別人，悲觀的情緒會使效率低落，先收斂起自己的情緒，再跟團隊討論。悲觀是指自己在管理時的看法，適當的悲觀避免過度樂觀的無法發現計畫終將失敗。面對危機時務必謹言慎行，不要將這個情緒傳達給下屬去掀起無謂的波瀾。這就是所謂的：長期樂觀，短期悲觀廣納雅言、謙虛接受他人訊息的能力。在職場上怎麼做人比怎麼做事來的重要。聽到不同的意見時，不要快速的用狹隘的理由來拒絕整件事情，先試著接受它。例如有人推薦某件事情給你，不應該馬上拒絕，而是先接納對方的意見，並同意嘗試。除了個人成長的因素之外，主管外在形象有一個很大的重點：避免讓人覺得你聽不進去。頻繁地拒絕或否定部署，很有可能直接讓珍貴的諫言遠離你，或是少掉獲取新資訊的機會。作者在書中提及：別人教你的事情你就試試看，有人推薦書給你就唸唸看。嘗試模仿你所尊敬的人，並身體力行。但記得過分聽從他人的言論容易瞻前顧後，猶疑不定。分享自己的挫折經驗多少讓人知道你經歷過的風風雨雨，有助於他人了解你。怎麼詮釋不同的經驗取決於個人，不要排斥每個人的經驗。讓大家知道你也是個有溫度的人，有助於拉近團隊之間的關係。忍無可忍的時候最終我們都會面對在一些對話的過程中情緒失控，無法用理性的方式來跟對方對話。嘗試透過俯瞰的角度來了解整個事情的問題點，拉高自己的觀點，遭受到情緒的批評或責難時，首先調整自己。先處理情緒，再處理事情。在工作上，比金錢更重要的是什麼？越是忙碌越不要忘記休息，過度忙碌容易迷失自我。從長輩那兒得到過的好處，就回饋在晚輩身上。教導晚輩更多的專業技術吧，教導別人時，自己能學到的更多。無論多辛苦、就算身處險惡境遇中仍有希望，不要放棄任何希望，就算沒看到光芒，也要撐下去，隨時隨地找地方另闢天地。心中時常擺上自己尊敬的對象，記得自己不要讓這個人丟臉。多唸書，並不是只單純的知識，而是哲學等有人生意義的書。在職場中最重要的事情就是吸收、實踐。首先實踐自己學到的人生理論或是生活方式。試著扮演自己想成為的人，會讓你整個人氣度都不一樣，世界上沒有人是十全十美的，攝取並吸收眾人的長處即可。學習就是模仿，並嘗試讓自己進步。但記得不是想要取代或是成為誰。這同時說明了，不要拿自己跟別人比較，自己跟自己比較，讓自己更好，而不是嘗試去超越別人，這樣只會讓自己活在追逐的迴圈裡。這就是一種：被討厭的勇氣。我，只能當我自己。自滿的言論是危險信號如果覺得自己沒有什麼缺點，不再需要改進，這是個危險的訊號！有時人們會沈溺於過去的成功，包括：學歷、功績、各方面的成就，認為自己的能力十足強大，比旁邊的人優秀。這樣只代表我們自我滿足，停止進步、停止嘗試向前的力量。有可能這一瞬間相對其他人是真的很優秀，但這是一種怠惰，隨之而來的就是失敗。自滿的言論代表你對現在的自己感到滿足，也代表缺乏上進心。那我們真正該做的是什麼？思考，不斷的自省與思考。這是一個相當清澈的人生觀，我個人就常常思考過去犯下的錯，或細心的規劃未來的方向。試著思考當下，把當下的事情做好，了解這件事情對自己的意義。如同賈伯斯所述：”當最終你回頭看自己生命中的點點滴滴時，你才會明白這一切是怎麼串在一起的。”把握當下，做好每件事情。重點不是做什麼，而是為什麼而做，不論對自己也好對別人也好，這都是同樣的道理。對別人是用為什麼來說服別人，對自己時自我了解自己在做什麼，賦予事情意義。別主顧著思考未來，試著思考此時此刻眼前發生的事情，對自己的人生具有什麼樣的意義在生命中，找到自己的使命感，這就對自己所謂的為什麼。更宏觀的觀點就是人類為麼存在？當我們在生命結束的那一瞬間，回顧時或許就會了解這一生的一切。重視緣分珍惜與他人的緣分，並不只是去認識更多人，而是重視那個真正能跟你敞開心胸談論的人。嘗試多與有品德的人來往，而不僅僅是有利益的人。擁有相同目標的人，將創造出強大的力量，過程比什麼都崇高，而不是結束。在工作中為當下努力，改進過去的錯誤，主動地邁向未來。躊躇不前，反覆的算計不應該是我們的核心生活方式。活在當下，跟身邊的人相處，不論在工作上、在家庭上，並改變自己，讓周遭的人也感受到這個更好的氛圍。即使只有一個人，仍堅持做著自己認為對的事情，為社會貢獻一己之力，或與擁有相同使命感的好夥伴組隊朝著目標前進，過程才是人生最大的收穫人生的目標應該是受人敬重，而不是共的的金錢財富。成為那個值得別人仰慕的人，可能是成就或品格，這就是對社會的貢獻，刻劃了人類文明的歷史。結語一開始這本書傳達了很多管理細節、溝通技巧，教導我們以心待人的管理方式。卻在後半部的書卻講述了更高層次的觀點：除了工作之外的人生觀。其實我是一個急於追求工作的人，追求工作上的自我成長，追求薪資等等。我無法否認的是這些事情也讓我自己活在一個比較的世界裡面，有時我很有成就感，有時只帶來無限的空虛，該怎麼活？該怎麼做？這是我尋尋覓覓的人生目標，或許就是那個明確的滿足點。在看完這本書後的這陣子裡，書對我的思考有極大的影響，翻開這本書不外乎是希望能在工作上有更好的表現，卻在書的結尾中收到了一份與自己不同信念的餽贈，我不斷重新思考著自己想要的是什麼，但最重要的事，我開始嘗試活在當下，更注重周遭的人事物。我仍在追尋此生的意義，在龐大的宇宙和無限的時間之流中。","raw":null,"content":null,"categories":[{"name":"好書筆記","slug":"好書筆記","permalink":"http://www.andrewchen.tw/categoriesl/好書筆記/"}],"tags":[{"name":"重點筆記","slug":"重點筆記","permalink":"http://www.andrewchen.tw/tags/重點筆記/"},{"name":"心得分享","slug":"心得分享","permalink":"http://www.andrewchen.tw/tags/心得分享/"},{"name":"自我成長","slug":"自我成長","permalink":"http://www.andrewchen.tw/tags/自我成長/"},{"name":"溝通技巧","slug":"溝通技巧","permalink":"http://www.andrewchen.tw/tags/溝通技巧/"}]},{"title":"兼具情與理的傳達力 (上篇) 團隊的向心力","slug":"20170211_BOOKS_兼具情與理的傳達力-1","date":"2017-02-11T10:25:55.000Z","updated":"2017-03-03T15:37:24.000Z","comments":true,"path":"2017/02/11/20170211_BOOKS_兼具情與理的傳達力-1/","link":"","permalink":"http://www.andrewchen.tw/2017/02/11/20170211_BOOKS_兼具情與理的傳達力-1/","excerpt":"成爲讓部屬願意追隨的上司，51個帶人先帶心的領導力。作者：岩田松雄譯者：劉格安、黃薇嬪出版社：悅知文化兼具情與理的傳達力 (下篇) 管理的表達方式 &amp; 工作之上的人生目標作者同系列的書：領導的品格-心得分享真正的傳達事情給對方情，代表的是話說帶有人情味。理，代表的是容易理解的傳達方式。告知和傳達是不同的兩件事倘若無法引起對方的共鳴，或產生任何影響，就不算是真正的告知對方事情。若對方在聽完這些訊息後，實際採取了某些行動，才算真正的傳達出去。","text":"成爲讓部屬願意追隨的上司，51個帶人先帶心的領導力。作者：岩田松雄譯者：劉格安、黃薇嬪出版社：悅知文化兼具情與理的傳達力 (下篇) 管理的表達方式 &amp; 工作之上的人生目標作者同系列的書：領導的品格-心得分享真正的傳達事情給對方情，代表的是話說帶有人情味。理，代表的是容易理解的傳達方式。告知和傳達是不同的兩件事倘若無法引起對方的共鳴，或產生任何影響，就不算是真正的告知對方事情。若對方在聽完這些訊息後，實際採取了某些行動，才算真正的傳達出去。當事情已經說過，已經表達過，問題卻一再發生時。扣除外在因素，並不是對方的問題，而是自己的問題。自己的表達能力無法讓對方信服、或是產生共鳴。這就是告知和傳達的差別，較差的管理者指利用的職位取得比部署更多的資訊，並且只做個資訊傳達的工作，真正好的管理者，應該嘗試讓部署採取行動解決，這才是真正的說服對方。管理並不是單單地利用權責來完成事情而已。資訊的價值取決於說話者是誰多數的時候，說話的人是誰，比他說了什麼還重要。一個人的人格特質以及給予人的印象，將會影響到資訊的傳達效果，真正能影響別人的是人的是說話內容和說話者的人品。說話的技巧和給人的既定印象，同時達成兩個條件，才能真正的說服他人，驅動他人主動去完成事情。以演講來說，簡報技巧、話術、舞台風格，其實都屬於枝微末節的技巧。真正的重點是說服人的能力，讓人信賴的本質，但人們卻往往去重視其他更不重要的奇技淫巧。領導這不該太過情緒化，也不應該過於理智。透過感情或品德去體貼他人、了解對方的能力、誠實的個性、高瞻遠矚。這些才應該是評價一個管理者最重要的指標。情緒化的言論會被理性否定，理性的言論會被情緒化的否定。這就是領導者最根本重點，而不是運用優秀的政治手腕來迫使員工服從、透過規定來硬化大家的工作，成為一個透過感受來說服大家的人，而不是透過規定驅動團隊的人。如何成為更令人信服的領導者談論自己的背景，並聆聽對方的背景，是溝通最重要的環節之一。互相了解能降低對方對自己的防衛心理，防衛心理會產生不理性的排斥感。考量對方的背景，職場上正確的瞭解對方的過去是很重要的，不要單看現在的職位或是情況。以高階管理者來說，空降的高階管理者，與一路奮鬥上來的管理者，就擁有著完全不同的心境與立場。徹底的了解對方的狀況，再來分析自己該怎麼說明狀況，而不是強行的述說自己的情況，並嘗試加諸在對方身上。首要的目標是互相了解，而不是互相鬥爭或是比較利益。在開始整段談論時，如果你是上位者，記得注意兩個重點：謙卑、禮貌。不要利用自己的地位和手段來與人交談，這樣這場交談會淪為形式、商業化，缺乏感情並讓下屬缺乏動力。處理自己與他人的關係建立良好的工作關係記得隨時保持最真實的自己，裝腔作勢與自卑感是一體兩面的東西。真誠的表達發自內心的想法，會自然而然的傳達到對方心裡去。人與人之間的思想和言論像鏡子樣，會互相映射，當自己改變了，對方隨著時間也會變得更好。思想也是相同的道理，改變自己跟對方溝通時的思考，對方也會嘗試跟上這個節奏。不要裝腔作勢來讓對方尊重自己，這樣只會適得其反，尊重對方並展現自己的專業。破窗效應自己的思考不要充滿負面，不論內在或是外在。和積極正面的人來往，自己也才能變成一樣的人。領導者的一句話，往往能左右整個組織的工作氣氛。領導者是帶領眾人前往目標的舵手。如果當情況已經不妙，領導者又持續的表達出負面的情緒，只會讓團隊陷入糟糕的情緒當中，間接的拖累整體的效率。反之，當有部署做了值得嘉許的事情時，就應該不吝於讚美對方。這代表著：我有注意你的表現，傳達出正面的能量，間接推動團體的運作。思考自身言論的影響力身為領導者，絕對要記得旁人眼光比自己想像還要敏銳。注意自己的行為、表情、和表達方式。單純很累的嘆氣，也以可能會因為身份地位的關係被做一堆的解讀。很多時候，玩笑話反而隱藏著真心話。亂開的玩笑往往會造成無法預期的後果，注意自己的言行，不要說出不經意或是會被加以詮釋的話語。表達是至關重要，做錯或是被誤解的錯誤都是不妙的：話脫口而出之前，詢問自己兩件事情：我要表達什麼大家想聽到什麼拉近彼此的關係關心人同時也是讓自己打起精神，激勵別人時其實也在激勵自己。利用這個方式開始激勵整個組織，為團隊灌入活水，讓團隊能更順暢的運作是管理者的核心任務。每個人跟人之間的距離最終會有一個最恰到好處的位置，從一開始的必恭必敬到最後的忘年之交都有可能。但請注意，並不是所有人最後都能演變成好朋友，也不是所有人都適合當朋友，抓準最適當的距離，讓你跟你的部屬(或主管)都能舒服的工作。這中間就或許是所謂的搏感情，但真心的聆聽對方說的話，仔細的聽對方闡述事情的內容，並給予適當地回應，用真心對人，才是真正正確的處事方式。","raw":null,"content":null,"categories":[{"name":"好書筆記","slug":"好書筆記","permalink":"http://www.andrewchen.tw/categoriesl/好書筆記/"}],"tags":[{"name":"重點筆記","slug":"重點筆記","permalink":"http://www.andrewchen.tw/tags/重點筆記/"},{"name":"心得分享","slug":"心得分享","permalink":"http://www.andrewchen.tw/tags/心得分享/"},{"name":"自我成長","slug":"自我成長","permalink":"http://www.andrewchen.tw/tags/自我成長/"},{"name":"溝通技巧","slug":"溝通技巧","permalink":"http://www.andrewchen.tw/tags/溝通技巧/"}]},{"title":"Git 還原單一檔案","slug":"20170211_NOTE_git還原單一檔案","date":"2017-02-11T00:45:15.000Z","updated":"2017-02-11T02:23:05.000Z","comments":true,"path":"2017/02/11/20170211_NOTE_git還原單一檔案/","link":"","permalink":"http://www.andrewchen.tw/2017/02/11/20170211_NOTE_git還原單一檔案/","excerpt":"筆記：如何將 修改到一半的檔案 還原到 追蹤前 的狀態如何將 修改到一半的檔案 還原到 最後一個 Commmit 的狀態如何將某個 指定的檔案 還原到 指定的 Commmit 的狀態","text":"筆記：如何將 修改到一半的檔案 還原到 追蹤前 的狀態如何將 修改到一半的檔案 還原到 最後一個 Commmit 的狀態如何將某個 指定的檔案 還原到 指定的 Commmit 的狀態首先假設我們有一個 demo.js 檔案。經過了以下的操作：第一次修改 demo.js -&gt; 將檔案列入追蹤 $git add ./demo.js -&gt; 第二次修改 demo.js如何將 修改到一半的檔案 還原到 追蹤前 的狀態現在想要還原成第二次修改的樣子，操作步驟直接還原即可，使用下面這個指令：1$ git checkout &lt;file&gt;備註：相同效果的指令1$ git checkout -- &lt;file&gt;如何將 修改到一半的檔案 還原到 最後一個 Commit 的狀態解除 Git 對 demo.js 已經追蹤的部分 (Unstage)：1$ git reset HEAD &lt;file&gt;依上例還原即可1$ git checkout &lt;file&gt;如何將某個 指定的檔案 還原到 指定的 Commit 的狀態查詢指定的 Commit ID1$ git log指定還原版本還原1$ git checkout &lt;commitId&gt; &lt;file&gt;參考資料：Git Docs魚乾的筆記本路破皮的部落格zlargon GitbookApple Boyvar article=$(\"#main\").html(),scriptStart=article.indexOf(\"\");article=article.substring(0,scriptStart),article=article.replace(/-&gt;/g,''),$(\"#main\").html(article)","raw":null,"content":null,"categories":[{"name":"做個筆記怕忘記","slug":"做個筆記怕忘記","permalink":"http://www.andrewchen.tw/categoriesl/做個筆記怕忘記/"}],"tags":[{"name":"程式設計","slug":"程式設計","permalink":"http://www.andrewchen.tw/tags/程式設計/"},{"name":"重點筆記","slug":"重點筆記","permalink":"http://www.andrewchen.tw/tags/重點筆記/"},{"name":"Git","slug":"Git","permalink":"http://www.andrewchen.tw/tags/Git/"}]},{"title":"人月神話 - 軟體專案管理之道","slug":"20170210_BOOKS_人月神話","date":"2017-02-10T15:00:49.000Z","updated":"2017-05-04T23:30:09.000Z","comments":true,"path":"2017/02/10/20170210_BOOKS_人月神話/","link":"","permalink":"http://www.andrewchen.tw/2017/02/10/20170210_BOOKS_人月神話/","excerpt":"人月神話堪稱經典中的經典，直到最近幾年仍然時常被提起的一本必讀書。主要在討論軟體專案管理上的問題即規劃死角，個人認為無論是程式設計師、PM 或是相關主管甚至是客戶，都值得閱讀的一本書。而我閱讀的這本人月神話是 20 週年再版的書籍，其中已經有部分的修訂，但在書的後方仍然有登載出版的觀念與思考邏輯供讀者參考。人月神話大方向的討論了：軟體專案為什麼容易失敗、如何降低失敗的機率。大致上分為兩大部分，其餘的篇章分別舉出許多細節來支撐自己的論點。作者：Frederick P.Brooks, Jr.譯者：錢一一出版社：經濟新潮社到底什麼是 “人月” 神話 ?","text":"人月神話堪稱經典中的經典，直到最近幾年仍然時常被提起的一本必讀書。主要在討論軟體專案管理上的問題即規劃死角，個人認為無論是程式設計師、PM 或是相關主管甚至是客戶，都值得閱讀的一本書。而我閱讀的這本人月神話是 20 週年再版的書籍，其中已經有部分的修訂，但在書的後方仍然有登載出版的觀念與思考邏輯供讀者參考。人月神話大方向的討論了：軟體專案為什麼容易失敗、如何降低失敗的機率。大致上分為兩大部分，其餘的篇章分別舉出許多細節來支撐自己的論點。作者：Frederick P.Brooks, Jr.譯者：錢一一出版社：經濟新潮社到底什麼是 “人月” 神話 ?人月神話這個詞要拆分成兩個名詞來看，人月 + 神話，人月 指的是每個人每月的工作時間，專案規劃時使用每人每月的工時來估計進度，利用的 人月 這個單位來計算這個計畫是否可以完成。而 神話 則是直接表達了作者認為這種規劃方式是完全不可行的。與 神話 同樣不可能發生的劇情，這也是整本書中最底層的論點：規劃的方式錯誤導致整個專案失敗。而人月中存在最明顯的問題有三個：第一，是一個人一個月的產值，通常不是 100% 發揮的。工作中會有許多的雜事影響或單純是開發者個心態、心情，各種 BUG 錯誤拖延等等，讓工時直接得低於預估的一個月工作量。第二，工時是無法堆疊的，兩個人的一月，並不等同於一個人的兩個月，軟體開發中有許多工作是有連續性的，先做完 A 才能再做 B，同時一個月加入另一個人並不會加快工作。第三，就算工作是完全可分割可同步進行的，整個專案中仍然有許多的知識迭代，無論在任何時期，加入新的人手，訓練、了解狀況都需要消耗時間，教導新手也會消耗老鳥的時間。作者更是明白的點出：在一個進度已經落後的軟體專案中增加人手，只會更加落後嘗試建立一個高度分工的團隊作者在一開始提出了一個類似 外科手術團隊 的完美架構，認為個個工程師各司其職，每個人負責好自己的區域，行程一個完美的開發團隊。核心概念是：由一個人操刀，其他人扮演支援性的角色。為了讓系統的整體架構設計有一個統一的概念，統一個設計思維。作者同意這屬於專制的團隊，由極少數人掌控著整個系統發展的方向和設計細節。理所當然的，對於這個獨裁者的技術能力、長遠的規劃視野就相當的重要。在設計模式和無暇程式碼的書中都有提到，系統、程式碼的設計最終原則就是要能體現出自己的目標，一貫的呈現風格就顯得相當重要。這邊有相當重要的一點：高度分工的團隊需要優秀的領導者，首當其衝的就是這個領導者幾乎不能犯錯，因為每個開發者對於整個團隊的了解都是片面的，如果我們片面的了解事情，有時會相當難去判斷對錯。盲目的開發下，很有可能開發出 “完全符合需求卻錯誤” 的情況，需要領導者必須能完美給予任務命令或是能及時地發現這些錯誤。同樣，這名核心管理者也需要相當能力的溝通技巧。關於溝通的部分，書中相當重視如何傳達想法。而作者的核心觀念是：完整的文件。同步這份文件、溝通的方式將會影響這整個系統的成敗。而今天的我們也知道，除了文件之外，我們有更多高階的語法、測試程式碼可以在這方面協助我們溝通。作者相當推薦大家選擇更語意化的高階程式碼，從這邊可以嗅出一點這本書的年齡。第二系統效應第二系統效應，在開發第一套系統時，會遭遇許多設計上的瑕疵，想要更多的功能，希望能重構的程式碼。會產生許許多多新的想法，但因為時間的需求或是開發上的難度，沒有辦法執行。當我在第二次開發同一個系統時，會瘋狂的將之前的願望通通加入到新的系統中，造成第二個系統的開發負擔，或是產品需求不夠明確。我們應該對一些特別的誘惑保持清醒，確保正確的概念與目標已貫徹到設計的細節之中。規劃與管理的重點在規劃上，管理者是需要相當費盡心血。管理者必須明訂，並且嘗試推動整個專案往前，分割成片段式的工作，如果規劃得不夠明確、或是直接丟出超長時間的規劃，那就準備收到一個失敗的結局，因為沒有人會去進行。而規劃排成方面，書中使用大量的專案管理技巧，包括類似瀑布式的規劃、PERT圖等等，預估工作時間是相當困難的，除了專業技巧之外，需要相當多的經驗。在專案整體的時間分割上，作者認為時間分配為：33% 規劃16.5% 撰寫程式25% 組建測試和早期系統測試25% 系統測試，完成所有組件這邊有兩大個重點：撰寫程式的時間其實只有 16.5%，而組裝和測試的時間總合高達 50%，除了規劃需要使用 33% 我並沒有足夠的經驗之外，我個人相當支持後半段的說法，在合併功能時包含的估計除錯所需的時間，的確需要為後半段發生問題的可能性，預留更多的時間。沒有銀彈專案管理到底有沒有正確的做法？有沒有真正的解決方案？答案是沒有，也沒有什麼好棒棒的工具可以解決一切的問題，沒有銀彈就是這個意思。專案管理除了專案本身難以估計之外，開發人員的問題、系統的問題、甚至是是否能應付客戶，都是會影響整個專案的結果。並沒有一個絕對的招式或是方式能解決所有的問題。仍然仰賴管理者的經驗和專業技巧。結語這本書的觀念相當清晰，除了嘗試正確預估的工時之外，其餘的部分都在傳達我們要如何寫出正整潔的程式碼，穩定的系統是快速開發的基底，高品質的程式碼能有效的降低錯誤機率，因為錯誤是拖慢專案速度的元兇殺手。在書中有提及一些東西我完全沒有提到，包括：高階程式語言、記憶體配置、專案管理的算法細節、結構設計、更好的開發工具等等，其中的內容也都是相當彩的篇章，但其實個人覺得有點跟時代脫節，舉例來說現在主流的 Git 就解決了許多作者所說的溝通和管理問題。而其餘設計細節，我認為這完全是另外的討論項目了，所以沒有在這邊多加贅述。其實這本書明顯的感受得到年紀，畢竟出版是在 30 年前，但並不是說觀念老舊或是不合時宜。換而言之，我們現在手邊更多作者當初所期待的方便的工具，能協助我們來解決對應的問題，例如 Git, Github 就是很好的例子，讓我們能擁有便捷的溝通方式，而且是直接在程式碼上做溝通，測試、文件工具等等現在更是發展的一應俱全，如何利用這些配套的工具強化團隊效率，反而是我們當今的課題。","raw":null,"content":null,"categories":[{"name":"Code要好好寫","slug":"Code要好好寫","permalink":"http://www.andrewchen.tw/categoriesl/Code要好好寫/"}],"tags":[{"name":"讀書心得","slug":"讀書心得","permalink":"http://www.andrewchen.tw/tags/讀書心得/"},{"name":"程式設計","slug":"程式設計","permalink":"http://www.andrewchen.tw/tags/程式設計/"},{"name":"重點筆記","slug":"重點筆記","permalink":"http://www.andrewchen.tw/tags/重點筆記/"},{"name":"心得分享","slug":"心得分享","permalink":"http://www.andrewchen.tw/tags/心得分享/"}]},{"title":"CleanCode 無瑕的程式碼 (下篇)","slug":"20170205_BOOKS_CleanCode1-2","date":"2017-02-05T15:50:49.000Z","updated":"2017-03-03T15:37:31.000Z","comments":true,"path":"2017/02/05/20170205_BOOKS_CleanCode1-2/","link":"","permalink":"http://www.andrewchen.tw/2017/02/05/20170205_BOOKS_CleanCode1-2/","excerpt":"作者：Robert C. Martin譯者：戴于晉、博碩文化審校：陳錦輝出版社：博碩文化CleanCode 無瑕的程式碼 (上篇)接續著前一篇，無瑕的程式碼前半段著重於程式碼的季節面，下半段討論更多大方向的目標，討論規劃系統架構、測試、程式碼橋接規劃等，不再是單一個程式設計師自己撰寫程式碼的世界觀，書中講述更多的團隊運作方式和長期規劃方面的觀念。從更高的視角看整潔程式碼除了命名正確之外，個人的經驗是當系統成長到一定的規模時，開發者會不願意去面對舊有的程式碼，就算命名相當正確、易讀易懂，但修改或新增功能總是需要大動干戈，綁手綁腳的東修西改。同時因為這個原因，常常讓我放棄重構的念頭，有時甚至是直接刪掉某個部份的程式碼重來。想當然爾，這種錯誤只會日積月累，屆時將會進入完全無法挽回的地步。及早發現、儘早治療。畫圈圈耍自閉，跟其他人劃清界線","text":"作者：Robert C. Martin譯者：戴于晉、博碩文化審校：陳錦輝出版社：博碩文化CleanCode 無瑕的程式碼 (上篇)接續著前一篇，無瑕的程式碼前半段著重於程式碼的季節面，下半段討論更多大方向的目標，討論規劃系統架構、測試、程式碼橋接規劃等，不再是單一個程式設計師自己撰寫程式碼的世界觀，書中講述更多的團隊運作方式和長期規劃方面的觀念。從更高的視角看整潔程式碼除了命名正確之外，個人的經驗是當系統成長到一定的規模時，開發者會不願意去面對舊有的程式碼，就算命名相當正確、易讀易懂，但修改或新增功能總是需要大動干戈，綁手綁腳的東修西改。同時因為這個原因，常常讓我放棄重構的念頭，有時甚至是直接刪掉某個部份的程式碼重來。想當然爾，這種錯誤只會日積月累，屆時將會進入完全無法挽回的地步。及早發現、儘早治療。畫圈圈耍自閉，跟其他人劃清界線邊界，是系統設計中一個簡單易學且效益極高的設計重點。以 Node.js 來說，會頻繁地使用到第三方套件，而更新第三方套件、客戶更改需求、或抽換相依套件，以上這些動作相當的困難且風險極高。小幅度的更改讓系統看似沒有問題，但完全不知道啥時會爆炸出個莫名其妙的 Bug。當有大範圍需要修改時更是可怕，個人經歷是改下去以後，東邊爆炸西邊起火，搞了老半天系統還沒正常過，好不容易穩定下來後來仍然令人疑心疑鬼。邊界最單純的作法就是在引用第三方套件時，包裝一次成為自己的介面，這個包裝的地方，即可視為所謂的程式碼邊界。爾後開發統一引用包裝過後的介面，而邊界函數橋接的第三方套件則是外部程式碼，明確的劃清雙方的界線。透過定義自己程式的邊界，明確的定義自己的維護案範圍，並同時降低了對外的耦合，避免雙方程式碼高度的交織。並針對使用中的介面撰寫一套測試，確保對外的依賴運作正常，在升級版本時即可大幅地減輕痛苦。而升級時如果對方API有修改，透過邊界一次性的修改即可，不須逐一在專案中追逐散落在各個角落的引用。另一個角度，開發時也可以利用邊界，在其他API尚未完成時進行開發，完成後再橋接邊界另一半的程式碼。測試程式碼是一種品質保證無論是否是利用 TDD ( Test-driven Development，測試驅動開發)，測試仍然一樣的重要。除了上述的邊界測試、減輕修改程式碼負擔之外，測試更有心理層面的效果：給予開發人員修改的信心。讓我們在修改程式碼後，確認功能仍然正常運作。測試分為相當多個層級，在許多書中有不同的論點。個人的經驗是至少要對系統的最核心功能有一套測試保護，並模擬使用者整個操作的流程，這樣能在最簡單的情況下，保證著系統還算是正常的運作，不至於整個系統崩潰了卻無人知曉。以 EC 來說，最核心就是結帳功能，如果能時時確保功能正常，是完全沒有爭議的好事情。如果讓你的測試程式碼腐敗，那麼你的產品程式碼也會跟著腐敗。請保持你的測試整潔。雖然說測試的速度並非首要，但會影響到開發人員的效率或是心態，因此頻繁、簡便、快速的測試仍然是很重要的，細心的維護您的測試程式碼：多弄幾次整理好重構，基於有測試保護功能正常，開發者能放心的重構程式碼，將程式碼重構成理想的結構，更加明確的表態功能作為，甚至是修改效能、強化防呆等等。在許多書中都提及相同的開發經驗：請立即重構，不要擱置。擱置重構只會讓這個問題繼續蔓延下去，放著放著忘記了，之後就沒人管了。這個污痕將會永留存。立即重構也利於開發速度，開發者也對相關狀況最清楚的時候重構程式碼，成本也相對低的。這些都是常見的致命陋習書中在最後的篇幅大幅度的探討常見的錯誤，諸如：不適當的註解程式碼修改後沒有跟著修改註解、多餘的廢話等等。註解應該保留給技術性紀錄。而冗餘的註解程式碼，就刪掉他吧！我們都有 Git 了！亂來的函數函數在沒有特地請求的情況下”順便”回傳了其他資料，這會造成其他開發者的困擾，只因為我們在其他邏輯上將這兩個功能結合在一起，正確的做法是徹底的切割功能。旗標參數，我之前就常犯這個錯誤，在函數的傳入參數中加上類似 flag:boolean 的參數，讓函數能根據 flag 變化，錯誤相當明顯：這個函數做了兩件事情，pure function 才是王道啊。函數中如果真的有複數的操作，請明確地反映在函數名稱上面，雖然說函數上方能撰寫說明註解，但更多的狀況是開發者在其他處看到類似的功能，複製後就直接嘗試使用。請用大眾化的思考方式思考最少驚奇原則，當然系統中會有很多巧妙的設計，但撰寫程式碼時讓其他程式設計師訝異不是件好事情，無意義的多回傳東西，多修改其他地方的值或是參數等等，都是屬於不必要的功能，甚至造成無意義的困擾。當然也不要無意義的炫技，讓人看得懂的程式碼才是最好的。減少整個專案中重複的程式碼，嘗試利用已經擁有的功能，或是在已經擁有的套件中擴充功能，有時閱讀別人的程式碼很令人煩躁，但事實這就是這樣，屢次的堆疊新功能和新程式碼上去，雖然有明顯的短期收益，但對整體專案的健康影響是相當大。找到重複的地方，並移除這些重複。而程式碼的排序、編排方式也是相同的，專案中使用一樣的 Coding Style 算是相當基本的要求。命名也是相同的邏輯，temp, tmp 在普遍的認知中就是暫存用的資料，如果是使用者資料請用 user, users 等等，濫用無意義的命名會帶來更多的痛苦。1234// 有講跟沒講一樣的 function namefunction dataOperator(data) &#123; // ...&#125;在許多複雜的結構設計中，遵循設計模式是個不錯的選擇，簡單地表明是工廠模式、橋接模式等，會為閱讀者帶來更明確的方向和視野。不要偷懶偷懶是一切問題的開始，正確地表達程式碼語意，在短期上面看似工作效率更低，但多為未來的自己著想，不要偷懶不撰寫測試程式碼或是文件，這些東西在往後會以更高的成本出現，趁早完成對大家都有好處。如果 PM 或是老闆不同意，嘗試說服他吧！同時，當我們在修補 Bug 時，也可以試著為 Bug 補上對應的測試，避免後人犯錯，同時詮釋了自己這次修改的程式碼原因。結語在無瑕的程式碼中，有一部分的章節討論多執行緒的開發與設計，在這部分的內容我並沒有寫進心得中，主因是我撰寫這個部落格時技術核心是選擇：Node.js。我仍然相當推薦書中的內容，嘗試透過多執行語言的開發問題來反思非同步開發，是相當有助益的。而整本書帶給我的，最多的是開發上的思維整理，會突然想到說：啊！原來就是因為當初那樣寫才…。有很多錯誤都是我在學生時期犯過的，在工作之後有嘗試著改變，閱讀此書之後大大的幫助我整理，讓思路更明確且清澈，同時也明確的感受到前人犯下的錯誤，期許自己能在程式開發生涯中，更自律的要求自己。","raw":null,"content":null,"categories":[{"name":"Code要好好寫","slug":"Code要好好寫","permalink":"http://www.andrewchen.tw/categoriesl/Code要好好寫/"}],"tags":[{"name":"讀書心得","slug":"讀書心得","permalink":"http://www.andrewchen.tw/tags/讀書心得/"},{"name":"程式設計","slug":"程式設計","permalink":"http://www.andrewchen.tw/tags/程式設計/"},{"name":"重點筆記","slug":"重點筆記","permalink":"http://www.andrewchen.tw/tags/重點筆記/"},{"name":"心得分享","slug":"心得分享","permalink":"http://www.andrewchen.tw/tags/心得分享/"}]},{"title":"CleanCode 無瑕的程式碼 (上篇)","slug":"20170205_BOOKS_CleanCode1-1","date":"2017-02-05T14:55:10.000Z","updated":"2017-05-04T23:29:57.000Z","comments":true,"path":"2017/02/05/20170205_BOOKS_CleanCode1-1/","link":"","permalink":"http://www.andrewchen.tw/2017/02/05/20170205_BOOKS_CleanCode1-1/","excerpt":"無瑕的程式碼，其實是我第二次詳細閱讀這本書。第一次是在大學一年級，剛開始寫程式的我根本完全看不懂書中在寫什麼啊！每字每句話都能看懂，卻完全無法理解意義或是體悟到任何的道理，丟在書架上幾年後，工作之餘再重新看了一次。這次感觸良多，有些是我犯過的錯，有些對我來說是重要的警告。總之，我認為這是一本程式設計師必讀的書，說是學習一種新的知識或是撰寫技巧其實並不精確，個人覺得是幫助自己釐清撰寫程式碼時的思考、自我反省的一本書。看完這本書仍然取決於我們自己要改變多少做事的風格。作者：Robert C. Martin譯者：戴于晉、博碩文化審校：陳錦輝出版社：博碩文化CleanCode 無瑕的程式碼 (下篇)為什麼需要花時間維程式碼的整潔？真正的”無瑕”的程式碼的定義是什麼？在第一章節作者給了一個大概的方向：無暇程式碼就是在追求程式碼的表達能力，且沒有任何一個流派是絕對正確的。維護整潔的程式碼，不僅僅是程式設計師對於專業的自我要求，也是在日益龐大的系統開發中，迫切需要重視的問題。或許在小型的專案中我們能仰賴記憶力、猜測、或是一些經驗推導來維持整個專案的運作。隨著團隊的人數擴增、專案程式碼行數的成長、甚至單純是客戶的要求朝三暮四的變化，整潔的程式碼開始成為必要的開發條件，不論是實質上的效率問題，甚至是影響到日後的修改、維護，缺乏整潔觀念的程式碼必然會帶來一場災難。整潔程式碼的第一步討論變數命名、函數、註解、程式碼編排等等細節的技巧，在這部分我在學生時期就有特別在注意，但往往沒有相當明確的方向與見解，以下綜合書中的資訊和我在職場前輩身上學到的智慧，大致整理成以下幾個重點：","text":"無瑕的程式碼，其實是我第二次詳細閱讀這本書。第一次是在大學一年級，剛開始寫程式的我根本完全看不懂書中在寫什麼啊！每字每句話都能看懂，卻完全無法理解意義或是體悟到任何的道理，丟在書架上幾年後，工作之餘再重新看了一次。這次感觸良多，有些是我犯過的錯，有些對我來說是重要的警告。總之，我認為這是一本程式設計師必讀的書，說是學習一種新的知識或是撰寫技巧其實並不精確，個人覺得是幫助自己釐清撰寫程式碼時的思考、自我反省的一本書。看完這本書仍然取決於我們自己要改變多少做事的風格。作者：Robert C. Martin譯者：戴于晉、博碩文化審校：陳錦輝出版社：博碩文化CleanCode 無瑕的程式碼 (下篇)為什麼需要花時間維程式碼的整潔？真正的”無瑕”的程式碼的定義是什麼？在第一章節作者給了一個大概的方向：無暇程式碼就是在追求程式碼的表達能力，且沒有任何一個流派是絕對正確的。維護整潔的程式碼，不僅僅是程式設計師對於專業的自我要求，也是在日益龐大的系統開發中，迫切需要重視的問題。或許在小型的專案中我們能仰賴記憶力、猜測、或是一些經驗推導來維持整個專案的運作。隨著團隊的人數擴增、專案程式碼行數的成長、甚至單純是客戶的要求朝三暮四的變化，整潔的程式碼開始成為必要的開發條件，不論是實質上的效率問題，甚至是影響到日後的修改、維護，缺乏整潔觀念的程式碼必然會帶來一場災難。整潔程式碼的第一步討論變數命名、函數、註解、程式碼編排等等細節的技巧，在這部分我在學生時期就有特別在注意，但往往沒有相當明確的方向與見解，以下綜合書中的資訊和我在職場前輩身上學到的智慧，大致整理成以下幾個重點：排版、正確註解排版和正確語意的註解是相當基本的東西，基本除了不要亂雷別人之外，沒有什麼爭議問題。最需要討論的應該就是註解的量，有些開發者會相當仰賴註解把事情說清楚，而另一派的開發者認為，當前開發的語言幾乎都是高階語言了，我們透過變數和函數的命名就應該將事情說明清楚。我個人是支持後者的說法，在工作經驗中也是比較偏向後者的作風。註解只用來補足某些程式碼無法陳述的部分而已，嘗試更精確地名命、重構程式碼才是正確的整潔方式。而註解掉的廢棄程式碼則是完全不應該出現的，刪除時應當對程式碼負責。總之，這是版本控管的事情了，他本身就不應該留在那邊。註解下來的程式碼，只會變成永遠的殘存程式碼放在那邊而已，而沒有人敢去刪除它，留著他感覺很重要，但是註解掉就代表不需要了。不要白目、避免自己犯錯不論是常數、變數、函數甚至類別命名等，最重要的事情是如實的反應內容，當然擁有很多命名的規則，或是慣用的習慣，但最大的重點是忠實的反應實際上的內容。同時不要使用無意義的命名：諸如 tmp, data 這些命名其實是我在學生時期撰寫程式碼常用的，當然因為我多半是一個認自己寫，我總是知道 tmp 我多半用在拆解資料，data 通常我用在 API 或是函數回傳的資料。但真正的主因是學生時期的系統往往不太複雜，就算我繳交過最複雜的幾個 APP 和選課系統，往往都是瀑布式開發，一次完成的。命名最大的影響在於：當我們回頭看自己的程式碼時。當我們回頭追尋問題、修改功能、甚至是看別人的程式碼時，這些無意義的命名將會造成很大的影響，問題小則浪費時間，大則用錯變數、重疊使用變數，造成交叉感染。當然白目的命名就更不可取了 magicNumber、justDoThis() 等，當我們自己在撰寫時可能覺得情投意合，完全表達了我們想表達的狀況，但往往會造成更多的誤導。而在命名的選擇中，需要仔細的衡量 “完全表達內容” 和 “避免贅述”，並且找到適當的平衡點，不要一昧的把變數名稱拉長來完整描述狀況，適當即可。何謂適當？我自己認為這就是專業的 Developer 和 Programer 之間的第一個差距，在龐大的組織中會針對開發做細節的規範，但如果只會死板地遵循規範，不應該是一個稱為智力型工作者的 Developer 該有的樣子。函數即映射這是在前一份工作的前輩指點，幾個月前的自己對於函數命名犯下許多錯誤，但當時並不知覺，在之後雷到自己。函數即映射 很明確的指出，每個函數的名稱應該正確的描述自己內部的行為，同時可推導出 pure function 的觀念，一個操作或是一個動作，就是一個函數，片段的函數在組合包裝成更大的功能，層層包裝之中，必須分工明確，這樣才能完整地描述整件事情的操作流程。這其中有一個相當重要的觀念需要注意，函數不應該有副作用，超出預期功能的函數並不會比較方便，而是製造更多的麻煩而已。善用物件及資料結構來表達類似於封裝的觀念，了解物件真正要做的事情是什麼，完整的命名後打包，正確的封裝來避免外界的干擾，同時也是減少對外界傳達不必要的資訊。而針對 Node.js 在這部分的觀念，個人認為重點是善用第三方套件，用大家熟機的套見就像使用物件一樣，將程式更明確的語易化，而熟悉的套件功能，也減少了閱讀程式碼的成本，更明確的闡述一切。舉例套件 lodash，lodash中友需許多多已經包裝好的片段功能，協助我們取出資料、整理資料等等，很多功能其實也只要單純一兩個迴圈加上幾個if便可以完成，但在不考慮效能的情況下，第三方套件會比自己撰寫的迴圈來得更語意明確。層層的錯誤處理錯誤處理是大型型系統開中最重要的環節，在中後期開發或是功能橋接的階段，不可避免的事面對各種錯誤，而如何尋找出錯誤，除了仰賴工程師自己的技巧之外，透過錯誤處理系統正確的承接錯誤的來源也相當重要，正確的定義每個錯誤，避免整個系統只使用少數幾個甚至一個錯誤包裝。先前我覺得全域是的承接錯誤很方便很帥，結果在系統開發中後期造成了不少的困擾。當然逐層追回仍然能解析出來錯誤真正的原因，但是在每個承接錯誤的地方加上註記，或許會來得更好。","raw":null,"content":null,"categories":[{"name":"Code要好好寫","slug":"Code要好好寫","permalink":"http://www.andrewchen.tw/categoriesl/Code要好好寫/"}],"tags":[{"name":"讀書心得","slug":"讀書心得","permalink":"http://www.andrewchen.tw/tags/讀書心得/"},{"name":"程式設計","slug":"程式設計","permalink":"http://www.andrewchen.tw/tags/程式設計/"},{"name":"重點筆記","slug":"重點筆記","permalink":"http://www.andrewchen.tw/tags/重點筆記/"},{"name":"心得分享","slug":"心得分享","permalink":"http://www.andrewchen.tw/tags/心得分享/"}]},{"title":"被討厭的勇氣 (下篇)","slug":"20170131_BOOKS_被討厭的勇氣1-2","date":"2017-01-31T11:10:15.000Z","updated":"2017-05-04T23:29:32.000Z","comments":true,"path":"2017/01/31/20170131_BOOKS_被討厭的勇氣1-2/","link":"","permalink":"http://www.andrewchen.tw/2017/01/31/20170131_BOOKS_被討厭的勇氣1-2/","excerpt":"接續著上半篇的心得，後半部的阿德勒開始討論自我定位的問題，當我們完全脫離別人的看法之後，我們自己該如何定位自己？更該如何跟別人相處，如何繼續地用自己的方式，在社會的洪流中生活下去。作者：岸見一郎、古賀史健譯者：葉小燕出版社：究竟出版被討厭的勇氣 1 (上篇)個體心理學與整體論","text":"接續著上半篇的心得，後半部的阿德勒開始討論自我定位的問題，當我們完全脫離別人的看法之後，我們自己該如何定位自己？更該如何跟別人相處，如何繼續地用自己的方式，在社會的洪流中生活下去。作者：岸見一郎、古賀史健譯者：葉小燕出版社：究竟出版被討厭的勇氣 1 (上篇)個體心理學與整體論無法再分割的最小單位。精神與肉體無法分割、理性與情感無法分割、意識與無意識無法分割這邊指的無法分割是指我們在表達情緒時，整體是不可分割的，當我們在發脾氣時、在爭論時，理性與情感是無法分割的，也就是無論我們多麽理性，我們仍然是透過整個整體在與人溝通，無論如何都是兼具了理性與感性。人際關係的終極目標在於 “社會意識”把別人當成夥伴，並感覺到有自己的歸屬，稱為社會意識。共同體，共同體的目標也是整個社會。把對自我的執著轉變成為對他人的關心。你不是世界的中心為什麼只關心我?做不到 “課題分離”，被認同需求束搏的人，也是極度以自我為中心的。阿德勒的觀點為：希望自己取得社會的認同，這個觀點也只是從自己出發而已。只在乎別人是如何看我的這種生活方式，就是所謂的自我中心，只關心”我”的生活型態。別人並不是為了滿足你的期望而活，你只是共同體的一部份，不是中心。重新去思考自己能帶來的價值，能為大家貢獻什麼，而不是單純的思考自己能從大家那邊得到什麼。而為大家帶來什麼貢獻，這點是出自於善意，並不是為了獲得大家的讚賞，而是實質的非強迫性幫助。歸屬感避不是與生俱來的，而是要靠自己的雙手去獲得。人際關係 –&gt; 課題分離 –&gt; 社會意識社會意識的觀點在於共同體，不斷拉高自己的高度，透過巨觀的思維來看整件事情。不要把事情看得很單一，例如：誰誰誰不愛我了，我的人生…。要拉高看事情的維度與角度，瞭解到這些事情是本來就有可能發生的，並不是針對自己，遭遇變故後這整個世界也仍然在運轉，並沒有因此而停止。在害怕關係崩壞的恐懼下過日子，其實只是為別人而活，是不自由的生活方式。不責罵，也不稱讚背後的目的都是操控。如果透過單一手段的話，很容易二元化整個世界的事情，並開始追究是非對錯，達成事情只是為了避免責罵，或獲得獎賞，當我們抽掉賞罰時，會感覺到是事情是沒有意義。這個心態並不樂見。阿德勒心理學否定縱向關係，支持一切的橫向關係。縱向關係就是導致介入他人的課題的直接原因。因為覺得自己會處理得比對方更好。縱向關係會在自己的對外的各個感情中傳染，當你用縱向關係的心態去瞧不起某人時，另外一方面就投射出縱向關西的崇拜或是尊重另一個人，反之亦然。當我們用縱向關係在看但人際關係時，就會出現階級的情況，這會讓人際關係陷入利益的狀態，例如跟XXX約遲到一下沒關係，但是跟OOO約絕對不能遲到。而這種縱向關係最終會反映在重要的事情決策上，或是面對對方的態度。只要你與任何一個人建立了縱向關係，不知不覺間你所有的人際關係都會採用縱向的方式。關於稱讚稱讚是一種有能力者給無能力者的評價。責備容易導致迴避的處事行為，不斷地稱讚會導致被稱讚的人缺乏信心，稱讚也常常讓人誤解是為了稱讚而稱讚的。這邊的情緒處理相當的複雜，真誠與誠實是相當難掌握的，說者無心聽者有意，純粹的鼓勵往往令人起疑。人只有在自己有價值的時候，才會有勇氣。感謝，或是橫向的稱讚，都屬於比較好的方式。讓人感覺到對整件事情有幫助，感覺到自己有價值。因此肯定他人的作為，是一個更扎實的稱讚方式。(在兼具情與理的表達方式一書中有類似的說法)。當一個人覺得我對共同體來說是有益的時候，就能感受到自己的價值。這邊就詮釋了自卑感議題，為了追隨別人的觀感，在自己的心中映射出理想的自己，現在的自己與理想中的自己有差距，進而產生了自卑感，這個自卑感也有可能用自傲、炫耀來包裝。自卑感有可能產生動力，也有可能找藉口來詮釋這個自卑感，這時就成了人生的謊言，用來迴避自己無法解決的課題。獲得感謝不是從別人那裡獲得好的評價，而是自己主觀的認識我對別人有貢獻，間接地解決了自卑感的問題，接著有可能可以逐漸解開人生的課題，這屬於一種橫向的幫助，比縱向的幫助、直接性的稱讚來的有效果。只要存在，就有價值我們不以行為的層級，而是已存在的層級來看待別人。社會意識，必須以人開始去做。就算其他人不配合，也和你沒關係。應該由你開始，完全不必考慮其他人是否提供協助。這大概是整本書最接近我自己核心思想的一句話。但難免受傷、難免難受。有本書 “把這份愛傳下去”， 核心邏輯就是這個，總要有人開始，而不計代價。這樣就能像湖中的漣漪，傳遍整個水面。由自己開市就是最好的方式。小結交友的課題，不只單單是交朋友，包括與朋友相處上的關係，職場上的人際手腕等等，與整個社為的人相處的關係，這遠比想像中來得複雜，這包括了人與人之間的對等溝通，並且透過自己讓社會變得更好。幫助的不只是整個社會，同時也是在幫助自己，與社會地位比自己低的人建立橫向關係，同事就是在幫助自己與長輩建立橫向溝通的方式，也消除了自己的自卑感。認真地活在當下過多的自我意識，反而牽制自我不是肯的自我，而是接納自我接納自我信任他人貢獻他人接納自我接納自我跟肯定自我是不同的，自我肯定是肯定成功，說服自己能辦到，接納自我是接受那個失敗的自己，當失敗時無力挽回。並在接納之後，繼續的盡最大的努力前進。積極正面的斷念這就是整個阿德勒心理學最重要的核心價值之一，積極正面，明確的了解自己該做什麼，並且壁面自己陷入過往的泥沼中。不過份的肯定自己，正面的為自己努力，同時嘗試去幫助他人，一切是為了讓自己更好，讓自己對攝位多少有點貢獻。主啊求你四我平靜的心，去接納無法改變的事情;賜給我勇氣，去改變可以改變的東西;並賜給我智慧，去分辨這兩者的差異。— 尼布爾&lt;寧靜的祈禱文&gt;我們並非能力不足，只是缺乏勇氣而已。信用和信任有什麼不同相信別人的時候不附加任何條件，再怎麼樣無條件信任他人，最後不過是遭受背叛而已。重點並不是無條件的幫助別人，應該是在能力範圍內，而在幫助別人時，就只是幫助而已。不要在對方請求幫助時馬上產生懷疑，人跟人互相猜忌，會變得更複雜，觀念與 “把這份愛傳下去” 雷同，只要關心自己怎麼做就好，關心自己能不能幫助人，而不是反覆思考是否受到詐騙。只要你害怕信任，終將無法與人建立深厚的關係。這邊的論點在現實社會中比較難令人接受。這篇像大同世界的思考，屬於一種改變世界的手段，如果從現在起每個人都真誠以待，那這個世界就會變得更單純、更歡樂。工作的本質在於對他人貢獻所謂的貢獻他人並不是捨棄自我去為某人鞠躬盡瘁，而是為了實際感受自我的價值在整體社會共同體中，社會意識是讓自己有安全感的來源。可以說是一種存在感、自我價值感。阿德勒心理中認為，改變自我需要呼費過去 50% 的歲數時間也就是 20 歲的人需要花 10 年改變，同理，越年輕的人開始嘗試是理解，就能越早改變。工作狂是人生的謊言無論在哪種情況下，發動攻擊的那個人是有問題的，絕不是大家都錯了。這邊同事要思考，自我價值、情緒是種工具以及社會意識。人與人之間相處的方式。別把焦點放在無關緊要的小部分，甚至打算用狹隘的觀點來評論全世界。這種事情的極端狀況就是憂鬱症、躁鬱症等行為。但也有可能是比較讓然感覺正面的事情：工作狂。以工作為藉口迴避其他責任。以工作為藉口迴避其他人生的課題。交友的課題、愛的課題。這種就屬於先前提到的：行為層級。以自身的行為定義自己，並不是真正的存在的層級，不夠透徹了解自身的價值。由這一瞬間開始變得幸福阿德勒認為：幸福來自己認定自身的價值。自己所做的貢獻，可能可見或是不可見。所謂的幸福，就是貢獻感。這就屬於社會意識的範疇，了解自己的存在、自己的貢獻後就不需要別人的人同來定義自己的供獻。不屬於追求別人的認同感時，就能放下那個來自人際關係的包袱不必成為別人或是某個自己期待受到肯定的人，而是自己就是自己，自我認同，就不會以行為的層級，而是真正存在的層級參與社會的共同體。想成為特別存在的人有兩條路為了得到別人的關注，脫離普通的狀態，成為特別的存在有可能特別好，也有可能特別壞。當我們透過不太正當的手段追求受到關注，例如小孩子的打鬧，或是其他蓄意引人注目的問題，屬於簡便的追求卓越，追求的是自己受到關注的感覺，某種層面上，這也屬於一種自私的行為，單純為了滿足自己而已。甘於平凡的勇氣我們沒有必要刻意誇耀自己的優越性人生是一連串的剎那活在當下。追求的是此刻的心態，回頭時候看到許多光彩，這邊的觀念偏向說，並不是所有的事情都要完美個站照規劃達成，才能擁有好結果。如果你去爬山，計畫爬到山頂，可是爬了一半就下來，仍然是去爬山，並不是一切都要按照計畫的完美執行。而是當下最努力的我們，才適當我們在回憶時最甘甜的剎那。過去發生什麼事情，和當下沒有關係，而未來會如何，也不是當下要考慮的問題。不要用直線去衡量自己已經走到了哪裡，要看看每個剎那是如何度過的。從更現實的角度來看，如果我現在即刻身亡，我會後悔什麼，我最在意的是什麼，這就是這個剎那。這相當的難實踐。只要貢獻他人這顆引導之星還在，就不會徬徨，做什麼都可以。將自己導向正確的路途上必須有人開始去做。就算其他人不配合，也和你沒關係。這就是我的建議。應該由你開始，完全不必考慮其他人是否提供協助現在，就是現在，當我們想通的這一瞬間。","raw":null,"content":null,"categories":[{"name":"好書筆記","slug":"好書筆記","permalink":"http://www.andrewchen.tw/categoriesl/好書筆記/"}],"tags":[{"name":"讀書心得","slug":"讀書心得","permalink":"http://www.andrewchen.tw/tags/讀書心得/"},{"name":"重點筆記","slug":"重點筆記","permalink":"http://www.andrewchen.tw/tags/重點筆記/"},{"name":"心理學","slug":"心理學","permalink":"http://www.andrewchen.tw/tags/心理學/"},{"name":"自我成長","slug":"自我成長","permalink":"http://www.andrewchen.tw/tags/自我成長/"}]},{"title":"被討厭的勇氣 (上篇)","slug":"20170131_BOOKS_被討厭的勇氣1-1","date":"2017-01-31T02:20:15.000Z","updated":"2017-05-04T23:29:17.000Z","comments":true,"path":"2017/01/31/20170131_BOOKS_被討厭的勇氣1-1/","link":"","permalink":"http://www.andrewchen.tw/2017/01/31/20170131_BOOKS_被討厭的勇氣1-1/","excerpt":"2015年最火紅的&lt;被討厭的勇氣&gt;，有別於一般心理學書籍，作者從個人心理的觀點來探討個人跟整個社會的互動，把焦點放在自己身上，了解自己、改變自己，不再是去瞭解他人或是嘗試透視對方的想法。思考自己在做什麼，讓自己的外在表態或是內在的心靈強化是書中相當明顯的觀點，而當我們自己變得更好時，或許也能帶動身邊的人跟著改變。作者：岸見一郎、古賀史健譯者：葉小燕出版社：究竟出版被討厭的勇氣 1 (下篇)否定心理創傷","text":"2015年最火紅的&lt;被討厭的勇氣&gt;，有別於一般心理學書籍，作者從個人心理的觀點來探討個人跟整個社會的互動，把焦點放在自己身上，了解自己、改變自己，不再是去瞭解他人或是嘗試透視對方的想法。思考自己在做什麼，讓自己的外在表態或是內在的心靈強化是書中相當明顯的觀點，而當我們自己變得更好時，或許也能帶動身邊的人跟著改變。作者：岸見一郎、古賀史健譯者：葉小燕出版社：究竟出版被討厭的勇氣 1 (下篇)否定心理創傷心理創傷並不存在阿德勒心理學明確的否定心理創傷。不要由經驗來決定自我，而是由經驗賦予的意義來決定。我們每個人都為了某個目的而活著。應該追究的，不是過去的原因，是現在的目的。決定論目的論決定論因果關係，就是典型的決定論。因為什麼原因，造成現在這樣。雖然看似邏輯正確，但心中其實是將事情的結果推向過去的自己，否定現在的是幾，從某個方面來說我們往往忽略了人能掌控自己的情緒，面對失敗，了解原因及可，不要將責任推給過去。目地論目的論的觀點認為，人的每個行為、情緒變化等等，都是有目的性的，我們透過表達自己的情緒，來得到自己想要的成果。與決定論完全相反的是，決定論認為：”我因為XXX事情，所以我現在生氣了”，但在目的論認為：”你現在生氣，是為了達成ＯＯＯ目標”。舉例來說，決定的論點是：”因為你掃地沒掃乾淨所以我生氣”，認為”我生氣是別人造成的”。目的論則認為：當下在生氣時，其實是透過情緒表達，希望對方折服自己並認真打掃，情緒變成了一種手段，而非被動的產物。(透過這個論點可以反思，我們是能控制自己的情緒的，能收放自己的情緒。)人，會捏造憤怒的情緒即是目的論的核心論點。藉由捏造的憤怒的情緒，來達成某種目度。這種情緒並不是所謂的 “無法控制” 或是 “衝動”。如果人們能夠不遷怒，那就代表憤怒是可以收放自如的 “工具” 。我們藉由憤怒的情緒來讓自己的行為合理化，是一種使人屈服於自己的手段。不受過去支配的生活方式不論是從 “人不受過去控制” 或 “人不受情緒控制” 的層面來說，阿德勒心理學都是與虛無主義者對立的思想，是哲學。問題不在於過去發生了什麼事情，而是我們怎麼去解釋它。例如說成功的喜悅可能沖昏頭，失敗可能激起更多的浪花。每個人的生命中都會發生各種產生正面利益或是負面利益的事情，重點在於我們怎麼去詮釋狀況，從發生的狀況中我們得到或是學習到什麼。人並非受過去的原因而行動，而是朝向自己決定好的目的而行動。改變改變的第一步是要先知道。答案，不應該是由誰告訴你，而是你自己親手去找才對。改變、成長都需要靠自己，一切的起頭也需要自己來。過程中的經歷才能淬煉成結果。不斷地灌輸觀念，不如人自己反思、自我思考。幸與不幸，是自己選的沒有人單純只是為了做壞事而做壞事，所有犯罪的人都有讓他犯罪的內在 “正當理由”。例如，因為金錢糾紛而殺人，對當事人來說，他因為自以為的 “正當理由” 而採取行動。換句話說，是在執行 “自以為好” 的 “善” 事。當然，這裡所說的 “善” 並不是指道德上的良善，而是 “為自己的” 善。希臘語中的 “善” 跟道德沒有關係，純粹是 “有用” 的意思;另一方面 “惡” 是指 “沒有用處”。我們往往選擇對自己有利的狀況，可能自覺、可能不自覺，這種有利的狀況多半屬於短期有利，當下自己覺得舒服或方便而已，有可能是安於現狀，亦可能只是面子掛不住。所謂的 “目的論” 就是指人們只是為了達成某種目的，而做出的情緒反應而已，並透過其他的原因來詮釋現在的自己。但多半的時候人們透過 “決定論” 來解釋自己也是情非得已，並沒有了解到自己內心中正正的目的性。人，常常決定不要改變生活型態 life style是人的性格或是氣質。並非直接指物質的生活狀況。如果生活性態不是天生的，而是自己選的，那就有重新選擇的可能性。人們往往不願意改變，儘管自己已經知道有地方需要改變，儘管知道已經造成別人的抱怨，但往往我們覺得 “安於現狀” 是輕鬆的，不確定的未來，人們總是不願意去冒險。缺乏便幸福的勇氣。人生決定於當下一種捨棄現有的生活型態的決心。就像在第一次做壞事一樣，變好一樣也需要有改變的勇氣，第一次運動時會覺得想放棄，同樣的，第一次偷東西的人，也會猶豫或是考慮要不要收手。無論之前你的人生發生過怎麼樣的事，那對於你將來要怎麼過日子一點影響都沒有。人生過去的影響，實際真正的影響在於精神層面，而精神層面應該是能理性控制的。小結貫徹了之前我自己聽過的一句話：感性的事情要用理性解，理性的事情要用感性解。人生中有很多機會可以選擇，對於過去，重點是是從過去學習到什麼，或是從過往的經驗了解什麼。而不是一味的埋怨過去對自已造成傷害，因為過去的種種如果，所現在如何。人的所有的情緒、反應都是有目的性的。表達難過可能是為了得到安慰，憤怒是為了使人屈服、表達自己的強悍，情緒是能收放的。當然，人必定會有情緒，接受內在的情緒之後，不一定要對外表態出來，我真正需要學習的，是處理自己內心的情緒即可。而生活的現狀，取決於自己的思考，換而言之，現在的生活狀況是自己決定的，就如：”如果我有空的話..我就…”事實上是在為自己找藉口，為自己尋找 “結果論” 的原因，安慰自己。做出改變是痛苦的，是需要時間的。離開自己的舒適圈，朝夢想前進，而不是為自己找更多的理由。尋找解法，而不是責怪原因。所有的煩惱都來自人際關係為什麼討厭自己因為過分害被別人討厭、在人際關係中受傷所致。目的變成了不要在人際關係中受傷害。在人際關係中相當容易受到傷害，我們會遇到適合自己的人、排斥自己的人。為了避免受到傷害，我們為自己套上：孤僻、沈默等等性格，為自己的行爲找出合理的詮釋。合理的詮釋是為了讓自己的避免傷害，例如我會覺得：如果我每天念英文，我的人生就是彩色的了。其實心中是在迴避唸英文這個問題，我怕自己每天念也念不來，怕自己就算真的唸了，人生也並沒有改變。阿德勒：要除去所有煩惱，唯有獨自一人存活在宇宙中。簡單說，有人就會有問題拉。所有的煩惱都是人際關係的煩惱我們就算要覺得孤獨，也需要其他人的存在。所謂的 “內在的煩惱” 並不存在。自卑感，是一種主觀的設定自卑感 = 價值 + 較少 + 感覺。這些折磨我們的自卑感並不是 “客觀的事實”，而是 “主觀的解釋”人與人之間存在比較，而我們從什麼角度跟別人比較，進而的產生 “自己不如人” 的感覺。事情有各個角度可以看，接受失敗、接受自己的缺點，而不是持續地以自己的缺點出發，認為自己的不完美，認為別人的條件比較好。因為這些主觀的觀點產生的自卑感，實為 “主觀的自卑感”，而非 “客觀的事實”，這種感覺通常是由自己判定自己的失敗，或是由別人投射在我們心中。總之，這個感覺仍然是人的感情建立，並非實際需要比較的東西。當成藉口的自卑情結當理想無法達成時，就會產生一種低劣無能的感覺。自卑情結，是指把自卑感當成某種藉口使用的狀態。自卑情結即是為自己找藉口，為自己找的一個相對舒適的圈圈。因為自己無法達成，所以也就算了。同時解開了自己愧疚的心結，也解釋了自己為什麼不更努力的去完成目標。自卑感不見得是壞事，人們可以透過自卑感產生動力，覺得自己不好，需要更加努力達成。但自卑情結是為自己找到看似合理的出口，放棄改變來避免失敗。自傲的人同時也感到自卑藉由權威的力量來膨脹自我的人，終究還是活在別人的價值觀裡，過著別人的人生。如果有人自吹自擂，不過是因為他感到自卑罷了。真的正的強者，不會急於表現自己有多好，急於證明自己比別人好。因為他們對自己有足夠的自信，知道自己的優點。這也是為什麼在爭論的場合中弱勢的人，自尊心往往較強，甚至透過擺爛的行為，來贏得一個自己無法贏得的爭吵，把 “自己” 看得相當的重要。炫耀不幸藉由自己的不幸，變得特別; 憑藉不幸，想要高人一等。把自己的不幸當成武器，想要支配對方。人們也會利用自己的缺點、悲情的過往來提搞自己的身份地位。透過說明自己撐過了某種艱困的過去，來表示自己撐過去了。或是透過 “你們沒經歷過，永遠無法體會” 的論點，來顯示自己的成長過程與眾不同。謙虛大概才是一個有自信的人會擁有的。題外話，營造更好交談的10條建議這邊讓我想到一個 TED 的演講：營造更好交談的10條建議。其中提到，當人們在陳述自己的遭遇時，是在尋求慰藉或是某種認同，而當我們接受到這樣的訊號時，建議不要用自己的經驗或是經驗法則套用在別人身上，沒有任何一段經驗是相同的，那段悲傷的情緒屬於對方的，而自己的狀況是相對的較難獲得認同。而與他人溝通或是聆聽對方的遭遇時，是一個建立雙方感情鏈結的好機會，我們需要做的只有嘗試去體會對方的感受，並當個好的傾聽者。中譯影片：人生並不是與他人競賽追求卓越，不需要跟任何人競爭，只需要跨步向前就行了。健全的自卑感並不是跟別人比較產生的，而是跟 “理想中的自己” 比較後的結果。人跟人之間應該是完全平等的，沒有人絕對得比誰優秀，儘管我們之間慛載著差異。而我們會把看到感覺優秀的人的影子，投射到自己身上，產生一個如果自己是那樣的想法。間接的，我們產了現在的自己不如自己像象中好的樣子，產生了自卑感。將別人的幸福認定成自己的挫敗。要把大家當成夥伴，而不是都當成敵人。當我們把周遭的人都當成敵人，免不了跟別人比較。應該把大家當成夥伴，大家共同成長，那比較就會更少，也不會間接產生自卑感。由權力鬥爭到復仇想藉由勝利來證明自己的權利。當對方挑起權力鬥爭時，絕不要隨之起舞。我們不需要透過鬥爭來解決問題，更不需要透過鬥爭來證明自己的能力。正確地解決問題，不要挑起無意義的爭端。認錯不等於承認失敗不是忍耐，忍耐代表你已經捲入了這場鬥爭。當對方發起爭執時，代表這整件事情處理的過程有瑕疵。沒有必要證明自己是對的或是對方是錯的，解決問題最重要的。這回歸到第一章節所述的 “憤怒是種工具” 不要濫用憤怒的情緒來解決問題。如何面對人生的任務行動面的目標有 “獨立” 和 “能與社會和諧生活” 兩項。而支援這項行動的心裡面目標則是 “我是有能力的”，以及 “人人都是我的夥伴”工作的任務交友的任務愛的任務工作的任務工作的任務其實仍然與人際關係有關，如果我們在工作上疏失，會導致自己不想去上班，不願意面對工作。真正的原因並不是工作本身，而是我們在工作上會遭受的責難，被評價為能力不足等等的問題。因此，工作的任務其實仍然屬於人際關係的範疇。交友的任務這屬於人生的中相當重要的一個課題。交友的任務即是普遍認知的人際關係，而這方面的難度會高於工作的任務。因為人跟人之間並沒有強制性的關聯，沒有 “一定要在一起” 的需求。朋友的重點不在多，而在於摯友，久久見面一次的朋友仍然可是摯友。愛的任務只要和這個人在一起，就可以自由盡情的展現自我愛的過程中，最重的是面對問題，並嘗試解決，並不要安逸於現狀。不要漠視人生的謊言找出各種藉口來逃避人生任務的情形，就稱為人生的謊言從擁有的心理學到使用的心理學佛洛伊德-因果論擁有的心理學，最後注定要走入決定論。阿德勒-目的論使用的心理學，決定權在於你自己。小結人之間最大的心魔就是互相比較，透過比較得到優越感，或是自卑感。人生的課題主要為三大方向：工作、交友、愛情，在嘗試解決這三方面的問題時應該對自己更有自信，不是不斷的拿自己的條件跟人比較。而比較時又常常使用固守的觀點認為自己不夠好，在失敗的時候，我們嘗試找出原因，卻只找出藉口，藉由藉口來解釋自己的失敗，解釋自己為什麼無法成功，其實成功與否一直都操之在我們自己，遮蔽這一切的，即是人生的謊言。滿滿的正能量啊。割捨別人的課題不要為了滿足別人的期望而活如果你不為自己而活，那誰要為你的人生而活?賞罰教育帶來的瑕疵點：絕對的是非對錯，將這個世界上的事情一分為二。理想的狀況事情是：我們會只做對的事情，並不會做錯誤的事情。但這種教育造成的情況是，我們會選擇做會受到讚賞的事情，選擇做光彩的事情。而人們排斥做沒人注意到的事情。換而言之我們陷入的為他人而活的迴圈，有別人的目光的事情才有意義。…所有的問題仍然來自於人際關係。課題分離不涉入別人的課題。所有人際關係中的紛爭，差不多都是因為一個腳踩進人家的課題裡，或自己的課題遭到干涉所引起的。仔細思考，因為這個決定而帶來的結果，最後會由誰來承受？只有自己可以改變自己。我們能把馬牽到水邊，卻不能強迫她喝水。割捨別人的課題越是關係親近的家人，越需要刻意機課題切割開來。割捨別人的課題這個想法是雙面的，如果我們不要為了滿足別人的期望而活。那我們也不應該期望別人會為了我們而做什麼，這個觀點相當的清晰，每個人跟人之間是個體，我們能互相關心，能相愛，但不是互相控制對方，互相牽制對方。每個人有每個人自己的人生，有屬於它的成功，也有屬於自己的失敗，失敗也是屬於自己的體驗。不要介入別人的課題，也不要讓別人介入你的。尤其是家人，更因為晦長時間的相處而互相跨入對方的私領域。斬斷難題所謂的命運，並非依靠傳說來安排，而是揮舞自己的劍去展開。 — 亞歷山大與常識對立的反命題。如果你無法不在意他人的評價、無法不害怕被別人討厭。也不想付出可能得不到認同的代價。那就無法貫徹自己的生活方次。小結順著書本的邏輯思考到這邊的話，邏輯是說得通的。我很難表達自己現在覺得這整件事情的想法，也與我自己過去的經驗有所牴觸。但不可否認的，我們不可能做到人見人愛，就連賈伯斯都被指責是個暴君、差勁、難相處的人。自己快樂和讓人快樂，相當難同時兼具，如果我們要完全百分之百應和他人，那就會失去自由的自己。不過不要忘記一具相當重要的話：說話讓人舒服的程度，決定你的高度。這仍然是管理學中翁相當重要的一環。做人、做自己、跟管理，需要認真地分開思考。抓取中間的平衡點是相當重要的，過度的偏激自我或是他人，都是不健康的心理狀態。","raw":null,"content":null,"categories":[{"name":"好書筆記","slug":"好書筆記","permalink":"http://www.andrewchen.tw/categoriesl/好書筆記/"}],"tags":[{"name":"讀書心得","slug":"讀書心得","permalink":"http://www.andrewchen.tw/tags/讀書心得/"},{"name":"重點筆記","slug":"重點筆記","permalink":"http://www.andrewchen.tw/tags/重點筆記/"},{"name":"心理學","slug":"心理學","permalink":"http://www.andrewchen.tw/tags/心理學/"},{"name":"自我成長","slug":"自我成長","permalink":"http://www.andrewchen.tw/tags/自我成長/"}]},{"title":"天使與惡魔，炸雞排試吃評比 !!","slug":"20161228_FOODS_雞排","date":"2016-12-28T13:00:00.000Z","updated":"2017-05-04T23:28:16.000Z","comments":true,"path":"2016/12/28/20161228_FOODS_雞排/","link":"","permalink":"http://www.andrewchen.tw/2016/12/28/20161228_FOODS_雞排/","excerpt":"終於在這次的聖誕節達成了雞排小成就：吃到了台灣著名的三大雞排!!! 因為時間的關係，我前前後後在南北兩地吃到這三家雞排，總共嘗試了六次才有辦法寫出這篇文章。這三家共同的特色就是肉厚多汁，厚實的雞排肉完全不像在吃炸雞排，咬肉的感覺就像厚切牛排的概念一樣，肉厚的口感硬是跟傳統雞全不一樣。天使雞排 - 瑞豐店 * 2惡魔雞排 - 寧夏店 + 士林店艋舺雞排 - 屏東店 + 鳳山店","text":"終於在這次的聖誕節達成了雞排小成就：吃到了台灣著名的三大雞排!!! 因為時間的關係，我前前後後在南北兩地吃到這三家雞排，總共嘗試了六次才有辦法寫出這篇文章。這三家共同的特色就是肉厚多汁，厚實的雞排肉完全不像在吃炸雞排，咬肉的感覺就像厚切牛排的概念一樣，肉厚的口感硬是跟傳統雞全不一樣。天使雞排 - 瑞豐店 * 2惡魔雞排 - 寧夏店 + 士林店艋舺雞排 - 屏東店 + 鳳山店雞排口味口味最重肉汁最多的是惡魔雞排，味道的個性鮮明且強烈，而天使雞排的肉汁也不妨多讓，味道適中並帶有肉的甜味 讓我允指回味啊！艋舺雞排的口味則相當經典，一樣炸的恰到好處，艋舺雞排的椒鹽粉味道相當明顯，但絕不會太嗆或是讓人不舒服。而除了天使雞排之外，另外兩家在北部的夜市已經相當容易尋找到他們的蹤跡。雞排肉質雞排的大小其實有蠻大的差距的，儘管就差那兩三口雞排，慾望的滿足感就是差非常多，但我個人認為雞排大小跟地段有直接關係，所以並沒有直接拿來當作比較的參考，我在高雄吃到的雞排就真的有台北的 1.4 倍大的感覺，就是有差那麼多。但因為地價相差甚遠，所以我覺得不能單方片的稱讚某雞排店的雞排好吃。但我仍然私心推薦 天使雞排 - 瑞豐店。當然雞排這種東西吃下去其實也是看運氣，說不定當天那個員工心情不好，多炸了20秒鐘，那口感就差非常多了，品質控管在連鎖的店面上，面對不同的工讀生的操作，年免會有所差距，儘管都可能有時間管制，但天氣氣問的不同，員工反應速度不同等等細節因素，都大大的影響雞排的口感，或是單純就是那隻雞心情不好而已，吃下去雞肉就是不嫩，憂鬱太久的感覺。最重要的事我認為雞排在拿到之後，要在最快的時間內，以不燙到嘴的方式入口！雞排跟牛排一樣，高溫加熱起鍋後 “靜置” 也屬於烹飪的一環。以牛排來說，煎鍋起來後靜置 5-6 分鐘是一種烹飪方式，而雞排也是相同的狀況。簡單說，你拿到手之後，雞排也是不斷的在加熱的狀況！那要是晚五分鐘之，雞排就是處於相對過熟的情框了，因此強烈推薦，在不燙到舌頭的情況下，儘早享用你的雞排吧！外傳另外惡魔狂暴雞排。是這趟旅程中的小插曲，我吃到的時候他才剛剛開幕不到一個禮拜，或許是意外，雞排炸的略焦，後半段就顯得相當乾硬，可能營業穩定下來之後就會變得非常好吃。","raw":null,"content":null,"categories":[{"name":"吃吃喝喝","slug":"吃吃喝喝","permalink":"http://www.andrewchen.tw/categoriesl/吃吃喝喝/"}],"tags":[{"name":"吃吃喝喝","slug":"吃吃喝喝","permalink":"http://www.andrewchen.tw/tags/吃吃喝喝/"},{"name":"美食介紹","slug":"美食介紹","permalink":"http://www.andrewchen.tw/tags/美食介紹/"},{"name":"炸物","slug":"炸物","permalink":"http://www.andrewchen.tw/tags/炸物/"},{"name":"夜市","slug":"夜市","permalink":"http://www.andrewchen.tw/tags/夜市/"}]},{"title":"JavaScript 綁定函數方式比較 - .Bind() .Apply() .Call()","slug":"20150818_JS_buildCallApply","date":"2015-08-18T14:30:15.000Z","updated":"2017-05-04T23:27:40.000Z","comments":true,"path":"2015/08/18/20150818_JS_buildCallApply/","link":"","permalink":"http://www.andrewchen.tw/2015/08/18/20150818_JS_buildCallApply/","excerpt":"JavaScript 在呼叫 Function 時，有三種方式可以改變其範疇，分別為 .bind(),.call(), .apply(), 而這三種又有些許的差異：","text":"JavaScript 在呼叫 Function 時，有三種方式可以改變其範疇，分別為 .bind(),.call(), .apply(), 而這三種又有些許的差異：function .bind().bind() 不會立即執行 function，並設定 this 範疇與傳入參數。傳入第一個參數是 scope，指定 function 內 this 的範疇。1func.bind( this, 1 ,2 ,3 ) ; // 不會立即執行function .call().call() 呼叫 function，並設定 this 範疇與傳入參數。傳入第一個參數是 scope，指定 function 內 this 的範疇。1func.call( this, 1 ,2 ,3 ) ; // 逐一傳入參數 (立即執行)function .apply().apply() 呼叫 function，並設定 this 範疇與傳入參數。傳入第一個參數是 scope，指定 function 內 this 的範疇。而參數是統一用一個陣列包起來，apply 會自行拆開傳入。1func.apply( this, [ 1, 2, 3 ] ); // 參數統一用 array 傳入 (立即執行)","raw":null,"content":null,"categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://www.andrewchen.tw/categoriesl/Node-js/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.andrewchen.tw/tags/JavaScript/"},{"name":"Node.js","slug":"Node-js","permalink":"http://www.andrewchen.tw/tags/Node-js/"},{"name":"學習筆記","slug":"學習筆記","permalink":"http://www.andrewchen.tw/tags/學習筆記/"},{"name":"教學","slug":"教學","permalink":"http://www.andrewchen.tw/tags/教學/"}]},{"title":"Redis - Node.js 記憶體快取","slug":"20150816_JS_redis","date":"2015-08-16T03:01:07.000Z","updated":"2017-05-04T23:26:23.000Z","comments":true,"path":"2015/08/16/20150816_JS_redis/","link":"","permalink":"http://www.andrewchen.tw/2015/08/16/20150816_JS_redis/","excerpt":"Redis 是以 key-value 的形式在伺服器的記憶體中儲存資訊的方式，為伺服器命名做快取(cache)。有別於其他 noSQL 或是 RDB，key-value 即是使用一個 key 的值對應到一筆資料。而 Redis 的特色就是將這筆資料，寫在記憶體裡面。大概有幾種狀況會將資料寫入到快取中：在一定時間內會被大量請求的資料，如：新聞的 Top 10。某些伺服器會頻繁使用的資料，或全域變數。如：測試用的資料，短時間內要使用的假資料。也能當成 Session 使用。(相當不健康的觀念)Redis 本身會瓜分伺服器的記憶體來使用，Node.js 連線所使用的記憶體相對於 PHP/Apache 較少，除非能非常準確地掌握 Session 的數量，否則不建議 Redit 當成 Session 使用，同樣的意思不應該將 Redis 當成資料庫來只用。如果對 Redis 有相當大的需求，應該特地架設 Redis 的伺服器，避免兩套系統互相搶奪記憶體資源。RedisRedis - 官方文件Redis - npmRedis - GUI安裝","text":"Redis 是以 key-value 的形式在伺服器的記憶體中儲存資訊的方式，為伺服器命名做快取(cache)。有別於其他 noSQL 或是 RDB，key-value 即是使用一個 key 的值對應到一筆資料。而 Redis 的特色就是將這筆資料，寫在記憶體裡面。大概有幾種狀況會將資料寫入到快取中：在一定時間內會被大量請求的資料，如：新聞的 Top 10。某些伺服器會頻繁使用的資料，或全域變數。如：測試用的資料，短時間內要使用的假資料。也能當成 Session 使用。(相當不健康的觀念)Redis 本身會瓜分伺服器的記憶體來使用，Node.js 連線所使用的記憶體相對於 PHP/Apache 較少，除非能非常準確地掌握 Session 的數量，否則不建議 Redit 當成 Session 使用，同樣的意思不應該將 Redis 當成資料庫來只用。如果對 Redis 有相當大的需求，應該特地架設 Redis 的伺服器，避免兩套系統互相搶奪記憶體資源。RedisRedis - 官方文件Redis - npmRedis - GUI安裝先從官方網站下載 Redis，解開壓縮檔之後，在資料夾下執行以下指令1$ make輸入指令後，Redis 會自行安裝，需要一段時間1$ make testRedis 會自行進行測試，測時完成後即可啟動，啟動並不需要在指定的資料夾下，屬於全域的1$ redis-server接著在 Redis - GUI 的介面中進行連線就可以檢視現在 Redis 內的資料。使用在 Node.js 引用 Redis 的套件並且連線1var redis = require(\"redis\").createClient('6379', '127.0.0.1'); //port, IPredis.set 寫入值123redis.set( key, value, function( err, reply )&#123; console.log( reply.toString() ); // 新增成功會回傳 ok&#125;);redis.get 取得值123redis.get( key, function( err, reply )&#123; console.log( reply.toString() ); // 新增會回傳 value&#125;);cache 資料的存活時間1redis.expire( key, 60);redis 錯誤 callback function1redis.on( \"connect\", callback );redis 錯誤 callback function1redis.on( \"error\", callback );redis 驗證如果在 redis.conf 中有設定需要驗證的話，須在在此填入驗證碼，類似密碼的意思。1redis.auth(\"AndrewChen\");結語Redis 基本上安裝完成就成功一半了，簡易的 set/get 即可使用，Redis 的操作本身不難，但謹慎的使用，小心記憶體的使用量，避免超額使用或是佔據了伺服器的空間。另外定期簡單的透過GUI介面檢查 Redis 的狀況也是相當不錯的選擇。","raw":null,"content":null,"categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://www.andrewchen.tw/categoriesl/Node-js/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.andrewchen.tw/tags/JavaScript/"},{"name":"Node.js","slug":"Node-js","permalink":"http://www.andrewchen.tw/tags/Node-js/"},{"name":"學習筆記","slug":"學習筆記","permalink":"http://www.andrewchen.tw/tags/學習筆記/"},{"name":"教學","slug":"教學","permalink":"http://www.andrewchen.tw/tags/教學/"}]},{"title":"淺談前端框架未來，Angular, React, 還是...？","slug":"20150802_JS_AngularReactOrOther","date":"2015-08-02T01:13:44.000Z","updated":"2017-05-04T23:25:50.000Z","comments":true,"path":"2015/08/02/20150802_JS_AngularReactOrOther/","link":"","permalink":"http://www.andrewchen.tw/2015/08/02/20150802_JS_AngularReactOrOther/","excerpt":"本篇文上是為 JSDC 2015 撰寫感謝 Caeser Chi 給予指導前端入坑深似海，一入宅門出不來。這肯定是許多前端工程師可以體認到的共同感觸，前端真可以說是一個坑，維繫大家能夠持續學習的動機，除了熱情，應該就還是熱情吧。淺談前端框架","text":"本篇文上是為 JSDC 2015 撰寫感謝 Caeser Chi 給予指導前端入坑深似海，一入宅門出不來。這肯定是許多前端工程師可以體認到的共同感觸，前端真可以說是一個坑，維繫大家能夠持續學習的動機，除了熱情，應該就還是熱情吧。淺談前端框架隨著前端應用變化越來越多，因此許多前端框架不斷的推陳出新，從早期大家所熟知的 batman.js, backbone.js, emberjs 在中期也開始出現了許多不同框架，其中到了 Google 踏進 Angular.js 之後前端框架正式熱門起來，也掀起另外一波大戰。隨著世代的轉移，JavaScript 漸漸語法轉移到 ES6，語法不同，開始有了不同應用，也因此又出現了令人亮眼的新秀：Aurelia。由於前端框架的世界更新相當迅速，不斷有新的Framwork出現，各家開發者對自己熟悉的框架各執其詞，其實相當難定義何者叫好。前端框架未來？React, Angular ?React 和 Angular 目前為前端兩大流行的框架，兩者的風格迥異。React 主打 Single Source of True 和 Flux 的單項資料流，重新以元件的思維角度去設計 WebApp，最後又採用相同思維可以進行開發 iOS, Android native 程式框架 - React Native 讓大家眼睛為之一亮。而在Angular目前的情況較為不明朗，相當多的開發者正在使用能穩定運作的 1.x 版本，但是 Angular 2.x 的版本卻面臨了相當大的改版，而且並沒有支援 1.x 的部分。 Angular 最大亮點在雙向資料綁定，簡潔的資料綁定和監控配上快節奏的開發技巧時，產生令人驚豔的開發速度。React 跟 Angular 整體的核心思維是相當不同的，React 特色在於簡化的開發邏輯與資料流，單純的單項資料流讓開發流程和除錯都容易了許多，React 的結構設計也讓抽取元件變得直觀與單純，React 傾向於將開發簡化，在設計好架構與資料結構後就減少犯錯的機會。但從另一個角度來說，React針對單一的操作，要撰寫的程式碼多出了許多，整個架構也變得龐大。而 Angular 則相反，Angular 在處理資料時相當快速且方便，雙向的資料綁定讓開者並不需要思考太多元件對應的關係，但也因此最終可能會讓整個專案陷入混亂，Angular 在抽取元件時比 React 需要更多的開發技巧，對整體團隊的開發素質要求也相對的更高。新的選擇 - AureliaAurelia 或許可以說介於 React 和 Angular 兩者之間，Aurelia 目前為相當新秀的開發框架，他本身與 Angular 的資料綁定方式相當類似，不僅僅對 Angular 的開發者相當容易上手，安插在 HTML5 中的屬性也更加語意化。Aurelia 的核心圍繞在模板上，因此他似乎同時擁有了 React 類似元件的觀念，又同時有 Angular 綁定資料的手法，算是相當多元，除此之外 Aurelia 對 ES6, ES7 擁有更高的支援度。當然目前 Aurelia 還在持續開發中，雖然版本尚未穩定，但是已經是個值得注目的前端框架，可以開始試著去執行，了解 Aurelia ，或許在現今 Single Page App 爆炸性成長的階段，Aurelia 能在未來佔有一席之地。也許未來 JavaScript 真的能夠做到前後端統一程式碼進行開發，也有可能踏入 hardware 開發領域，這都需要時間來證明，當然也需要各位的投入，就讓我們持續關注這個世代的變化吧。","raw":null,"content":null,"categories":[{"name":"社群活動","slug":"社群活動","permalink":"http://www.andrewchen.tw/categoriesl/社群活動/"}],"tags":[{"name":"社群活動","slug":"社群活動","permalink":"http://www.andrewchen.tw/tags/社群活動/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.andrewchen.tw/tags/JavaScript/"},{"name":"Angular.js","slug":"Angular-js","permalink":"http://www.andrewchen.tw/tags/Angular-js/"},{"name":"React.js","slug":"React-js","permalink":"http://www.andrewchen.tw/tags/React-js/"}]},{"title":"JS Devil Day 參與心得","slug":"20150802_JS_JSDevilDay","date":"2015-08-02T01:05:42.000Z","updated":"2017-05-04T23:26:01.000Z","comments":true,"path":"2015/08/02/20150802_JS_JSDevilDay/","link":"","permalink":"http://www.andrewchen.tw/2015/08/02/20150802_JS_JSDevilDay/","excerpt":"本篇文上是為 JSDC 2015 撰寫感謝 Caeser Chi 給予指導JS Devil Day 是本次 JSDC 2015 所舉辦第一場對外 Meetup，也是首次透過北中南三方連線方式進行，本次以參與者角色，記錄此次活動。JS Devil Day 當天主要有三個主題：Angular.js、ECMAScript6、講者對談與交流。專家分享","text":"本篇文上是為 JSDC 2015 撰寫感謝 Caeser Chi 給予指導JS Devil Day 是本次 JSDC 2015 所舉辦第一場對外 Meetup，也是首次透過北中南三方連線方式進行，本次以參與者角色，記錄此次活動。JS Devil Day 當天主要有三個主題：Angular.js、ECMAScript6、講者對談與交流。專家分享儘管對 Angular.js相當不熟悉，透過講者阿梨的分享讓我對Angular.js的概念有些許的了解，事後座談時講者也推薦初學者直接以Angular.js 2.0作為起手版本。接著是 Jeremy 對 ES6、webpack 提出了幾個重點，在 ES6 中可以明顯地感受到 JavaScript 已經開始嘗試解決 ES5 一些為人詬病的問題，包括區域變數、類別、模組化等等，同時 ES6 內建了 promise 和 generator ，同時在 ES6 解決了過複雜的 callback function和流程控制，另外 ES6 採用許多 coffeeScript 語法讓結構更為簡潔。個人認為 ES6 讓 Javascript 成為了更完整的開發語言，也讓 Javascript 減少了許多舊有的小問題，也不必仰賴開發者用奇技淫巧去嘗試解決問題。現今主流瀏覽器諸如：Chrome、Safari、Firefox 等等，已經逐漸開始支援 ES6，但尚未完全支援。在瀏覽器完全支援 ES6 之前，我們可以透過 babel 在程式執行之前將 ES6 的程式碼轉譯成 ES5，讓瀏覽器完全整的支援 ES6 程式碼。另外 Jeremy 提到 webpack 和 JSCS ，協助團隊開發更為順暢，開發工具和技巧相當的重要。順暢的開發過程除了提高效率之外，也保護了開發者健康的肝。","raw":null,"content":null,"categories":[{"name":"社群活動","slug":"社群活動","permalink":"http://www.andrewchen.tw/categoriesl/社群活動/"}],"tags":[{"name":"社群活動","slug":"社群活動","permalink":"http://www.andrewchen.tw/tags/社群活動/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.andrewchen.tw/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://www.andrewchen.tw/tags/ES6/"}]},{"title":"Android App - TTtimer","slug":"20150719_APP_TTtimerForOIT","date":"2015-07-19T07:46:12.000Z","updated":"2017-05-04T23:24:46.000Z","comments":true,"path":"2015/07/19/20150719_APP_TTtimerForOIT/","link":"","permalink":"http://www.andrewchen.tw/2015/07/19/20150719_APP_TTtimerForOIT/","excerpt":"名稱：TTtimer類型：Andriod App / Java, 未上架時間：2015/1 (大三上學期)用途：期末作業簡介Android APP - TTtime 是我在大三上學期修 Java 課程的期末作品。這隻 APP 大概是我個人最喜歡期末作品之一，包括結構和設計是我個人最喜歡的，當時我有不少的時間與不曉得發揮空間。TTtimer 的設計概念出自於 10,000 小時，意指在某一個專業區域中努力 10,000 小時才能成為該專業領域中的佼佼者(這個理念最後被我個人推翻了)。而 TTtimer 即是此類型的計時器，選擇目標的專業項目後，持續累計時間來達成最初設定的目標，並透過累計時間的百分比、累計總數來給予獎勵或是頭銜的稱號。","text":"名稱：TTtimer類型：Andriod App / Java, 未上架時間：2015/1 (大三上學期)用途：期末作業簡介Android APP - TTtime 是我在大三上學期修 Java 課程的期末作品。這隻 APP 大概是我個人最喜歡期末作品之一，包括結構和設計是我個人最喜歡的，當時我有不少的時間與不曉得發揮空間。TTtimer 的設計概念出自於 10,000 小時，意指在某一個專業區域中努力 10,000 小時才能成為該專業領域中的佼佼者(這個理念最後被我個人推翻了)。而 TTtimer 即是此類型的計時器，選擇目標的專業項目後，持續累計時間來達成最初設定的目標，並透過累計時間的百分比、累計總數來給予獎勵或是頭銜的稱號。以下為 APP 使用到的技術重點，有需要的同學可以在裡面尋找相關自訓。有機會的話相我想把這個 APP 上架，最為一次學習經驗。Source Code 分享Source Code 放置在 Google Drive 上面，分享給需要範例的同學們。[Android APP] TTtimer-for-AS-v1.0技術簡介物件導向設計APP 中，每個 任務 都是以一個物件包裝，包括包裝這個 任務 本身的資訊、進度、累計時間等等。而累計時間輸出時，可是轉換成百分比的函數，也是包裝在 PlaneToTime 的類別裡面。物件導向設計可參考的是以下主要幾個類別：MyTimerMicroTimerPlanPlanToTimeMyTimer 和 MicroTimer 類別主要功能就是計時器，在每個計畫中都會使用到一個計時計，並且有簡化一些時間I/O的機制，主要是根據我當時自己的需求所包裝的。而 Plan 和 PlanToTime 包裝了 計畫 和 有時目標間的計畫，事實上在最後 APP 實作的時候，並沒有 無目標時間的計畫，也就是說類別 Plan 只是單純被 PlanToTime 繼承，作用類似於一個基底類別，其實並沒有實作的功能，這屬於我個人設計錯誤，因為一開始有構想 無目標時間的計畫。因此在後面會發現，底層設計的取得獎勵的方式，略有不同，僅僅因為當初規劃時我的想法岔開了。包裝這四個類別，在我專案開發中後期其為吃香，傳送資料時不太需要考慮資料格式。簡單思考：傳遞一個物件比起傳遞四個不同型別的參數，何者容易？當然是包裝好的一個物件，一次傳遞來得輕鬆方便。另外，包裝物件可以在多人開發時，資料格式的缺漏檢查，或是避免掉不必要的資料傳遞誤會與錯誤。計時器計時器只有兩個原則，每秒(或是其他時間)的觸發事件，然後再撰寫自己紀錄的方式。計時器 Andriod 有預設事件，少量的計時器每秒的 tick 相當精準，不要一次開一大堆就好。也別用計時器去處理監聽事件，基本上 Andriod 大部份的物件都有自己的監聽事件，不需要自行去撰寫計時器去檢查。在 TTtimer 中牽涉到的類別如下：MainActivityTiemRiverSysSet之前被問過幾次 Android App 的計時計怎麼處理，計時器的影子可以在 Mainctivity 中找到，當初設計是在 APP 一啟動時，背後就有一個碼表在計時，而計時計的參數被我抽取到 TimeRiver 和 SysSet 的類別中，其實 TimeRiver 的類別中的設定參數直接抽取到 SysSet，目前的方式是多個任務會共用同一個碼錶，避免每開一起一個新的任務就啟用新的碼表消耗效能。SQLite如果 SQLite 無法正常啟用，記得注意 Android 本身的版本是否要更新，之前個人在測試時就發生過無法啟動的狀況。情急之下用 txt 自己刻了一套類似功能的 documentation SQL。現在想想挺好笑的，結果期中考過後我發現手機系統要更新，更新好就能使用 SQLite 了，只好默默的砍掉整個手刻的 SQL。關於 SQLite 我使用在兩個部分：儲存計畫、系統參數。PlanSQLSystemSettingSQL兩者都相當直接的包裝了基本的 Sqlite 的 CRUD (新增/修改/刪除/查詢)，基本上 SQLite 在類別設計完成後，撰寫一次，確認每次 APP 開啟後跟 SQLite 的 IO 正常後，我就再也沒有修改過內部的程式碼。所以理想的話只要努力一次就好，並不需要開發途中不斷地維護那段程式碼。 SQLite 需要注意的重點是測試資料的問題。在開發時頻繁的測試過程中，程式碼除錯時會頻繁地影響到資料庫資料的變動，導致錯誤解決了卻仍然出現問題。主因是資料錯誤，產生 Garbage in garbage out 的結果。建議在開發期間每次 APP 啟動時就初始化一次資料，清空資料庫並且寫入測試用的資料，最終在 APP 發佈時只要將初始化資料的程式碼註解掉即可。另外需要注意的事情是，程式碼要有解析空資料的能力。意思是多半在測試時，資料庫內已經有測試資料，往往忽略了有可能無資料的情況，反而在拿掉測試資料後才發現 APP 啟動的一瞬間就會因為資料讀取失敗而崩潰。動態新增控制項這大概是我被詢問最頻繁的項目了。處理這部分的是以下兩個類別：AddBtnViewList動態新增控制項的步驟就是：宣告 &gt; 設定 &gt; 掛載。除非是要做 APP 遊戲，不然 Andriod 內建的 ListView 應該能解決大部份的問題，當初我在這塊也是修改了好幾個版本，一開始因為好玩也是手刻 ListView，再建立 Scroll view。不過內建的 ListView 和手刻的邏輯基本上是相同的，先將想要動態新增的物件製作成一份 ListItem 再由 ListView 去重複就對了。Android Lifecycle 生命週期撰寫 Andriod APP 最重要的就是生命週期。簡而言之，生命週期就是我們在手機各種操作時，切換到 APP 畫面時對程式運行的影響，例如執行中的 APP 在按下 Home 鍵後會進入到 onPause() 的狀態，不同的狀態不可能讓 APP 一直處於運轉中，因此 APP 作業流程設計會圍繞著 Android Lifecycle 在運轉，也是設計的核心。但記得在 Lifecycle 中，我個人認為最不能仰賴 onDestroy()，仰賴關閉 APP 時才去執行，無法預測 APP 是在什麼情況下被關閉的，可能執行緒被中斷、手機沒電等等狀況。重要的資料同步，盡可能不要放在 onDestroy 的部分。雙語系TTtiemr 支援雙語系，支援 zh-Tw 和 en 語系，根據手機設定的國籍去做辨識。在手機中抓取字串的方式都需要使用 android:text=&quot;@string/show&quot; 抓取，之前有聽過反映這樣相當不友善(且不容易辨識)，不過在後期翻譯時相當有趣，單純翻譯 string 的設定檔就可完成。如果從一開始就有遵守紀律，將對應的字串寫在設定檔內，在專案末期好好享受輕鬆翻譯 APP 語言的成果吧!多解析度圖片在多解析度圖片這部分，我個人處理得相當糟糕，當初在 PC 上測試時雨手機上測試時發現差距極大，因此我大量的改用百分比去做設計。解決問題後我就沒有再去對多種解析度的螢幕下去做設計。Animation 動畫效果在 WorkingActivity 可以大量使用到動畫，Android 的動畫使用大致上是：宣告 &gt; 設定參數 &gt; 啟動。需要注意的是 Animation 的狀態，需要將正確的資料流操作掛載載正確的 Animation 事件上面，避免掉發生動畫時件不同步或是執行順序有問題的情況。Animation 玩起來相當有趣且有成就看，相當推薦大家玩玩。檔案簡介path: src/main/java/tw/com/oit/andrew/myclass/MyTimer計時計類別，主要是依照需求包裝了計時器去配合之後的 Andriod time tick。myclass/MicroTimer繼承了 MyTimer，加入了秒數的欄位，最後這兩個計時器使用的類別會被包在 Plan 和 PlanToTime 中使用。myclass/Plan包裝了每個計畫項目資訊，屬於 PlanToTime 的父類別，絕大多數重要的功能也是在這裡。myclass/PlanToTime在計畫項目資訊增加了目標時間，之後的 Activity 中使用的都是這個 class。兩個 Plan 相關的 class 是整個 APP 中 CP 最高的，但也是被反覆修改最多次的，良好的物件設計讓我在整個 APP 開發的後期有了相當不錯的資料控管，我能清楚的掌握資料的傳輸。system/Notify包裝了所有使用的通知視窗(Dialog)，從外部可以輕鬆的呼叫視窗，僅需要傳入必要的字串需求即可。system/SysSet系統設定檔。應該與 TimeRiver 合併。system/TimeRiver系統設定檔。主要是針對計時器的部分，這部分的設定會被記錄在 SQLite 中，確保每次重新啟動時都會是使用者設定的值。tenthousandtimer/MainActivity主要介面的操作，拿讀取進來的資料動態新增控制項，並且宣告、啟動計時器。tenthousandtimer/MetalsActivity單純檢視獎牌與頭銜等訊息，可以視為單純的 ListView Demo。tenthousandtimer/MyMenu針對 Menu 包裝操作，命名並沒有使用 Activity 是用來區別這個是一包裝操作的 class 並非直接掛載在頁面上的。tenthousandtimer/SettingActivity設定頁面，設邊使用了固定的控制項，然後將設定的資訊寫在上面的 system 類別中，並儲存在 SQLite。tenthousandtimer/WelcomActivity歡迎界面，在裡面載入 SQLite 的資料，其實這沒有必要，在 MainActivity 中載入即可，單純為了好看。tenthousandtimer/WorkingActivity在 WorkingActivity 中大量的使用了 Animation，如果在事後才掛上 Animation 容易導致先前設計的資料流多少出現錯誤。仔細研究 Animation 與主程式非同步的關係，就能解決這個問題，並不至於需要 APP 大改寫。tttsql/PlanSQL &amp; tttsql/SystemSettingSQL包裝了 SQLite 的操作，包含了整批資料的 CRUD，這邊對於 SQLite 的操作相當基本，依據我的印象，資料更新的操作是直接用覆蓋的。基本上也不會出錯，在小量的資料下，效能也沒有問題。PlanSQL 和 SystemSettingSQL 分別包裝了不同的資料而已，基本上觀念完全相同。皆是在載入畫面時會讀取資料。記得注意 Andriod 的版本問題，另外 SQLite 自己也有版本問題，請確保測試資料正確，紀律性的測試可以省去很多麻煩。viewlist/AddBtn &amp; viewlist/ViewList這兩個類別都包裝了動態新增物件的功能，新增動態物件其實相當麻煩，要考慮物件本身、事件、資料，因此我會盡可能將資訊都封裝在類別內，屆時只需要傳入必要參數即可，如任務有用物件包裝好，那理所當然直接傳遞物件即可。結語TTtiemr 亦有存在問題，目前我個人也不知道該如何解決。TTtimer 似乎在重複開啟太多任務後，會導致手機效能降低，吃掉太多CPU或記憶體。但此部分已經超過我對 Andriod APP 的認知，需要更專業的技術。但 TTtimer 所使用的技術，除了連線的需求之外，能滿足絕大部份的 APP 開發。這次的 Andriod APP - TTtimer 分享希望能幫助到大家，如果有任何問題也可以 Facebook 敲我或是寄信給我詢問細節，但請標明是誰詢問與相關的問題資訊。","raw":null,"content":null,"categories":[{"name":"學生時期","slug":"學生時期","permalink":"http://www.andrewchen.tw/categoriesl/學生時期/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.andrewchen.tw/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://www.andrewchen.tw/tags/Java/"},{"name":"學生時期作品","slug":"學生時期作品","permalink":"http://www.andrewchen.tw/tags/學生時期作品/"}]}]}