{"meta":{"title":"愛吃東西的RD - AndrewChen","subtitle":"Node.js、JavaScript、學習筆記、讀書心得、吃吃喝喝","description":"Node.js、JavaScript、學習筆記、讀書心得、吃吃喝喝","author":"AndrewChen","url":"http://www.andrewchen.tw"},"pages":[{"title":"About","date":"2017-01-31T01:40:49.000Z","updated":"2017-02-05T03:44:33.000Z","comments":true,"path":"about/index.html","permalink":"http://www.andrewchen.tw/about/index.html","excerpt":"","text":"AndrewChenNode.js backend developer &nbsp;&nbsp;&nbsp; Taipei, Taiwan &nbsp;&nbsp; chenpoanandrew@gmail.com如果對部落格內容有任何疑問，或是發現錯誤歡迎透過 Facebook 或是 Gamil 聯絡，請各位多指教。更多關於工作經歷、個人接案經驗也會在日後逐步更新到部落格中。","raw":null,"content":null},{"title":"Categories","date":"2017-02-02T11:31:23.000Z","updated":"2017-02-04T06:59:56.000Z","comments":false,"path":"categories/index.html","permalink":"http://www.andrewchen.tw/categories/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"Tags","date":"2017-02-02T11:31:23.000Z","updated":"2017-02-04T06:59:56.000Z","comments":false,"path":"tags/index.html","permalink":"http://www.andrewchen.tw/tags/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"","date":"2017-02-11T01:14:26.000Z","updated":"2017-02-11T01:14:26.000Z","comments":true,"path":"scripts/icon_fa-arrow-right.js","permalink":"http://www.andrewchen.tw/scripts/icon_fa-arrow-right.js","excerpt":"","text":"// 將 -> 更換成 i.fa.fa-arrow-right var article = $('#main').html(); var scriptStart = article.indexOf(''); article = article.substring(0, scriptStart); // 移除這串 script article = article.replace(/-&gt;/g, ''); $('#main').html(article);","raw":null,"content":null},{"title":"","date":"2017-02-11T01:32:01.000Z","updated":"2017-02-11T01:32:01.000Z","comments":true,"path":"scripts/test.js","permalink":"http://www.andrewchen.tw/scripts/test.js","excerpt":"","text":"console.log('第一次修改')","raw":null,"content":null}],"posts":[{"title":"Git 還原單一檔案","slug":"20170211_NOTE_git還原單一檔案","date":"2017-02-11T00:45:15.000Z","updated":"2017-02-11T02:23:05.000Z","comments":true,"path":"2017/02/11/20170211_NOTE_git還原單一檔案/","link":"","permalink":"http://www.andrewchen.tw/2017/02/11/20170211_NOTE_git還原單一檔案/","excerpt":"筆記：\n如何將 修改到一半的檔案 還原到 追蹤前 的狀態\n如何將 修改到一半的檔案 還原到 最後一個 Commmit 的狀態\n如何將某個 指定的檔案 還原到 指定的 Commmit 的狀態\n","text":"筆記： 如何將 修改到一半的檔案 還原到 追蹤前 的狀態 如何將 修改到一半的檔案 還原到 最後一個 Commmit 的狀態 如何將某個 指定的檔案 還原到 指定的 Commmit 的狀態 首先假設我們有一個 demo.js 檔案。經過了以下的操作： 第一次修改 demo.js -&gt; 將檔案列入追蹤 $git add ./demo.js -&gt; 第二次修改 demo.js 如何將 修改到一半的檔案 還原到 追蹤前 的狀態現在想要還原成第二次修改的樣子，操作步驟 直接還原即可，使用下面這個指令： 1$ git checkout &lt;file&gt; 備註：相同效果的指令 1$ git checkout -- &lt;file&gt; 如何將 修改到一半的檔案 還原到 最後一個 Commit 的狀態 解除 Git 對 demo.js 已經追蹤的部分 (Unstage)： 1$ git reset HEAD &lt;file&gt; 依上例還原即可 1$ git checkout &lt;file&gt; 如何將某個 指定的檔案 還原到 指定的 Commit 的狀態 查詢指定的 Commit ID 1$ git log 指定還原版本還原 1$ git checkout &lt;commitId&gt; &lt;file&gt; 參考資料： Git Docs 魚乾的筆記本 路破皮的部落格 zlargon Gitbook Apple Boy 更換成 i.fa.fa-arrow-right --> var article = $('#main').html(); var scriptStart = article.indexOf(''); article = article.substring(0, scriptStart); // 移除這串 script article = article.replace(/-&gt;/g, ''); $('#main').html(article);","raw":null,"content":null,"categories":[{"name":"做個筆記怕忘記","slug":"做個筆記怕忘記","permalink":"http://www.andrewchen.tw/categoriesl/做個筆記怕忘記/"}],"tags":[{"name":"重點筆記","slug":"重點筆記","permalink":"http://www.andrewchen.tw/tags/重點筆記/"},{"name":"程式設計","slug":"程式設計","permalink":"http://www.andrewchen.tw/tags/程式設計/"},{"name":"Git","slug":"Git","permalink":"http://www.andrewchen.tw/tags/Git/"}]},{"title":"人月神話 - 軟體專案管理之道","slug":"20170210_BOOKS_人月神話","date":"2017-02-10T15:00:49.000Z","updated":"2017-02-10T16:11:42.000Z","comments":true,"path":"2017/02/10/20170210_BOOKS_人月神話/","link":"","permalink":"http://www.andrewchen.tw/2017/02/10/20170210_BOOKS_人月神話/","excerpt":"\n作者：Frederick P.Brooks, Jr.譯者：錢一一出版社：經濟新潮社\n\n人月神話堪稱經典中的經典，直到最近幾年仍然時常被提起的一本必讀書。主要在討論軟體專案管理上的問題即規劃死角，個人認為無論是程式設計師、PM 或是相關主管甚至是客戶，都值得閱讀的一本書。而我閱讀的這本人月神話是 20 週年再版的書籍，其中已經有部分的修訂，但在書的後方仍然有登載出版的觀念與思考邏輯供讀者參考。人月神話大方向的討論了：軟體專案為什麼容易失敗、如何降低失敗的機率。大致上分為兩大部分，其餘的篇章分別舉出許多細節來支撐自己的論點。\n到底什麼是 “人月” 神話 ?","text":"作者：Frederick P.Brooks, Jr.譯者：錢一一出版社：經濟新潮社 人月神話堪稱經典中的經典，直到最近幾年仍然時常被提起的一本必讀書。主要在討論軟體專案管理上的問題即規劃死角，個人認為無論是程式設計師、PM 或是相關主管甚至是客戶，都值得閱讀的一本書。而我閱讀的這本人月神話是 20 週年再版的書籍，其中已經有部分的修訂，但在書的後方仍然有登載出版的觀念與思考邏輯供讀者參考。人月神話大方向的討論了：軟體專案為什麼容易失敗、如何降低失敗的機率。大致上分為兩大部分，其餘的篇章分別舉出許多細節來支撐自己的論點。 到底什麼是 “人月” 神話 ? 人月神話這個詞要拆分成兩個名詞來看，人月 + 神話，人月 指的是每個人每月的工作時間，專案規劃時使用每人每月的工時來估計進度，利用的 人月 這個單位來計算這個計畫是否可以完成。而 神話 則是直接表達了作者認為這種規劃方式是完全不可行的。與 神話 同樣不可能發生的劇情，這也是整本書中最底層的論點：規劃的方式錯誤導致整個專案失敗。 而人月中存在最明顯的問題有三個：第一，是一個人一個月的產值，通常不是 100% 發揮的。工作中會有許多的雜事影響或單純是開發者個心態、心情，各種 BUG 錯誤拖延等等，讓工時直接得低於預估的一個月工作量。第二，工時是無法堆疊的，兩個人的一月，並不等同於一個人的兩個月，軟體開發中有許多工作是有連續性的，先做完 A 才能再做 B，同時一個月加入另一個人並不會加快工作。第三，就算工作是完全可分割可同步進行的，整個專案中仍然有許多的知識迭代，無論在任何時期，加入新的人手，訓練、了解狀況都需要消耗時間，教導新手也會消耗老鳥的時間。作者更是明白的點出： 在一個進度已經落後的軟體專案中增加人手，只會更加落後 嘗試建立一個高度分工的團隊作者在一開始提出了一個類似 外科手術團隊 的完美架構，認為個個工程師各司其職，每個人負責好自己的區域，行程一個完美的開發團隊。核心概念是：由一個人操刀，其他人扮演支援性的角色。為了讓系統的整體架構設計有一個統一的概念，統一個設計思維。作者同意這屬於專制的團隊，由極少數人掌控著整個系統發展的方向和設計細節。理所當然的，對於這個獨裁者的技術能力、長遠的規劃視野就相當的重要。在設計模式和無暇程式碼的書中都有提到，系統、程式碼的設計最終原則就是要能體現出自己的目標，一貫的呈現風格就顯得相當重要。 這邊有相當重要的一點：高度分工的團隊需要優秀的領導者，首當其衝的就是這個領導者幾乎不能犯錯，因為每個開發者對於整個團隊的了解都是片面的，如果我們片面的了解事情，有時會相當難去判斷對錯。盲目的開發下，很有可能開發出 “完全符合需求卻錯誤” 的情況，需要領導者必須能完美給予任務命令或是能及時地發現這些錯誤。同樣，這名核心管理者也需要相當能力的溝通技巧。 關於溝通的部分，書中相當重視如何傳達想法。而作者的核心觀念是：完整的文件。同步這份文件、溝通的方式將會影響這整個系統的成敗。而今天的我們也知道，除了文件之外，我們有更多高階的語法、測試程式碼可以在這方面協助我們溝通。 作者相當推薦大家選擇更語意化的高階程式碼，從這邊可以嗅出一點這本書的年齡。 第二系統效應第二系統效應，在開發第一套系統時，會遭遇許多設計上的瑕疵，想要更多的功能，希望能重構的程式碼。會產生許許多多新的想法，但因為時間的需求或是開發上的難度，沒有辦法執行。當我在第二次開發同一個系統時，會瘋狂的將之前的願望通通加入到新的系統中，造成第二個系統的開發負擔，或是產品需求不夠明確。我們應該對一些特別的誘惑保持清醒，確保正確的概念與目標已貫徹到設計的細節之中。 規劃與管理的重點在規劃上，管理者是需要相當費盡心血。管理者必須明訂，並且嘗試推動整個專案往前，分割成片段式的工作，如果規劃得不夠明確、或是直接丟出超長時間的規劃，那就準備收到一個失敗的結局，因為沒有人會去進行。而規劃排成方面，書中使用大量的專案管理技巧，包括類似瀑布式的規劃、PERT圖等等，預估工作時間是相當困難的，除了專業技巧之外，需要相當多的經驗。 在專案整體的時間分割上，作者認為時間分配為： 33% 規劃 16.5% 撰寫程式 25% 組建測試和早期系統測試 25% 系統測試，完成所有組件 這邊有兩大個重點：撰寫程式的時間其實只有 16.5%，而組裝和測試的時間總合高達 50%，除了規劃需要使用 33% 我並沒有足夠的經驗之外，我個人相當支持後半段的說法，在合併功能時包含的估計除錯所需的時間，的確需要為後半段發生問題的可能性，預留更多的時間。 沒有銀彈專案管理到底有沒有正確的做法？有沒有真正的解決方案？答案是沒有，也沒有什麼好棒棒的工具可以解決一切的問題，沒有銀彈就是這個意思。專案管理除了專案本身難以估計之外，開發人員的問題、系統的問題、甚至是是否能應付客戶，都是會影響整個專案的結果。並沒有一個絕對的招式或是方式能解決所有的問題。仍然仰賴管理者的經驗和專業技巧。 結語這本書的觀念相當清晰，除了嘗試正確預估的工時之外，其餘的部分都在傳達我們要如何寫出正整潔的程式碼，穩定的系統是快速開發的基底，高品質的程式碼能有效的降低錯誤機率，因為錯誤是拖慢專案速度的元兇殺手。 在書中有提及一些東西我完全沒有提到，包括：高階程式語言、記憶體配置、專案管理的算法細節、結構設計、更好的開發工具等等，其中的內容也都是相當彩的篇章，但其實個人覺得有點跟時代脫節，舉例來說現在主流的 Git 就解決了許多作者所說的溝通和管理問題。而其餘設計細節，我認為這完全是另外的討論項目了，所以沒有在這邊多加贅述。 其實這本書明顯的感受得到年紀，畢竟出版是在 30 年前，但並不是說觀念老舊或是不合時宜。換而言之，我們現在手邊更多作者當初所期待的方便的工具，能協助我們來解決對應的問題，例如 Git, Github 就是很好的例子，讓我們能擁有便捷的溝通方式，而且是直接在程式碼上做溝通，測試、文件工具等等現在更是發展的一應俱全，如何利用這些配套的工具強化團隊效率，反而是我們當今的課題。","raw":null,"content":null,"categories":[{"name":"Code要好好寫","slug":"Code要好好寫","permalink":"http://www.andrewchen.tw/categoriesl/Code要好好寫/"}],"tags":[{"name":"讀書心得","slug":"讀書心得","permalink":"http://www.andrewchen.tw/tags/讀書心得/"},{"name":"重點筆記","slug":"重點筆記","permalink":"http://www.andrewchen.tw/tags/重點筆記/"},{"name":"程式設計","slug":"程式設計","permalink":"http://www.andrewchen.tw/tags/程式設計/"}]},{"title":"CleanCode 無瑕的程式碼 (下篇)","slug":"20170205_BOOKS_CleanCode1-2","date":"2017-02-05T15:50:49.000Z","updated":"2017-02-10T16:36:00.000Z","comments":true,"path":"2017/02/05/20170205_BOOKS_CleanCode1-2/","link":"","permalink":"http://www.andrewchen.tw/2017/02/05/20170205_BOOKS_CleanCode1-2/","excerpt":"\n作者：Robert C. Martin譯者：戴于晉、博碩文化審校：陳錦輝出版社：博碩文化\nCleanCode 無瑕的程式碼 (上篇)\n\n接續著前一篇，無瑕的程式碼前半段著重於程式碼的季節面，下半段討論更多大方向的目標，討論規劃系統架構、測試、程式碼橋接規劃等，不再是單一個程式設計師自己撰寫程式碼的世界觀，書中講述更多的團隊運作方式和長期規劃方面的觀念。\n從更高的視角看整潔程式碼除了命名正確之外，個人的經驗是當系統成長到一定的規模時，開發者會不願意去面對舊有的程式碼，就算命名相當正確、易讀易懂，但修改或新增功能總是需要大動干戈，綁手綁腳的東修西改。同時因為這個原因，常常讓我放棄重構的念頭，有時甚至是直接刪掉某個部份的程式碼重來。想當然爾，這種錯誤只會日積月累，屆時將會進入完全無法挽回的地步。及早發現、儘早治療。\n畫圈圈耍自閉，跟其他人劃清界線","text":"作者：Robert C. Martin譯者：戴于晉、博碩文化審校：陳錦輝出版社：博碩文化 CleanCode 無瑕的程式碼 (上篇) 接續著前一篇，無瑕的程式碼前半段著重於程式碼的季節面，下半段討論更多大方向的目標，討論規劃系統架構、測試、程式碼橋接規劃等，不再是單一個程式設計師自己撰寫程式碼的世界觀，書中講述更多的團隊運作方式和長期規劃方面的觀念。 從更高的視角看整潔程式碼除了命名正確之外，個人的經驗是當系統成長到一定的規模時，開發者會不願意去面對舊有的程式碼，就算命名相當正確、易讀易懂，但修改或新增功能總是需要大動干戈，綁手綁腳的東修西改。同時因為這個原因，常常讓我放棄重構的念頭，有時甚至是直接刪掉某個部份的程式碼重來。想當然爾，這種錯誤只會日積月累，屆時將會進入完全無法挽回的地步。及早發現、儘早治療。 畫圈圈耍自閉，跟其他人劃清界線 邊界，是系統設計中一個簡單易學且效益極高的設計重點。以 Node.js 來說，會頻繁地使用到第三方套件，而更新第三方套件、客戶更改需求、或抽換相依套件，以上這些動作相當的困難且風險極高。小幅度的更改讓系統看似沒有問題，但完全不知道啥時會爆炸出個莫名其妙的 Bug。當有大範圍需要修改時更是可怕，個人經歷是改下去以後，東邊爆炸西邊起火，搞了老半天系統還沒正常過，好不容易穩定下來後來仍然令人疑心疑鬼。 邊界最單純的作法就是在引用第三方套件時，包裝一次成為自己的介面，這個包裝的地方，即可視為所謂的程式碼邊界。爾後開發統一引用包裝過後的介面，而邊界函數橋接的第三方套件則是外部程式碼，明確的劃清雙方的界線。透過定義自己程式的邊界，明確的定義自己的維護案範圍，並同時降低了對外的耦合，避免雙方程式碼高度的交織。並針對使用中的介面撰寫一套測試，確保對外的依賴運作正常，在升級版本時即可大幅地減輕痛苦。而升級時如果對方API有修改，透過邊界一次性的修改即可，不須逐一在專案中追逐散落在各個角落的引用。 另一個角度，開發時也可以利用邊界，在其他API尚未完成時進行開發，完成後再橋接邊界另一半的程式碼。 測試程式碼是一種品質保證無論是否是利用 TDD ( Test-driven Development，測試驅動開發)，測試仍然一樣的重要。除了上述的邊界測試、減輕修改程式碼負擔之外，測試更有心理層面的效果：給予開發人員修改的信心。讓我們在修改程式碼後，確認功能仍然正常運作。測試分為相當多個層級，在許多書中有不同的論點。個人的經驗是至少要對系統的最核心功能有一套測試保護，並模擬使用者整個操作的流程，這樣能在最簡單的情況下，保證著系統還算是正常的運作，不至於整個系統崩潰了卻無人知曉。以 EC 來說，最核心就是結帳功能，如果能時時確保功能正常，是完全沒有爭議的好事情。 如果讓你的測試程式碼腐敗，那麼你的產品程式碼也會跟著腐敗。請保持你的測試整潔。 雖然說測試的速度並非首要，但會影響到開發人員的效率或是心態，因此頻繁、簡便、快速的測試仍然是很重要的，細心的維護您的測試程式碼： 多弄幾次整理好重構，基於有測試保護功能正常，開發者能放心的重構程式碼，將程式碼重構成理想的結構，更加明確的表態功能作為，甚至是修改效能、強化防呆等等。 在許多書中都提及相同的開發經驗：請立即重構，不要擱置。擱置重構只會讓這個問題繼續蔓延下去，放著放著忘記了，之後就沒人管了。這個污痕將會永留存。立即重構也利於開發速度，開發者也對相關狀況最清楚的時候重構程式碼，成本也相對低的。 這些都是常見的致命陋習書中在最後的篇幅大幅度的探討常見的錯誤，諸如： 不適當的註解程式碼修改後沒有跟著修改註解、多餘的廢話等等。註解應該保留給技術性紀錄。而冗餘的註解程式碼，就刪掉他吧！我們都有 Git 了！ 亂來的函數函數在沒有特地請求的情況下”順便”回傳了其他資料，這會造成其他開發者的困擾，只因為我們在其他邏輯上將這兩個功能結合在一起，正確的做法是徹底的切割功能。 旗標參數，我之前就常犯這個錯誤，在函數的傳入參數中加上類似 flag:boolean 的參數，讓函數能根據 flag 變化，錯誤相當明顯：這個函數做了兩件事情，pure function 才是王道啊。函數中如果真的有複數的操作，請明確地反映在函數名稱上面，雖然說函數上方能撰寫說明註解，但更多的狀況是開發者在其他處看到類似的功能，複製後就直接嘗試使用。 請用大眾化的思考方式思考最少驚奇原則，當然系統中會有很多巧妙的設計，但撰寫程式碼時讓其他程式設計師訝異不是件好事情，無意義的多回傳東西，多修改其他地方的值或是參數等等，都是屬於不必要的功能，甚至造成無意義的困擾。當然也不要無意義的炫技，讓人看得懂的程式碼才是最好的。 減少整個專案中重複的程式碼，嘗試利用已經擁有的功能，或是在已經擁有的套件中擴充功能，有時閱讀別人的程式碼很令人煩躁，但事實這就是這樣，屢次的堆疊新功能和新程式碼上去，雖然有明顯的短期收益，但對整體專案的健康影響是相當大。 找到重複的地方，並移除這些重複。 而程式碼的排序、編排方式也是相同的，專案中使用一樣的 Coding Style 算是相當基本的要求。命名也是相同的邏輯，temp, tmp 在普遍的認知中就是暫存用的資料，如果是使用者資料請用 user, users 等等，濫用無意義的命名會帶來更多的痛苦。 1234// 有講跟沒講一樣的 function namefunction dataOperator(data) &#123; // ...&#125; 在許多複雜的結構設計中，遵循設計模式是個不錯的選擇，簡單地表明是工廠模式、橋接模式等，會為閱讀者帶來更明確的方向和視野。 不要偷懶偷懶是一切問題的開始，正確地表達程式碼語意，在短期上面看似工作效率更低，但多為未來的自己著想，不要偷懶不撰寫測試程式碼或是文件，這些東西在往後會以更高的成本出現，趁早完成對大家都有好處。如果 PM 或是老闆不同意，嘗試說服他吧！同時，當我們在修補 Bug 時，也可以試著為 Bug 補上對應的測試，避免後人犯錯，同時詮釋了自己這次修改的程式碼原因。 結語在無瑕的程式碼中，有一部分的章節討論多執行緒的開發與設計，在這部分的內容我並沒有寫進心得中，主因是我撰寫這個部落格時技術核心是選擇：Node.js。我仍然相當推薦書中的內容，嘗試透過多執行語言的開發問題來反思非同步開發，是相當有助益的。 而整本書帶給我的，最多的是開發上的思維整理，會突然想到說：啊！原來就是因為當初那樣寫才…。有很多錯誤都是我在學生時期犯過的，在工作之後有嘗試著改變，閱讀此書之後大大的幫助我整理，讓思路更明確且清澈，同時也明確的感受到前人犯下的錯誤，期許自己能在程式開發生涯中，更自律的要求自己。","raw":null,"content":null,"categories":[{"name":"Code要好好寫","slug":"Code要好好寫","permalink":"http://www.andrewchen.tw/categoriesl/Code要好好寫/"}],"tags":[{"name":"讀書心得","slug":"讀書心得","permalink":"http://www.andrewchen.tw/tags/讀書心得/"},{"name":"重點筆記","slug":"重點筆記","permalink":"http://www.andrewchen.tw/tags/重點筆記/"},{"name":"程式設計","slug":"程式設計","permalink":"http://www.andrewchen.tw/tags/程式設計/"}]},{"title":"CleanCode 無瑕的程式碼 (上篇)","slug":"20170205_BOOKS_CleanCode1-1","date":"2017-02-05T14:55:10.000Z","updated":"2017-02-05T15:28:44.000Z","comments":true,"path":"2017/02/05/20170205_BOOKS_CleanCode1-1/","link":"","permalink":"http://www.andrewchen.tw/2017/02/05/20170205_BOOKS_CleanCode1-1/","excerpt":"\n作者：Robert C. Martin譯者：戴于晉、博碩文化審校：陳錦輝出版社：博碩文化\nCleanCode 無瑕的程式碼 (下篇)\n\n無瑕的程式碼，其實是我第二次詳細閱讀這本書。第一次是在大學一年級，剛開始寫程式的我根本完全看不懂書中在寫什麼啊！每字每句話都能看懂，卻完全無法理解意義或是體悟到任何的道理，丟在書架上幾年後，工作之餘再重新看了一次。這次感觸良多，有些是我犯過的錯，有些對我來說是重要的警告。總之，我認為這是一本程式設計師必讀的書，說是學習一種新的知識或是撰寫技巧其實並不精確，個人覺得是幫助自己釐清撰寫程式碼時的思考、自我反省的一本書。看完這本書仍然取決於我們自己要改變多少做事的風格。\n為什麼需要花時間維程式碼的整潔？真正的”無瑕”的程式碼的定義是什麼？在第一章節作者給了一個大概的方向：無暇程式碼就是在追求程式碼的表達能力，且沒有任何一個流派是絕對正確的。維護整潔的程式碼，不僅僅是程式設計師對於專業的自我要求，也是在日益龐大的系統開發中，迫切需要重視的問題。或許在小型的專案中我們能仰賴記憶力、猜測、或是一些經驗推導來維持整個專案的運作。隨著團隊的人數擴增、專案程式碼行數的成長、甚至單純是客戶的要求朝三暮四的變化，整潔的程式碼開始成為必要的開發條件，不論是實質上的效率問題，甚至是影響到日後的修改、維護，缺乏整潔觀念的程式碼必然會帶來一場災難。\n整潔程式碼的第一步討論變數命名、函數、註解、程式碼編排等等細節的技巧，在這部分我在學生時期就有特別在注意，但往往沒有相當明確的方向與見解，以下綜合書中的資訊和我在職場前輩身上學到的智慧，大致整理成以下幾個重點：","text":"作者：Robert C. Martin譯者：戴于晉、博碩文化審校：陳錦輝出版社：博碩文化 CleanCode 無瑕的程式碼 (下篇) 無瑕的程式碼，其實是我第二次詳細閱讀這本書。第一次是在大學一年級，剛開始寫程式的我根本完全看不懂書中在寫什麼啊！每字每句話都能看懂，卻完全無法理解意義或是體悟到任何的道理，丟在書架上幾年後，工作之餘再重新看了一次。這次感觸良多，有些是我犯過的錯，有些對我來說是重要的警告。總之，我認為這是一本程式設計師必讀的書，說是學習一種新的知識或是撰寫技巧其實並不精確，個人覺得是幫助自己釐清撰寫程式碼時的思考、自我反省的一本書。看完這本書仍然取決於我們自己要改變多少做事的風格。 為什麼需要花時間維程式碼的整潔？真正的”無瑕”的程式碼的定義是什麼？在第一章節作者給了一個大概的方向：無暇程式碼就是在追求程式碼的表達能力，且沒有任何一個流派是絕對正確的。維護整潔的程式碼，不僅僅是程式設計師對於專業的自我要求，也是在日益龐大的系統開發中，迫切需要重視的問題。或許在小型的專案中我們能仰賴記憶力、猜測、或是一些經驗推導來維持整個專案的運作。隨著團隊的人數擴增、專案程式碼行數的成長、甚至單純是客戶的要求朝三暮四的變化，整潔的程式碼開始成為必要的開發條件，不論是實質上的效率問題，甚至是影響到日後的修改、維護，缺乏整潔觀念的程式碼必然會帶來一場災難。 整潔程式碼的第一步討論變數命名、函數、註解、程式碼編排等等細節的技巧，在這部分我在學生時期就有特別在注意，但往往沒有相當明確的方向與見解，以下綜合書中的資訊和我在職場前輩身上學到的智慧，大致整理成以下幾個重點： 排版、正確註解排版和正確語意的註解是相當基本的東西，基本除了不要亂雷別人之外，沒有什麼爭議問題。最需要討論的應該就是註解的量，有些開發者會相當仰賴註解把事情說清楚，而另一派的開發者認為，當前開發的語言幾乎都是高階語言了，我們透過變數和函數的命名就應該將事情說明清楚。我個人是支持後者的說法，在工作經驗中也是比較偏向後者的作風。註解只用來補足某些程式碼無法陳述的部分而已，嘗試更精確地名命、重構程式碼才是正確的整潔方式。 而註解掉的廢棄程式碼則是完全不應該出現的，刪除時應當對程式碼負責。總之，這是版本控管的事情了，他本身就不應該留在那邊。註解下來的程式碼，只會變成永遠的殘存程式碼放在那邊而已，而沒有人敢去刪除它，留著他感覺很重要，但是註解掉就代表不需要了。 不要白目、避免自己犯錯不論是常數、變數、函數甚至類別命名等，最重要的事情是如實的反應內容，當然擁有很多命名的規則，或是慣用的習慣，但最大的重點是忠實的反應實際上的內容。同時不要使用無意義的命名：諸如 tmp, data 這些命名其實是我在學生時期撰寫程式碼常用的，當然因為我多半是一個認自己寫，我總是知道 tmp 我多半用在拆解資料，data 通常我用在 API 或是函數回傳的資料。但真正的主因是學生時期的系統往往不太複雜，就算我繳交過最複雜的幾個 APP 和選課系統，往往都是瀑布式開發，一次完成的。命名最大的影響在於：當我們回頭看自己的程式碼時。當我們回頭追尋問題、修改功能、甚至是看別人的程式碼時，這些無意義的命名將會造成很大的影響，問題小則浪費時間，大則用錯變數、重疊使用變數，造成交叉感染。當然白目的命名就更不可取了 magicNumber、justDoThis() 等，當我們自己在撰寫時可能覺得情投意合，完全表達了我們想表達的狀況，但往往會造成更多的誤導。 而在命名的選擇中，需要仔細的衡量 “完全表達內容” 和 “避免贅述”，並且找到適當的平衡點，不要一昧的把變數名稱拉長來完整描述狀況，適當即可。何謂適當？我自己認為這就是專業的 Developer 和 Programer 之間的第一個差距，在龐大的組織中會針對開發做細節的規範，但如果只會死板地遵循規範，不應該是一個稱為智力型工作者的 Developer 該有的樣子。 函數即映射這是在前一份工作的前輩指點，幾個月前的自己對於函數命名犯下許多錯誤，但當時並不知覺，在之後雷到自己。函數即映射 很明確的指出，每個函數的名稱應該正確的描述自己內部的行為，同時可推導出 pure function 的觀念，一個操作或是一個動作，就是一個函數，片段的函數在組合包裝成更大的功能，層層包裝之中，必須分工明確，這樣才能完整地描述整件事情的操作流程。這其中有一個相當重要的觀念需要注意，函數不應該有副作用，超出預期功能的函數並不會比較方便，而是製造更多的麻煩而已。 善用物件及資料結構來表達類似於封裝的觀念，了解物件真正要做的事情是什麼，完整的命名後打包，正確的封裝來避免外界的干擾，同時也是減少對外界傳達不必要的資訊。而針對 Node.js 在這部分的觀念，個人認為重點是善用第三方套件，用大家熟機的套見就像使用物件一樣，將程式更明確的語易化，而熟悉的套件功能，也減少了閱讀程式碼的成本，更明確的闡述一切。舉例套件 lodash，lodash中友需許多多已經包裝好的片段功能，協助我們取出資料、整理資料等等，很多功能其實也只要單純一兩個迴圈加上幾個if便可以完成，但在不考慮效能的情況下，第三方套件會比自己撰寫的迴圈來得更語意明確。 層層的錯誤處理錯誤處理是大型型系統開中最重要的環節，在中後期開發或是功能橋接的階段，不可避免的事面對各種錯誤，而如何尋找出錯誤，除了仰賴工程師自己的技巧之外，透過錯誤處理系統正確的承接錯誤的來源也相當重要，正確的定義每個錯誤，避免整個系統只使用少數幾個甚至一個錯誤包裝。先前我覺得全域是的承接錯誤很方便很帥，結果在系統開發中後期造成了不少的困擾。當然逐層追回仍然能解析出來錯誤真正的原因，但是在每個承接錯誤的地方加上註記，或許會來得更好。","raw":null,"content":null,"categories":[{"name":"Code要好好寫","slug":"Code要好好寫","permalink":"http://www.andrewchen.tw/categoriesl/Code要好好寫/"}],"tags":[{"name":"讀書心得","slug":"讀書心得","permalink":"http://www.andrewchen.tw/tags/讀書心得/"},{"name":"重點筆記","slug":"重點筆記","permalink":"http://www.andrewchen.tw/tags/重點筆記/"},{"name":"程式設計","slug":"程式設計","permalink":"http://www.andrewchen.tw/tags/程式設計/"}]},{"title":"被討厭的勇氣 (下篇)","slug":"20170131_BOOKS_被討厭的勇氣1-2","date":"2017-01-31T11:10:15.000Z","updated":"2017-02-05T15:27:54.000Z","comments":true,"path":"2017/01/31/20170131_BOOKS_被討厭的勇氣1-2/","link":"","permalink":"http://www.andrewchen.tw/2017/01/31/20170131_BOOKS_被討厭的勇氣1-2/","excerpt":"\n作者：岸見一郎、古賀史健譯者：葉小燕出版社：究竟出版\n被討厭的勇氣 1 (上篇)\n接續著上半篇的心得，後半部的阿德勒開始討論自我定位的問題，當我們完全脫離別人的看法之後，我們自己該如何定位自己？更該如何跟別人相處，如何繼續地用自己的方式，在社會的洪流中生活下去。\n個體心理學與整體論","text":"作者：岸見一郎、古賀史健譯者：葉小燕出版社：究竟出版 被討厭的勇氣 1 (上篇) 接續著上半篇的心得，後半部的阿德勒開始討論自我定位的問題，當我們完全脫離別人的看法之後，我們自己該如何定位自己？更該如何跟別人相處，如何繼續地用自己的方式，在社會的洪流中生活下去。 個體心理學與整體論 無法再分割的最小單位。精神與肉體無法分割、理性與情感無法分割、意識與無意識無法分割 這邊指的無法分割是指我們在表達情緒時，整體是不可分割的，當我們在發脾氣時、在爭論時，理性與情感是無法分割的，也就是無論我們多麽理性，我們仍然是透過整個整體在與人溝通，無論如何都是兼具了理性與感性。 人際關係的終極目標在於 “社會意識” 把別人當成夥伴，並感覺到有自己的歸屬，稱為社會意識。 共同體，共同體的目標也是整個社會。 把對自我的執著轉變成為對他人的關心。 你不是世界的中心 為什麼只關心我?做不到 “課題分離”，被認同需求束搏的人，也是極度以自我為中心的。 阿德勒的觀點為：希望自己取得社會的認同，這個觀點也只是從自己出發而已。只在乎別人是如何看我的這種生活方式，就是所謂的自我中心，只關心”我”的生活型態。 別人並不是為了滿足你的期望而活，你只是共同體的一部份，不是中心。 重新去思考自己能帶來的價值，能為大家貢獻什麼，而不是單純的思考自己能從大家那邊得到什麼。而為大家帶來什麼貢獻，這點是出自於善意，並不是為了獲得大家的讚賞，而是實質的非強迫性幫助。 歸屬感避不是與生俱來的，而是要靠自己的雙手去獲得。 人際關係 –&gt; 課題分離 –&gt; 社會意識 社會意識的觀點在於共同體，不斷拉高自己的高度，透過巨觀的思維來看整件事情。不要把事情看得很單一，例如：誰誰誰不愛我了，我的人生…。要拉高看事情的維度與角度，瞭解到這些事情是本來就有可能發生的，並不是針對自己，遭遇變故後這整個世界也仍然在運轉，並沒有因此而停止。 在害怕關係崩壞的恐懼下過日子，其實只是為別人而活，是不自由的生活方式。 不責罵，也不稱讚 背後的目的都是操控。 如果透過單一手段的話，很容易二元化整個世界的事情，並開始追究是非對錯，達成事情只是為了避免責罵，或獲得獎賞，當我們抽掉賞罰時，會感覺到是事情是沒有意義。這個心態並不樂見。 阿德勒心理學否定縱向關係，支持一切的橫向關係。 縱向關係就是導致介入他人的課題的直接原因。因為覺得自己會處理得比對方更好。縱向關係會在自己的對外的各個感情中傳染，當你用縱向關係的心態去瞧不起某人時，另外一方面就投射出縱向關西的崇拜或是尊重另一個人，反之亦然。當我們用縱向關係在看但人際關係時，就會出現階級的情況，這會讓人際關係陷入利益的狀態，例如跟XXX約遲到一下沒關係，但是跟OOO約絕對不能遲到。而這種縱向關係最終會反映在重要的事情決策上，或是面對對方的態度。 只要你與任何一個人建立了縱向關係，不知不覺間你所有的人際關係都會採用縱向的方式。 關於稱讚 稱讚是一種有能力者給無能力者的評價。 責備容易導致迴避的處事行為，不斷地稱讚會導致被稱讚的人缺乏信心，稱讚也常常讓人誤解是為了稱讚而稱讚的。這邊的情緒處理相當的複雜，真誠與誠實是相當難掌握的，說者無心聽者有意，純粹的鼓勵往往令人起疑。 人只有在自己有價值的時候，才會有勇氣。 感謝，或是橫向的稱讚，都屬於比較好的方式。讓人感覺到對整件事情有幫助，感覺到自己有價值。因此肯定他人的作為，是一個更扎實的稱讚方式。(在兼具情與理的表達方式一書中有類似的說法)。 當一個人覺得我對共同體來說是有益的時候，就能感受到自己的價值。 這邊就詮釋了自卑感議題，為了追隨別人的觀感，在自己的心中映射出理想的自己，現在的自己與理想中的自己有差距，進而產生了自卑感，這個自卑感也有可能用自傲、炫耀來包裝。自卑感有可能產生動力，也有可能找藉口來詮釋這個自卑感，這時就成了人生的謊言，用來迴避自己無法解決的課題。獲得感謝不是從別人那裡獲得好的評價，而是自己主觀的認識我對別人有貢獻，間接地解決了自卑感的問題，接著有可能可以逐漸解開人生的課題，這屬於一種橫向的幫助，比縱向的幫助、直接性的稱讚來的有效果。 只要存在，就有價值 我們不以行為的層級，而是已存在的層級來看待別人。 社會意識，必須以人開始去做。就算其他人不配合，也和你沒關係。應該由你開始，完全不必考慮其他人是否提供協助。 這大概是整本書最接近我自己核心思想的一句話。但難免受傷、難免難受。有本書 “把這份愛傳下去”， 核心邏輯就是這個，總要有人開始，而不計代價。這樣就能像湖中的漣漪，傳遍整個水面。由自己開市就是最好的方式。 小結交友的課題，不只單單是交朋友，包括與朋友相處上的關係，職場上的人際手腕等等，與整個社為的人相處的關係，這遠比想像中來得複雜，這包括了人與人之間的對等溝通，並且透過自己讓社會變得更好。幫助的不只是整個社會，同時也是在幫助自己，與社會地位比自己低的人建立橫向關係，同事就是在幫助自己與長輩建立橫向溝通的方式，也消除了自己的自卑感。 認真地活在當下過多的自我意識，反而牽制自我 不是肯的自我，而是接納自我 接納自我 信任他人 貢獻他人 接納自我接納自我跟肯定自我是不同的，自我肯定是肯定成功，說服自己能辦到，接納自我是接受那個失敗的自己，當失敗時無力挽回。並在接納之後，繼續的盡最大的努力前進。 積極正面的斷念 這就是整個阿德勒心理學最重要的核心價值之一，積極正面，明確的了解自己該做什麼，並且壁面自己陷入過往的泥沼中。不過份的肯定自己，正面的為自己努力，同時嘗試去幫助他人，一切是為了讓自己更好，讓自己對攝位多少有點貢獻。 主啊求你四我平靜的心，去接納無法改變的事情;賜給我勇氣，去改變可以改變的東西;並賜給我智慧，去分辨這兩者的差異。— 尼布爾&lt;寧靜的祈禱文&gt; 我們並非能力不足，只是缺乏勇氣而已。 信用和信任有什麼不同 相信別人的時候不附加任何條件，再怎麼樣無條件信任他人，最後不過是遭受背叛而已。 重點並不是無條件的幫助別人，應該是在能力範圍內，而在幫助別人時，就只是幫助而已。不要在對方請求幫助時馬上產生懷疑，人跟人互相猜忌，會變得更複雜，觀念與 “把這份愛傳下去” 雷同，只要關心自己怎麼做就好，關心自己能不能幫助人，而不是反覆思考是否受到詐騙。 只要你害怕信任，終將無法與人建立深厚的關係。 這邊的論點在現實社會中比較難令人接受。這篇像大同世界的思考，屬於一種改變世界的手段，如果從現在起每個人都真誠以待，那這個世界就會變得更單純、更歡樂。 工作的本質在於對他人貢獻 所謂的貢獻他人並不是捨棄自我去為某人鞠躬盡瘁，而是為了實際感受自我的價值 在整體社會共同體中，社會意識是讓自己有安全感的來源。可以說是一種存在感、自我價值感。阿德勒心理中認為，改變自我需要呼費過去 50% 的歲數時間也就是 20 歲的人需要花 10 年改變，同理，越年輕的人開始嘗試是理解，就能越早改變。 工作狂是人生的謊言 無論在哪種情況下，發動攻擊的那個人是有問題的，絕不是大家都錯了。 這邊同事要思考，自我價值、情緒是種工具以及社會意識。人與人之間相處的方式。 別把焦點放在無關緊要的小部分，甚至打算用狹隘的觀點來評論全世界。 這種事情的極端狀況就是憂鬱症、躁鬱症等行為。但也有可能是比較讓然感覺正面的事情：工作狂。 以工作為藉口迴避其他責任。 以工作為藉口迴避其他人生的課題。交友的課題、愛的課題。這種就屬於先前提到的：行為層級。以自身的行為定義自己，並不是真正的存在的層級，不夠透徹了解自身的價值。 由這一瞬間開始變得幸福阿德勒認為：幸福來自己認定自身的價值。自己所做的貢獻，可能可見或是不可見。 所謂的幸福，就是貢獻感。 這就屬於社會意識的範疇，了解自己的存在、自己的貢獻後就不需要別人的人同來定義自己的供獻。不屬於追求別人的認同感時，就能放下那個來自人際關係的包袱不必成為別人或是某個自己期待受到肯定的人，而是自己就是自己，自我認同，就不會以行為的層級，而是真正存在的層級參與社會的共同體。 想成為特別存在的人有兩條路 為了得到別人的關注，脫離普通的狀態，成為特別的存在 有可能特別好，也有可能特別壞。當我們透過不太正當的手段追求受到關注，例如小孩子的打鬧，或是其他蓄意引人注目的問題，屬於簡便的追求卓越，追求的是自己受到關注的感覺，某種層面上，這也屬於一種自私的行為，單純為了滿足自己而已。 甘於平凡的勇氣 我們沒有必要刻意誇耀自己的優越性 人生是一連串的剎那活在當下。追求的是此刻的心態，回頭時候看到許多光彩，這邊的觀念偏向說，並不是所有的事情都要完美個站照規劃達成，才能擁有好結果。如果你去爬山，計畫爬到山頂，可是爬了一半就下來，仍然是去爬山，並不是一切都要按照計畫的完美執行。而是當下最努力的我們，才適當我們在回憶時最甘甜的剎那。 過去發生什麼事情，和當下沒有關係，而未來會如何，也不是當下要考慮的問題。不要用直線去衡量自己已經走到了哪裡，要看看每個剎那是如何度過的。 從更現實的角度來看，如果我現在即刻身亡，我會後悔什麼，我最在意的是什麼，這就是這個剎那。這相當的難實踐。 只要貢獻他人這顆引導之星還在，就不會徬徨，做什麼都可以。 將自己導向正確的路途上 必須有人開始去做。就算其他人不配合，也和你沒關係。這就是我的建議。應該由你開始，完全不必考慮其他人是否提供協助 現在，就是現在，當我們想通的這一瞬間。","raw":null,"content":null,"categories":[{"name":"好書筆記","slug":"好書筆記","permalink":"http://www.andrewchen.tw/categoriesl/好書筆記/"}],"tags":[{"name":"讀書心得","slug":"讀書心得","permalink":"http://www.andrewchen.tw/tags/讀書心得/"},{"name":"心理學","slug":"心理學","permalink":"http://www.andrewchen.tw/tags/心理學/"},{"name":"自我成長","slug":"自我成長","permalink":"http://www.andrewchen.tw/tags/自我成長/"},{"name":"重點筆記","slug":"重點筆記","permalink":"http://www.andrewchen.tw/tags/重點筆記/"}]},{"title":"被討厭的勇氣 (上篇)","slug":"20170131_BOOKS_被討厭的勇氣1-1","date":"2017-01-31T02:20:15.000Z","updated":"2017-02-05T15:27:51.000Z","comments":true,"path":"2017/01/31/20170131_BOOKS_被討厭的勇氣1-1/","link":"","permalink":"http://www.andrewchen.tw/2017/01/31/20170131_BOOKS_被討厭的勇氣1-1/","excerpt":"\n作者：岸見一郎、古賀史健譯者：葉小燕出版社：究竟出版\n被討厭的勇氣 1 (下篇)\n2015年最火紅的書莫過於就是&lt;被討厭的勇氣&gt;，有別於一般心理學書籍，作者從個人心理的觀點來探討個人跟整個社會的互動，把焦點放在自己身上，了解自己、改變自己，不再是去瞭解他人或是嘗試透視對方的想法。思考自己在做什麼，讓自己的外在表態或是內在的心靈強化是書中相當明顯的觀點，而當我們自己變得更好時，或許也能帶動身邊的人跟著改變。\n否定心理創傷","text":"作者：岸見一郎、古賀史健譯者：葉小燕出版社：究竟出版 被討厭的勇氣 1 (下篇) 2015年最火紅的書莫過於就是&lt;被討厭的勇氣&gt;，有別於一般心理學書籍，作者從個人心理的觀點來探討個人跟整個社會的互動，把焦點放在自己身上，了解自己、改變自己，不再是去瞭解他人或是嘗試透視對方的想法。思考自己在做什麼，讓自己的外在表態或是內在的心靈強化是書中相當明顯的觀點，而當我們自己變得更好時，或許也能帶動身邊的人跟著改變。 否定心理創傷 心理創傷並不存在阿德勒心理學明確的否定心理創傷。 不要由經驗來決定自我，而是由經驗賦予的意義來決定。 我們每個人都為了某個目的而活著。 應該追究的，不是過去的原因，是現在的目的。 決定論 目的論 決定論因果關係，就是典型的決定論。因為什麼原因，造成現在這樣。雖然看似邏輯正確，但心中其實是將事情的結果推向過去的自己，否定現在的是幾，從某個方面來說我們往往忽略了人能掌控自己的情緒，面對失敗，了解原因及可，不要將責任推給過去。 目地論目的論的觀點認為，人的每個行為、情緒變化等等，都是有目的性的，我們透過表達自己的情緒，來得到自己想要的成果。與決定論完全相反的是，決定論認為：”我因為XXX事情，所以我現在生氣了”，但在目的論認為：”你現在生氣，是為了達成ＯＯＯ目標”。舉例來說，決定的論點是：”因為你掃地沒掃乾淨所以我生氣”，認為”我生氣是別人造成的”。目的論則認為：當下在生氣時，其實是透過情緒表達，希望對方折服自己並認真打掃，情緒變成了一種手段，而非被動的產物。(透過這個論點可以反思，我們是能控制自己的情緒的，能收放自己的情緒。) 人，會捏造憤怒的情緒即是目的論的核心論點。藉由捏造的憤怒的情緒，來達成某種目度。這種情緒並不是所謂的 “無法控制” 或是 “衝動”。如果人們能夠不遷怒，那就代表憤怒是可以收放自如的 “工具” 。我們藉由憤怒的情緒來讓自己的行為合理化，是一種使人屈服於自己的手段。 不受過去支配的生活方式 不論是從 “人不受過去控制” 或 “人不受情緒控制” 的層面來說，阿德勒心理學都是與虛無主義者對立的思想，是哲學。 問題不在於過去發生了什麼事情，而是我們怎麼去解釋它。例如說成功的喜悅可能沖昏頭，失敗可能激起更多的浪花。每個人的生命中都會發生各種產生正面利益或是負面利益的事情，重點在於我們怎麼去詮釋狀況，從發生的狀況中我們得到或是學習到什麼。 人並非受過去的原因而行動，而是朝向自己決定好的目的而行動。 改變 改變的第一步是要先知道。答案，不應該是由誰告訴你，而是你自己親手去找才對。 改變、成長都需要靠自己，一切的起頭也需要自己來。過程中的經歷才能淬煉成結果。不斷地灌輸觀念，不如人自己反思、自我思考。 幸與不幸，是自己選的 沒有人單純只是為了做壞事而做壞事，所有犯罪的人都有讓他犯罪的內在 “正當理由”。例如，因為金錢糾紛而殺人，對當事人來說，他因為自以為的 “正當理由” 而採取行動。換句話說，是在執行 “自以為好” 的 “善” 事。當然，這裡所說的 “善” 並不是指道德上的良善，而是 “為自己的” 善。希臘語中的 “善” 跟道德沒有關係，純粹是 “有用” 的意思;另一方面 “惡” 是指 “沒有用處”。 我們往往選擇對自己有利的狀況，可能自覺、可能不自覺，這種有利的狀況多半屬於短期有利，當下自己覺得舒服或方便而已，有可能是安於現狀，亦可能只是面子掛不住。所謂的 “目的論” 就是指人們只是為了達成某種目的，而做出的情緒反應而已，並透過其他的原因來詮釋現在的自己。但多半的時候人們透過 “決定論” 來解釋自己也是情非得已，並沒有了解到自己內心中正正的目的性。 人，常常決定不要改變生活型態 life style是人的性格或是氣質。並非直接指物質的生活狀況。 如果生活性態不是天生的，而是自己選的，那就有重新選擇的可能性。 人們往往不願意改變，儘管自己已經知道有地方需要改變，儘管知道已經造成別人的抱怨，但往往我們覺得 “安於現狀” 是輕鬆的，不確定的未來，人們總是不願意去冒險。 缺乏便幸福的勇氣。 人生決定於當下一種捨棄現有的生活型態的決心。就像在第一次做壞事一樣，變好一樣也需要有改變的勇氣，第一次運動時會覺得想放棄，同樣的，第一次偷東西的人，也會猶豫或是考慮要不要收手。 無論之前你的人生發生過怎麼樣的事，那對於你將來要怎麼過日子一點影響都沒有。 人生過去的影響，實際真正的影響在於精神層面，而精神層面應該是能理性控制的。 小結貫徹了之前我自己聽過的一句話： 感性的事情要用理性解，理性的事情要用感性解。 人生中有很多機會可以選擇，對於過去，重點是是從過去學習到什麼，或是從過往的經驗了解什麼。而不是一味的埋怨過去對自已造成傷害，因為過去的種種如果，所現在如何。人的所有的情緒、反應都是有目的性的。表達難過可能是為了得到安慰，憤怒是為了使人屈服、表達自己的強悍，情緒是能收放的。當然，人必定會有情緒，接受內在的情緒之後，不一定要對外表態出來，我真正需要學習的，是處理自己內心的情緒即可。 而生活的現狀，取決於自己的思考，換而言之，現在的生活狀況是自己決定的，就如：”如果我有空的話..我就…”事實上是在為自己找藉口，為自己尋找 “結果論” 的原因，安慰自己。做出改變是痛苦的，是需要時間的。離開自己的舒適圈，朝夢想前進，而不是為自己找更多的理由。 尋找解法，而不是責怪原因。 所有的煩惱都來自人際關係 為什麼討厭自己 因為過分害被別人討厭、在人際關係中受傷所致。目的變成了不要在人際關係中受傷害。 在人際關係中相當容易受到傷害，我們會遇到適合自己的人、排斥自己的人。為了避免受到傷害，我們為自己套上：孤僻、沈默等等性格，為自己的行爲找出合理的詮釋。合理的詮釋是為了讓自己的避免傷害，例如我會覺得：如果我每天念英文，我的人生就是彩色的了。其實心中是在迴避唸英文這個問題，我怕自己每天念也念不來，怕自己就算真的唸了，人生也並沒有改變。 阿德勒：要除去所有煩惱，唯有獨自一人存活在宇宙中。 簡單說，有人就會有問題拉。 所有的煩惱都是人際關係的煩惱 我們就算要覺得孤獨，也需要其他人的存在。所謂的 “內在的煩惱” 並不存在。 自卑感，是一種主觀的設定 自卑感 = 價值 + 較少 + 感覺。這些折磨我們的自卑感並不是 “客觀的事實”，而是 “主觀的解釋” 人與人之間存在比較，而我們從什麼角度跟別人比較，進而的產生 “自己不如人” 的感覺。事情有各個角度可以看，接受失敗、接受自己的缺點，而不是持續地以自己的缺點出發，認為自己的不完美，認為別人的條件比較好。因為這些主觀的觀點產生的自卑感，實為 “主觀的自卑感”，而非 “客觀的事實”，這種感覺通常是由自己判定自己的失敗，或是由別人投射在我們心中。總之，這個感覺仍然是人的感情建立，並非實際需要比較的東西。 當成藉口的自卑情結 當理想無法達成時，就會產生一種低劣無能的感覺。自卑情結，是指把自卑感當成某種藉口使用的狀態。 自卑情結即是為自己找藉口，為自己找的一個相對舒適的圈圈。因為自己無法達成，所以也就算了。同時解開了自己愧疚的心結，也解釋了自己為什麼不更努力的去完成目標。自卑感不見得是壞事，人們可以透過自卑感產生動力，覺得自己不好，需要更加努力達成。但自卑情結是為自己找到看似合理的出口，放棄改變來避免失敗。 自傲的人同時也感到自卑 藉由權威的力量來膨脹自我的人，終究還是活在別人的價值觀裡，過著別人的人生。如果有人自吹自擂，不過是因為他感到自卑罷了。 真的正的強者，不會急於表現自己有多好，急於證明自己比別人好。因為他們對自己有足夠的自信，知道自己的優點。這也是為什麼在爭論的場合中弱勢的人，自尊心往往較強，甚至透過擺爛的行為，來贏得一個自己無法贏得的爭吵，把 “自己” 看得相當的重要。 炫耀不幸 藉由自己的不幸，變得特別; 憑藉不幸，想要高人一等。把自己的不幸當成武器，想要支配對方。 人們也會利用自己的缺點、悲情的過往來提搞自己的身份地位。透過說明自己撐過了某種艱困的過去，來表示自己撐過去了。或是透過 “你們沒經歷過，永遠無法體會” 的論點，來顯示自己的成長過程與眾不同。謙虛大概才是一個有自信的人會擁有的。 題外話，營造更好交談的10條建議這邊讓我想到一個 TED 的演講：營造更好交談的10條建議。 其中提到，當人們在陳述自己的遭遇時，是在尋求慰藉或是某種認同，而當我們接受到這樣的訊號時，建議不要用自己的經驗或是經驗法則套用在別人身上，沒有任何一段經驗是相同的，那段悲傷的情緒屬於對方的，而自己的狀況是相對的較難獲得認同。而與他人溝通或是聆聽對方的遭遇時，是一個建立雙方感情鏈結的好機會，我們需要做的只有嘗試去體會對方的感受，並當個好的傾聽者。 中譯影片： 人生並不是與他人競賽 追求卓越，不需要跟任何人競爭，只需要跨步向前就行了。健全的自卑感並不是跟別人比較產生的，而是跟 “理想中的自己” 比較後的結果。 人跟人之間應該是完全平等的，沒有人絕對得比誰優秀，儘管我們之間慛載著差異。而我們會把看到感覺優秀的人的影子，投射到自己身上，產生一個如果自己是那樣的想法。間接的，我們產了現在的自己不如自己像象中好的樣子，產生了自卑感。 將別人的幸福認定成自己的挫敗。 要把大家當成夥伴，而不是都當成敵人。當我們把周遭的人都當成敵人，免不了跟別人比較。應該把大家當成夥伴，大家共同成長，那比較就會更少，也不會間接產生自卑感。 由權力鬥爭到復仇 想藉由勝利來證明自己的權利。當對方挑起權力鬥爭時，絕不要隨之起舞。 我們不需要透過鬥爭來解決問題，更不需要透過鬥爭來證明自己的能力。正確地解決問題，不要挑起無意義的爭端。 認錯不等於承認失敗 不是忍耐，忍耐代表你已經捲入了這場鬥爭。 當對方發起爭執時，代表這整件事情處理的過程有瑕疵。沒有必要證明自己是對的或是對方是錯的，解決問題最重要的。這回歸到第一章節所述的 “憤怒是種工具” 不要濫用憤怒的情緒來解決問題。 如何面對人生的任務 行動面的目標有 “獨立” 和 “能與社會和諧生活” 兩項。而支援這項行動的心裡面目標則是 “我是有能力的”，以及 “人人都是我的夥伴” 工作的任務 交友的任務 愛的任務 工作的任務工作的任務其實仍然與人際關係有關，如果我們在工作上疏失，會導致自己不想去上班，不願意面對工作。真正的原因並不是工作本身，而是我們在工作上會遭受的責難，被評價為能力不足等等的問題。因此，工作的任務其實仍然屬於人際關係的範疇。 交友的任務這屬於人生的中相當重要的一個課題。交友的任務即是普遍認知的人際關係，而這方面的難度會高於工作的任務。因為人跟人之間並沒有強制性的關聯，沒有 “一定要在一起” 的需求。朋友的重點不在多，而在於摯友，久久見面一次的朋友仍然可是摯友。 愛的任務 只要和這個人在一起，就可以自由盡情的展現自我 愛的過程中，最重的是面對問題，並嘗試解決，並不要安逸於現狀。 不要漠視人生的謊言 找出各種藉口來逃避人生任務的情形，就稱為人生的謊言 從擁有的心理學到使用的心理學 佛洛伊德-因果論 擁有的心理學，最後注定要走入決定論。 阿德勒-目的論 使用的心理學，決定權在於你自己。 小結人之間最大的心魔就是互相比較，透過比較得到優越感，或是自卑感。人生的課題主要為三大方向：工作、交友、愛情，在嘗試解決這三方面的問題時應該對自己更有自信，不是不斷的拿自己的條件跟人比較。而比較時又常常使用固守的觀點認為自己不夠好，在失敗的時候，我們嘗試找出原因，卻只找出藉口，藉由藉口來解釋自己的失敗，解釋自己為什麼無法成功，其實成功與否一直都操之在我們自己，遮蔽這一切的，即是人生的謊言。 滿滿的正能量啊。 割捨別人的課題不要為了滿足別人的期望而活 如果你不為自己而活，那誰要為你的人生而活? 賞罰教育帶來的瑕疵點：絕對的是非對錯，將這個世界上的事情一分為二。理想的狀況事情是：我們會只做對的事情，並不會做錯誤的事情。但這種教育造成的情況是，我們會選擇做會受到讚賞的事情，選擇做光彩的事情。而人們排斥做沒人注意到的事情。換而言之我們陷入的為他人而活的迴圈，有別人的目光的事情才有意義。…所有的問題仍然來自於人際關係。 課題分離 不涉入別人的課題。所有人際關係中的紛爭，差不多都是因為一個腳踩進人家的課題裡，或自己的課題遭到干涉所引起的。 仔細思考，因為這個決定而帶來的結果，最後會由誰來承受？ 只有自己可以改變自己。我們能把馬牽到水邊，卻不能強迫她喝水。 割捨別人的課題 越是關係親近的家人，越需要刻意機課題切割開來。 割捨別人的課題這個想法是雙面的，如果我們不要為了滿足別人的期望而活。那我們也不應該期望別人會為了我們而做什麼，這個觀點相當的清晰，每個人跟人之間是個體，我們能互相關心，能相愛，但不是互相控制對方，互相牽制對方。每個人有每個人自己的人生，有屬於它的成功，也有屬於自己的失敗，失敗也是屬於自己的體驗。 不要介入別人的課題，也不要讓別人介入你的。 尤其是家人，更因為晦長時間的相處而互相跨入對方的私領域。 斬斷難題 所謂的命運，並非依靠傳說來安排，而是揮舞自己的劍去展開。 — 亞歷山大 與常識對立的反命題。 如果你無法不在意他人的評價、無法不害怕被別人討厭。也不想付出可能得不到認同的代價。那就無法貫徹自己的生活方次。 小結順著書本的邏輯思考到這邊的話，邏輯是說得通的。我很難表達自己現在覺得這整件事情的想法，也與我自己過去的經驗有所牴觸。但不可否認的，我們不可能做到人見人愛，就連賈伯斯都被指責是個暴君、差勁、難相處的人。自己快樂和讓人快樂，相當難同時兼具，如果我們要完全百分之百應和他人，那就會失去自由的自己。 不過不要忘記一具相當重要的話： 說話讓人舒服的程度，決定你的高度。 這仍然是管理學中翁相當重要的一環。做人、做自己、跟管理，需要認真地分開思考。抓取中間的平衡點是相當重要的，過度的偏激自我或是他人，都是不健康的心理狀態。","raw":null,"content":null,"categories":[{"name":"好書筆記","slug":"好書筆記","permalink":"http://www.andrewchen.tw/categoriesl/好書筆記/"}],"tags":[{"name":"讀書心得","slug":"讀書心得","permalink":"http://www.andrewchen.tw/tags/讀書心得/"},{"name":"心理學","slug":"心理學","permalink":"http://www.andrewchen.tw/tags/心理學/"},{"name":"自我成長","slug":"自我成長","permalink":"http://www.andrewchen.tw/tags/自我成長/"},{"name":"重點筆記","slug":"重點筆記","permalink":"http://www.andrewchen.tw/tags/重點筆記/"}]},{"title":"天使與惡魔，炸雞排試吃評比 !!","slug":"20161228_FOODS_雞排","date":"2016-12-28T13:00:00.000Z","updated":"2017-02-05T14:03:05.000Z","comments":true,"path":"2016/12/28/20161228_FOODS_雞排/","link":"","permalink":"http://www.andrewchen.tw/2016/12/28/20161228_FOODS_雞排/","excerpt":"終於在這次的聖誕節達成了雞排小成就：吃到了台灣著名的三大雞排!!!\n天使雞排 - 瑞豐店 * 2惡魔雞排 - 寧夏店 + 士林店艋舺雞排 - 屏東店 + 鳳山店\n因為時間的關係，我前前後後在南北兩地吃到這三家雞排，總共嘗試了六次才有辦法寫出這篇文章。這三家共同的特色就是肉厚多汁，厚實的雞排肉完全不像在吃炸雞排，咬肉的感覺就像厚切牛排的概念一樣，肉厚的口感硬是跟傳統雞全不一樣。\n","text":"終於在這次的聖誕節達成了雞排小成就：吃到了台灣著名的三大雞排!!! 天使雞排 - 瑞豐店 * 2惡魔雞排 - 寧夏店 + 士林店艋舺雞排 - 屏東店 + 鳳山店 因為時間的關係，我前前後後在南北兩地吃到這三家雞排，總共嘗試了六次才有辦法寫出這篇文章。這三家共同的特色就是肉厚多汁，厚實的雞排肉完全不像在吃炸雞排，咬肉的感覺就像厚切牛排的概念一樣，肉厚的口感硬是跟傳統雞全不一樣。 雞排口味口味最重肉汁最多的是惡魔雞排，味道的個性鮮明且強烈，而天使雞排的肉汁也不妨多讓，味道適中並帶有肉的甜味 讓我允指回味啊！艋舺雞排的口味則相當經典，一樣炸的恰到好處，艋舺雞排的椒鹽粉味道相當明顯，但絕不會太嗆或是讓人不舒服。而除了天使雞排之外，另外兩家在北部的夜市已經相當容易尋找到他們的蹤跡。 雞排肉質雞排的大小其實有蠻大的差距的，儘管就差那兩三口雞排，慾望的滿足感就是差非常多，但我個人認為雞排大小跟地段有直接關係，所以並沒有直接拿來當作比較的參考，我在高雄吃到的雞排就真的有台北的 1.4 倍大的感覺，就是有差那麼多。但因為地價相差甚遠，所以我覺得不能單方片的稱讚某雞排店的雞排好吃。但我仍然私心推薦 天使雞排 - 瑞豐店。 當然雞排這種東西吃下去其實也是看運氣，說不定當天那個員工心情不好，多炸了20秒鐘，那口感就差非常多了，品質控管在連鎖的店面上，面對不同的工讀生的操作，年免會有所差距，儘管都可能有時間管制，但天氣氣問的不同，員工反應速度不同等等細節因素，都大大的影響雞排的口感，或是單純就是那隻雞心情不好而已，吃下去雞肉就是不嫩，憂鬱太久的感覺。 最重要的事我認為雞排在拿到之後，要在最快的時間內，以不燙到嘴的方式入口！雞排跟牛排一樣，高溫加熱起鍋後 “靜置” 也屬於烹飪的一環。以牛排來說，煎鍋起來後靜置 5-6 分鐘是一種烹飪方式，而雞排也是相同的狀況。簡單說，你拿到手之後，雞排也是不斷的在加熱的狀況！那要是晚五分鐘之，雞排就是處於相對過熟的情框了，因此強烈推薦，在不燙到舌頭的情況下，儘早享用你的雞排吧！ 外傳另外惡魔狂暴雞排。是這趟旅程中的小插曲，我吃到的時候他才剛剛開幕不到一個禮拜，或許是意外，雞排炸的略焦，後半段就顯得相當乾硬，可能營業穩定下來之後就會變得非常好吃。","raw":null,"content":null,"categories":[{"name":"吃吃喝喝","slug":"吃吃喝喝","permalink":"http://www.andrewchen.tw/categoriesl/吃吃喝喝/"}],"tags":[{"name":"吃吃喝喝","slug":"吃吃喝喝","permalink":"http://www.andrewchen.tw/tags/吃吃喝喝/"},{"name":"美食介紹","slug":"美食介紹","permalink":"http://www.andrewchen.tw/tags/美食介紹/"},{"name":"炸物","slug":"炸物","permalink":"http://www.andrewchen.tw/tags/炸物/"},{"name":"夜市","slug":"夜市","permalink":"http://www.andrewchen.tw/tags/夜市/"}]},{"title":"JavaScript 綁定函數方式比較 - .Bind() .Apply() .Call()","slug":"20150818_JS_buildCallApply","date":"2015-08-18T14:30:15.000Z","updated":"2017-02-05T15:00:23.000Z","comments":true,"path":"2015/08/18/20150818_JS_buildCallApply/","link":"","permalink":"http://www.andrewchen.tw/2015/08/18/20150818_JS_buildCallApply/","excerpt":"\n學習筆記，JavaScript 在綁定 Function 時有三種方式，分別為 .bind(),.call(), .apply(), 而這三種又有些許的差異：","text":"學習筆記，JavaScript 在綁定 Function 時有三種方式，分別為 .bind(),.call(), .apply(), 而這三種又有些許的差異： function .bind().bind() 不會立即執行 function，並設定 this 範疇與傳入參數。傳入第一個參數是 scope，指定 function 內 this 的範疇。 1func.bind( null, 1 ,2 ,3 ) ; // 不會立即執行 function .call().call() 呼叫 function，並設定 this 範疇與傳入參數。傳入第一個參數是 scope，指定 function 內 this 的範疇。 1func.call( null, 1 ,2 ,3 ) ; // 逐一傳入參數 (立即執行) function .apply().apply() 呼叫 function，並設定 this 範疇與傳入參數。傳入第一個參數是 scope，指定 function 內 this 的範疇。而參數是統一用一個陣列包起來，apply 會自行拆開傳入。 1func.apply( null, [ 1, 2, 3 ] ); // 參數統一用 array 傳入 (立即執行)","raw":null,"content":null,"categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://www.andrewchen.tw/categoriesl/Node-js/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.andrewchen.tw/tags/JavaScript/"},{"name":"Node.js","slug":"Node-js","permalink":"http://www.andrewchen.tw/tags/Node-js/"},{"name":"學習筆記","slug":"學習筆記","permalink":"http://www.andrewchen.tw/tags/學習筆記/"},{"name":"教學","slug":"教學","permalink":"http://www.andrewchen.tw/tags/教學/"}]},{"title":"Redis - Node.js 記憶體快取","slug":"20150816_JS_redis","date":"2015-08-16T03:01:07.000Z","updated":"2017-02-04T06:59:56.000Z","comments":true,"path":"2015/08/16/20150816_JS_redis/","link":"","permalink":"http://www.andrewchen.tw/2015/08/16/20150816_JS_redis/","excerpt":"\n\nRedis\nRedis - 官方文件\nRedis - npm\nRedis - GUI\n\nRedis 是以 key-value 的形式在伺服器的記憶體中儲存資訊的方式，為伺服器命名做快取(cache)。有別於其他 noSQL 或是 RDB，key-value 即是使用一個 key 的值對應到一筆資料。而 Redis 的特色就是將這筆資料，寫在記憶體裡面。\n大概有幾種狀況會將資料寫入到快取中：\n\n在一定時間內會被大量請求的資料，如：新聞的 Top 10。\n某些伺服器會頻繁使用的資料，或全域變數。如：\n測試用的資料，短時間內要使用的假資料。\n也能當成 Session 使用。(相當不健康的觀念)\n\nRedis 本身會瓜分伺服器的記憶體來使用，Node.js 連線所使用的記憶體相對於 PHP/Apache 較少，除非能非常準確地掌握 Session 的數量，否則不建議 Redit 當成 Session 使用，同樣的意思不應該將 Redis 當成資料庫來只用。如果對 Redis 有相當大的需求，應該特地架設 Redis 的伺服器，避免兩套系統互相搶奪記憶體資源。\n安裝","text":"Redis Redis - 官方文件 Redis - npm Redis - GUI Redis 是以 key-value 的形式在伺服器的記憶體中儲存資訊的方式，為伺服器命名做快取(cache)。有別於其他 noSQL 或是 RDB，key-value 即是使用一個 key 的值對應到一筆資料。而 Redis 的特色就是將這筆資料，寫在記憶體裡面。 大概有幾種狀況會將資料寫入到快取中： 在一定時間內會被大量請求的資料，如：新聞的 Top 10。 某些伺服器會頻繁使用的資料，或全域變數。如： 測試用的資料，短時間內要使用的假資料。 也能當成 Session 使用。(相當不健康的觀念) Redis 本身會瓜分伺服器的記憶體來使用，Node.js 連線所使用的記憶體相對於 PHP/Apache 較少，除非能非常準確地掌握 Session 的數量，否則不建議 Redit 當成 Session 使用，同樣的意思不應該將 Redis 當成資料庫來只用。如果對 Redis 有相當大的需求，應該特地架設 Redis 的伺服器，避免兩套系統互相搶奪記憶體資源。 安裝 先從官方網站下載 Redis，解開壓縮檔之後，在資料夾下執行以下指令 1$ make 輸入指令後，Redis 會自行安裝，需要一段時間 1$ make test Redis 會自行進行測試，測時完成後即可啟動，啟動並不需要在指定的資料夾下，屬於全域的 1$ redis-server 接著在 Redis - GUI 的介面中進行連線就可以檢視現在 Redis 內的資料。 使用在 Node.js 引用 Redis 的套件並且連線 1var redis = require(\"redis\").createClient('6379', '127.0.0.1'); //port, IP redis.set 寫入值 123redis.set( key, value, function( err, reply )&#123; console.log( reply.toString() ); // 新增成功會回傳 ok&#125;); redis.get 取得值 123redis.get( key, function( err, reply )&#123; console.log( reply.toString() ); // 新增會回傳 value&#125;); cache 資料的存活時間 1redis.expire( key, 60); redis 錯誤 callback function 1redis.on( \"connect\", callback ); redis 錯誤 callback function 1redis.on( \"error\", callback ); redis 驗證如果在 redis.conf 中有設定需要驗證的話，須在在此填入驗證碼，類似密碼的意思。 1redis.auth(\"AndrewChen\"); 結語Redis 基本上安裝完成就成功一半了，簡易的 set/get 即可使用，Redis 的操作本身不難，但謹慎的使用，小心記憶體的使用量，避免超額使用或是佔據了伺服器的空間。另外定期簡單的透過GUI介面檢查 Redis 的狀況也是相當不錯的選擇。","raw":null,"content":null,"categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://www.andrewchen.tw/categoriesl/Node-js/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.andrewchen.tw/tags/JavaScript/"},{"name":"Node.js","slug":"Node-js","permalink":"http://www.andrewchen.tw/tags/Node-js/"},{"name":"學習筆記","slug":"學習筆記","permalink":"http://www.andrewchen.tw/tags/學習筆記/"},{"name":"教學","slug":"教學","permalink":"http://www.andrewchen.tw/tags/教學/"}]},{"title":"淺談前端框架未來，Angular, React, 還是...？","slug":"20150802_JS_AngularReactOrOther","date":"2015-08-02T01:13:44.000Z","updated":"2017-02-04T06:59:56.000Z","comments":true,"path":"2015/08/02/20150802_JS_AngularReactOrOther/","link":"","permalink":"http://www.andrewchen.tw/2015/08/02/20150802_JS_AngularReactOrOther/","excerpt":"\n本篇文上是本人Andrew Chen為JSDC 2015撰寫感謝Caeser Chi給予指導\n\n\n前端入坑深似海，一入宅門出不來。這肯定是許多前端工程師可以體認到的共同感觸，前端真可以說是一個坑，維繫大家能夠持續學習的動機，除了熱情，應該就還是熱情吧。\n淺談前端框架","text":"本篇文上是本人Andrew Chen為JSDC 2015撰寫感謝Caeser Chi給予指導 前端入坑深似海，一入宅門出不來。這肯定是許多前端工程師可以體認到的共同感觸，前端真可以說是一個坑，維繫大家能夠持續學習的動機，除了熱情，應該就還是熱情吧。 淺談前端框架 隨著前端應用變化越來越多，因此許多前端框架不斷的推陳出新，從早期大家所熟知的 batman.js, backbone.js, emberjs 在中期也開始出現了許多不同框架，其中到了 Google 踏進 Angular.js 之後前端框架正式熱門起來，也掀起另外一波大戰。 隨著世代的轉移，JavaScript 漸漸語法轉移到 ES6，語法不同，開始有了不同應用，也因此又出現了令人亮眼的新秀：Aurelia。 由於前端框架的世界更新相當迅速，不斷有新的Framwork出現，各家開發者對自己熟悉的框架各執其詞，其實相當難定義何者叫好。 前端框架未來？React, Angular ?React 和 Angular 目前為前端兩大流行的框架，兩者的風格迥異。 React 主打 Single Source of True 和 Flux 的單項資料流，重新以元件的思維角度去設計 WebApp，最後又採用相同思維可以進行開發 iOS, Android native 程式框架 - React Native 讓大家眼睛為之一亮。 而在Angular目前的情況較為不明朗，相當多的開發者正在使用能穩定運作的 1.x 版本，但是 Angular 2.x 的版本卻面臨了相當大的改版，而且並沒有支援 1.x 的部分。 Angular 最大亮點在雙向資料綁定，簡潔的資料綁定和監控配上快節奏的開發技巧時，產生令人驚豔的開發速度。 React 跟 Angular 整體的核心思維是相當不同的，React 特色在於簡化的開發邏輯與資料流，單純的單項資料流讓開發流程和除錯都容易了許多，React 的結構設計也讓抽取元件變得直觀與單純，React 傾向於將開發簡化，在設計好架構與資料結構後就減少犯錯的機會。 但從另一個角度來說，React針對單一的操作，要撰寫的程式碼多出了許多，整個架構也變得龐大。而 Angular 則相反，Angular 在處理資料時相當快速且方便，雙向的資料綁定讓開者並不需要思考太多元件對應的關係，但也因此最終可能會讓整個專案陷入混亂，Angular 在抽取元件時比 React 需要更多的開發技巧，對整體團隊的開發素質要求也相對的更高。 新的選擇 - AureliaAurelia 或許可以說介於 React 和 Angular 兩者之間，Aurelia 目前為相當新秀的開發框架，他本身與 Angular 的資料綁定方式相當類似，不僅僅對 Angular 的開發者相當容易上手，安插在 HTML5 中的屬性也更加語意化。 Aurelia 的核心圍繞在模板上，因此他似乎同時擁有了 React 類似元件的觀念，又同時有 Angular 綁定資料的手法，算是相當多元，除此之外 Aurelia 對 ES6, ES7 擁有更高的支援度。 當然目前 Aurelia 還在持續開發中，雖然版本尚未穩定，但是已經是個值得注目的前端框架，可以開始試著去執行，了解 Aurelia ，或許在現今 Single Page App 爆炸性成長的階段，Aurelia 能在未來佔有一席之地。 也許未來 JavaScript 真的能夠做到前後端統一程式碼進行開發，也有可能踏入 hardware 開發領域，這都需要時間來證明，當然也需要各位的投入，就讓我們持續關注這個世代的變化吧。","raw":null,"content":null,"categories":[{"name":"社群活動","slug":"社群活動","permalink":"http://www.andrewchen.tw/categoriesl/社群活動/"}],"tags":[{"name":"社群活動","slug":"社群活動","permalink":"http://www.andrewchen.tw/tags/社群活動/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.andrewchen.tw/tags/JavaScript/"},{"name":"Angular.js","slug":"Angular-js","permalink":"http://www.andrewchen.tw/tags/Angular-js/"},{"name":"React.js","slug":"React-js","permalink":"http://www.andrewchen.tw/tags/React-js/"}]},{"title":"JS Devil Day 參與心得","slug":"20150802_JS_JSDevilDay","date":"2015-08-02T01:05:42.000Z","updated":"2017-02-04T06:59:56.000Z","comments":true,"path":"2015/08/02/20150802_JS_JSDevilDay/","link":"","permalink":"http://www.andrewchen.tw/2015/08/02/20150802_JS_JSDevilDay/","excerpt":"\n本篇文上是我為JSDC 2015撰寫感謝Caeser Chi給予指導\n\n\nJS Devil Day 是本次 JSDC 2015 所舉辦第一場對外 Meetup，也是首次透過北中南三方連線方式進行，本次以參與者角色，記錄此次活動。\nJS Devil Day 當天主要有三個主題：Angular.js、ECMAScript6、講者對談與交流。\n專家分享","text":"本篇文上是我為JSDC 2015撰寫感謝Caeser Chi給予指導 JS Devil Day 是本次 JSDC 2015 所舉辦第一場對外 Meetup，也是首次透過北中南三方連線方式進行，本次以參與者角色，記錄此次活動。 JS Devil Day 當天主要有三個主題：Angular.js、ECMAScript6、講者對談與交流。 專家分享 儘管對 Angular.js相當不熟悉，透過講者阿梨的分享讓我對Angular.js的概念有些許的了解，事後座談時講者也推薦初學者直接以Angular.js 2.0作為起手版本。 接著是 Jeremy 對 ES6、webpack 提出了幾個重點，在 ES6 中可以明顯地感受到 JavaScript 已經開始嘗試解決 ES5 一些為人詬病的問題，包括區域變數、類別、模組化等等，同時 ES6 內建了 promise 和 generator ，同時在 ES6 解決了過複雜的 callback function和流程控制，另外 ES6 採用許多 coffeeScript 語法讓結構更為簡潔。 個人認為 ES6 讓 Javascript 成為了更完整的開發語言，也讓 Javascript 減少了許多舊有的小問題，也不必仰賴開發者用奇技淫巧去嘗試解決問題。 現今主流瀏覽器諸如：Chrome、Safari、Firefox 等等，已經逐漸開始支援 ES6，但尚未完全支援。在瀏覽器完全支援 ES6 之前，我們可以透過 babel 在程式執行之前將 ES6 的程式碼轉譯成 ES5，讓瀏覽器完全整的支援 ES6 程式碼。 另外 Jeremy 提到 webpack 和 JSCS ，協助團隊開發更為順暢，開發工具和技巧相當的重要。順暢的開發過程除了提高效率之外，也保護了開發者健康的肝。","raw":null,"content":null,"categories":[{"name":"社群活動","slug":"社群活動","permalink":"http://www.andrewchen.tw/categoriesl/社群活動/"}],"tags":[{"name":"社群活動","slug":"社群活動","permalink":"http://www.andrewchen.tw/tags/社群活動/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.andrewchen.tw/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://www.andrewchen.tw/tags/ES6/"}]},{"title":"Android App - TTtimer","slug":"20150719_APP_TTtimerForOIT","date":"2015-07-19T07:46:12.000Z","updated":"2017-02-06T02:45:58.000Z","comments":true,"path":"2015/07/19/20150719_APP_TTtimerForOIT/","link":"","permalink":"http://www.andrewchen.tw/2015/07/19/20150719_APP_TTtimerForOIT/","excerpt":"\n\n名稱：TTtimer類型：Andriod App / Java, 未上架時間：2015/1 (大三上學期)用途：期末作業\n簡介Android APP - TTtime 是我在大三上學期修 Amy 老師 Java 課程的期末作品。這隻 APP 大概是我個人最喜歡期末作品之一，包括結構和設計是我個人最喜歡的，當時我有不少的時間與不曉得發揮空間。TTtimer 的設計概念出自於 10,000 小時，意指在某一個專業區域中努力 10,000 小時才能成為該專業領域中的佼佼者(這個理念最後被我個人推翻了)。而 TTtimer 即是此類型的計時器，選擇目標的專業項目後，持續累計時間來達成最初設定的目標，並透過累計時間的百分比、累計總數來給予獎勵或是頭銜的稱號。","text":"名稱：TTtimer類型：Andriod App / Java, 未上架時間：2015/1 (大三上學期)用途：期末作業 簡介Android APP - TTtime 是我在大三上學期修 Amy 老師 Java 課程的期末作品。這隻 APP 大概是我個人最喜歡期末作品之一，包括結構和設計是我個人最喜歡的，當時我有不少的時間與不曉得發揮空間。TTtimer 的設計概念出自於 10,000 小時，意指在某一個專業區域中努力 10,000 小時才能成為該專業領域中的佼佼者(這個理念最後被我個人推翻了)。而 TTtimer 即是此類型的計時器，選擇目標的專業項目後，持續累計時間來達成最初設定的目標，並透過累計時間的百分比、累計總數來給予獎勵或是頭銜的稱號。 以下為 APP 使用到的技術重點，有需要的同學可以在裡面尋找相關自訓。有機會的話相我想把這個 APP 上架，最為一次學習經驗。 Source Code 分享Source Code 放置在 Google Drive 上面，分享給需要範例的同學們。 [Android APP] TTtimer-for-AS-v1.0 技術簡介物件導向設計APP 中，每個 任務 都是以一個物件包裝，包括包裝這個 任務 本身的資訊、進度、累計時間等等。而累計時間輸出時，可是轉換成百分比的函數，也是包裝在 PlaneToTime 的類別裡面。物件導向設計可參考的是以下主要幾個類別： MyTimer MicroTimer Plan PlanToTime MyTimer 和 MicroTimer 類別主要功能就是計時器，在每個計畫中都會使用到一個計時計，並且有簡化一些時間I/O的機制，主要是根據我當時自己的需求所包裝的。而 Plan 和 PlanToTime 包裝了 計畫 和 有時目標間的計畫，事實上在最後 APP 實作的時候，並沒有 無目標時間的計畫，也就是說類別 Plan 只是單純被 PlanToTime 繼承，作用類似於一個基底類別，其實並沒有實作的功能，這屬於我個人設計錯誤，因為一開始有構想 無目標時間的計畫。因此在後面會發現，底層設計的取得獎勵的方式，略有不同，僅僅因為當初規劃時我的想法岔開了。 包裝這四個類別，在我專案開發中後期其為吃香，傳送資料時不太需要考慮資料格式。簡單思考：傳遞一個物件比起傳遞四個不同型別的參數，何者容易？當然是包裝好的一個物件，一次傳遞來得輕鬆方便。另外，包裝物件可以在多人開發時，資料格式的缺漏檢查，或是避免掉不必要的資料傳遞誤會與錯誤。 計時器計時器只有兩個原則，每秒(或是其他時間)的觸發事件，然後再撰寫自己紀錄的方式。計時器 Andriod 有預設事件，少量的計時器每秒的 tick 相當精準，不要一次開一大堆就好。也別用計時器去處理監聽事件，基本上 Andriod 大部份的物件都有自己的監聽事件，不需要自行去撰寫計時器去檢查。在 TTtimer 中牽涉到的類別如下： MainActivity TiemRiver SysSet 之前被問過幾次 Android App 的計時計怎麼處理，計時器的影子可以在 Mainctivity 中找到，當初設計是在 APP 一啟動時，背後就有一個碼表在計時，而計時計的參數被我抽取到 TimeRiver 和 SysSet 的類別中，其實 TimeRiver 的類別中的設定參數直接抽取到 SysSet，目前的方式是多個任務會共用同一個碼錶，避免每開一起一個新的任務就啟用新的碼表消耗效能。 SQLite如果 SQLite 無法正常啟用，記得注意 Android 本身的版本是否要更新，之前個人在測試時就發生過無法啟動的狀況。情急之下用 txt 自己刻了一套類似功能的 documentation SQL。現在想想挺好笑的，結果期中考過後我發現手機系統要更新，更新好就能使用 SQLite 了，只好默默的砍掉整個手刻的 SQL。 關於 SQLite 我使用在兩個部分：儲存計畫、系統參數。 PlanSQL SystemSettingSQL 兩者都相當直接的包裝了基本的 Sqlite 的 CRUD (新增/修改/刪除/查詢)，基本上 SQLite 在類別設計完成後，撰寫一次，確認每次 APP 開啟後跟 SQLite 的 IO 正常後，我就再也沒有修改過內部的程式碼。所以理想的話只要努力一次就好，並不需要開發途中不斷地維護那段程式碼。 SQLite 需要注意的重點是測試資料的問題。在開發時頻繁的測試過程中，程式碼除錯時會頻繁地影響到資料庫資料的變動，導致錯誤解決了卻仍然出現問題。主因是資料錯誤，產生 Garbage in garbage out 的結果。建議在開發期間每次 APP 啟動時就初始化一次資料，清空資料庫並且寫入測試用的資料，最終在 APP 發佈時只要將初始化資料的程式碼註解掉即可。 另外需要注意的事情是，程式碼要有解析空資料的能力。意思是多半在測試時，資料庫內已經有測試資料，往往忽略了有可能無資料的情況，反而在拿掉測試資料後才發現 APP 啟動的一瞬間就會因為資料讀取失敗而崩潰。 動態新增控制項這大概是我被詢問最頻繁的項目了。處理這部分的是以下兩個類別： AddBtn ViewList 動態新增控制項的步驟就是：宣告 &gt; 設定 &gt; 掛載。除非是要做 APP 遊戲，不然 Andriod 內建的 ListView 應該能解決大部份的問題，當初我在這塊也是修改了好幾個版本，一開始因為好玩也是手刻 ListView，再建立 Scroll view。不過內建的 ListView 和手刻的邏輯基本上是相同的，先將想要動態新增的物件製作成一份 ListItem 再由 ListView 去重複就對了。 Android Lifecycle 生命週期 撰寫 Andriod APP 最重要的就是生命週期。簡而言之，生命週期就是我們在手機各種操作時，切換到 APP 畫面時對程式運行的影響，例如執行中的 APP 在按下 Home 鍵後會進入到 onPause() 的狀態，不同的狀態不可能讓 APP 一直處於運轉中，因此 APP 作業流程設計會圍繞著 Android Lifecycle 在運轉，也是設計的核心。但記得在 Lifecycle 中，我個人認為最不能仰賴 onDestroy()，仰賴關閉 APP 時才去執行，無法預測 APP 是在什麼情況下被關閉的，可能執行緒被中斷、手機沒電等等狀況。重要的資料同步，盡可能不要放在 onDestroy 的部分。 雙語系TTtiemr 支援雙語系，支援 zh-Tw 和 en 語系，根據手機設定的國籍去做辨識。在手機中抓取字串的方式都需要使用 android:text=&quot;@string/show&quot; 抓取，之前有聽過反映這樣相當不友善(且不容易辨識)，不過在後期翻譯時相當有趣，單純翻譯 string 的設定檔就可完成。如果從一開始就有遵守紀律，將對應的字串寫在設定檔內，在專案末期好好享受輕鬆翻譯 APP 語言的成果吧! 多解析度圖片在多解析度圖片這部分，我個人處理得相當糟糕，當初在 PC 上測試時雨手機上測試時發現差距極大，因此我大量的改用百分比去做設計。解決問題後我就沒有再去對多種解析度的螢幕下去做設計。 Animation 動畫效果在 WorkingActivity 可以大量使用到動畫，Android 的動畫使用大致上是：宣告 &gt; 設定參數 &gt; 啟動。需要注意的是 Animation 的狀態，需要將正確的資料流操作掛載載正確的 Animation 事件上面，避免掉發生動畫時件不同步或是執行順序有問題的情況。Animation 玩起來相當有趣且有成就看，相當推薦大家玩玩。 檔案簡介path: src/main/java/tw/com/oit/andrew/ myclass/MyTimer計時計類別，主要是依照需求包裝了計時器去配合之後的 Andriod time tick。 myclass/MicroTimer繼承了 MyTimer，加入了秒數的欄位，最後這兩個計時器使用的類別會被包在 Plan 和 PlanToTime 中使用。 myclass/Plan包裝了每個計畫項目資訊，屬於 PlanToTime 的父類別，絕大多數重要的功能也是在這裡。 myclass/PlanToTime在計畫項目資訊增加了目標時間，之後的 Activity 中使用的都是這個 class。兩個 Plan 相關的 class 是整個 APP 中 CP 最高的，但也是被反覆修改最多次的，良好的物件設計讓我在整個 APP 開發的後期有了相當不錯的資料控管，我能清楚的掌握資料的傳輸。 system/Notify包裝了所有使用的通知視窗(Dialog)，從外部可以輕鬆的呼叫視窗，僅需要傳入必要的字串需求即可。 system/SysSet系統設定檔。應該與 TimeRiver 合併。 system/TimeRiver系統設定檔。主要是針對計時器的部分，這部分的設定會被記錄在 SQLite 中，確保每次重新啟動時都會是使用者設定的值。 tenthousandtimer/MainActivity主要介面的操作，拿讀取進來的資料動態新增控制項，並且宣告、啟動計時器。 tenthousandtimer/MetalsActivity單純檢視獎牌與頭銜等訊息，可以視為單純的 ListView Demo。 tenthousandtimer/MyMenu針對 Menu 包裝操作，命名並沒有使用 Activity 是用來區別這個是一包裝操作的 class 並非直接掛載在頁面上的。 tenthousandtimer/SettingActivity設定頁面，設邊使用了固定的控制項，然後將設定的資訊寫在上面的 system 類別中，並儲存在 SQLite。 tenthousandtimer/WelcomActivity歡迎界面，在裡面載入 SQLite 的資料，其實這沒有必要，在 MainActivity 中載入即可，單純為了好看。 tenthousandtimer/WorkingActivity在 WorkingActivity 中大量的使用了 Animation，如果在事後才掛上 Animation 容易導致先前設計的資料流多少出現錯誤。仔細研究 Animation 與主程式非同步的關係，就能解決這個問題，並不至於需要 APP 大改寫。 tttsql/PlanSQL &amp; tttsql/SystemSettingSQL包裝了 SQLite 的操作，包含了整批資料的 CRUD，這邊對於 SQLite 的操作相當基本，依據我的印象，資料更新的操作是直接用覆蓋的。基本上也不會出錯，在小量的資料下，效能也沒有問題。PlanSQL 和 SystemSettingSQL 分別包裝了不同的資料而已，基本上觀念完全相同。皆是在載入畫面時會讀取資料。記得注意 Andriod 的版本問題，另外 SQLite 自己也有版本問題，請確保測試資料正確，紀律性的測試可以省去很多麻煩。 viewlist/AddBtn &amp; viewlist/ViewList這兩個類別都包裝了動態新增物件的功能，新增動態物件其實相當麻煩，要考慮物件本身、事件、資料，因此我會盡可能將資訊都封裝在類別內，屆時只需要傳入必要參數即可，如任務有用物件包裝好，那理所當然直接傳遞物件即可。 結語TTtiemr 亦有存在問題，目前我個人也不知道該如何解決。TTtimer 似乎在重複開啟太多任務後，會導致手機效能降低，吃掉太多CPU或記憶體。但此部分已經超過我對 Andriod APP 的認知，需要更專業的技術。但 TTtimer 所使用的技術，除了連線的需求之外，能滿足絕大部份的 APP 開發。這次的 Andriod APP - TTtimer 分享希望能幫助到大家，如果有任何問題也可以 Facebook 敲我或是寄信給我詢問細節，但請標明是誰詢問與相關的問題資訊。","raw":null,"content":null,"categories":[{"name":"學生時期","slug":"學生時期","permalink":"http://www.andrewchen.tw/categoriesl/學生時期/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.andrewchen.tw/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://www.andrewchen.tw/tags/Java/"},{"name":"學生時期作品","slug":"學生時期作品","permalink":"http://www.andrewchen.tw/tags/學生時期作品/"}]}]}