{"meta":{"version":1,"warehouse":"1.0.2"},"models":{"Asset":[{"_id":"themes/hueman/source/scrollLoading/style.css","path":"scrollLoading/style.css","modified":1},{"_id":"themes/hueman/source/scrollLoading/main.js","path":"scrollLoading/main.js","modified":1},{"_id":"themes/hueman/source/scrollLoading/jquery.scrollLoading.js","path":"scrollLoading/jquery.scrollLoading.js","modified":1},{"_id":"themes/hueman/source/scrollLoading/images/preloader@2x.gif","path":"scrollLoading/images/preloader@2x.gif","modified":1},{"_id":"themes/hueman/source/scrollLoading/images/preloader.gif","path":"scrollLoading/images/preloader.gif","modified":1},{"_id":"themes/hueman/source/js/script.js","path":"js/script.js","modified":1},{"_id":"themes/hueman/source/js/html-patch.js","path":"js/html-patch.js","modified":1},{"_id":"themes/hueman/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1},{"_id":"themes/hueman/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1},{"_id":"themes/hueman/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1},{"_id":"themes/hueman/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1},{"_id":"themes/hueman/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1},{"_id":"themes/hueman/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1},{"_id":"themes/hueman/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1},{"_id":"themes/hueman/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1},{"_id":"themes/hueman/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1},{"_id":"themes/hueman/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1},{"_id":"themes/hueman/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1},{"_id":"themes/hueman/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1},{"_id":"themes/hueman/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1},{"_id":"themes/hueman/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1},{"_id":"themes/hueman/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1},{"_id":"themes/hueman/source/css/style.styl","path":"css/style.styl","modified":1},{"_id":"themes/hueman/source/css/images/thumb-default.png","path":"css/images/thumb-default.png","modified":1},{"_id":"themes/hueman/source/css/images/thumb-default-small.png","path":"css/images/thumb-default-small.png","modified":1},{"_id":"themes/hueman/source/css/images/s-left.png","path":"css/images/s-left.png","modified":1},{"_id":"themes/hueman/source/css/images/opacity-10.png","path":"css/images/opacity-10.png","modified":1},{"_id":"themes/hueman/source/css/images/logo-header.png","path":"css/images/logo-header.png","modified":1},{"_id":"themes/hueman/source/css/images/logo-header.bk.png","path":"css/images/logo-header.bk.png","modified":1},{"_id":"themes/hueman/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1},{"_id":"themes/hueman/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1},{"_id":"themes/hueman/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1},{"_id":"themes/hueman/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1},{"_id":"themes/hueman/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1},{"_id":"source/img/nodeFormZero_2/node_4_4.png","path":"img/nodeFormZero_2/node_4_4.png","modified":1},{"_id":"source/img/nodeFormZero_2/node_4_3.png","path":"img/nodeFormZero_2/node_4_3.png","modified":1},{"_id":"source/img/nodeFormZero_2/node_4_2.png","path":"img/nodeFormZero_2/node_4_2.png","modified":1},{"_id":"source/img/nodeFormZero_2/node_4_1.png","path":"img/nodeFormZero_2/node_4_1.png","modified":1},{"_id":"source/img/nodeFormZero_2/node_3_1.png","path":"img/nodeFormZero_2/node_3_1.png","modified":1},{"_id":"source/img/nodeFormZero_2/node_2_7.png","path":"img/nodeFormZero_2/node_2_7.png","modified":1},{"_id":"source/img/nodeFormZero_2/node_2_6.png","path":"img/nodeFormZero_2/node_2_6.png","modified":1},{"_id":"source/img/nodeFormZero_2/node_2_5.png","path":"img/nodeFormZero_2/node_2_5.png","modified":1},{"_id":"source/img/nodeFormZero_2/node_2_4.png","path":"img/nodeFormZero_2/node_2_4.png","modified":1},{"_id":"source/img/nodeFormZero_2/node_2_3.png","path":"img/nodeFormZero_2/node_2_3.png","modified":1},{"_id":"source/img/nodeFormZero_2/node_2_2.png","path":"img/nodeFormZero_2/node_2_2.png","modified":1},{"_id":"source/img/nodeFormZero_2/node_2_1.png","path":"img/nodeFormZero_2/node_2_1.png","modified":1},{"_id":"source/img/me.jpg","path":"img/me.jpg","modified":1},{"_id":"source/img/TTtimer/working_finish.png","path":"img/TTtimer/working_finish.png","modified":1},{"_id":"source/img/TTtimer/ic_launcher.png","path":"img/TTtimer/ic_launcher.png","modified":1},{"_id":"source/img/TTtimer/demo2.png","path":"img/TTtimer/demo2.png","modified":1},{"_id":"source/img/TTtimer/demo.png","path":"img/TTtimer/demo.png","modified":1}],"Cache":[{"_id":"source/_posts/001_JSDevilDay.md","shasum":"9b6967b2b116a3c968026dc4963408dc2c1f4411","modified":1438602171000},{"_id":"source/_posts/002_AngularReactOrOther.md","shasum":"cd1eff450b2d957960e309e3dd1a17a9027e4ab1","modified":1438601372000},{"_id":"source/_posts/003_TTtimerForOIT.md","shasum":"fc9a74dee18db6b524214ca047244c2c138089d7","modified":1439974171000},{"_id":"source/_posts/JavaScript_01.md","shasum":"24f71a09a8d922209ba53dc5aef205cced1b51a1","modified":1441957774000},{"_id":"source/_posts/Node_Redis記憶體快取.md","shasum":"5c86119c7b04164fbdd9fc6f724ab2c7f928948f","modified":1439694770000},{"_id":"source/_posts/Node從零開始_01.md","shasum":"29ed1a0506cd697b4bac07791b8bc9645e62f39c","modified":1439895579000},{"_id":"source/_posts/Node從零開始_02.md","shasum":"85e9c83cac67c891cdd24e3285cae1ca0f157941","modified":1439517682000},{"_id":"source/_posts/Node從零開始_03.md","shasum":"26a902304da386b80351a437467b6922b84f6632","modified":1439654116000},{"_id":"source/_posts/Node從零開始_04.md","shasum":"c2f366a55f9023ee5f56de1e963307ebde5b5c8e","modified":1443175852000},{"_id":"source/_posts/Node從零開始_05.md","shasum":"039e33f230e3eaf3c6320b1f68317d60053c5ff7","modified":1440465970000},{"_id":"source/_posts/_hello-world.md","shasum":"170bcae0322be89b6a544676d221edad75d1d13e","modified":1438821366000},{"_id":"source/categories/index.md","shasum":"c6cd5091945f5e95b77ccdda674e3192c30736a2","modified":1438479249000},{"_id":"source/_posts/Node從零開始_06.md","shasum":"1bac35282ea62222db91f01cb311410a8a8e6087","modified":1440472465000},{"_id":"source/img/TTtimer/ic_launcher.png","shasum":"80deb1892604a3ec7154a9d4bc36477ba8fd2c2f","modified":1439970250000},{"_id":"source/img/me.jpg","shasum":"511c9c8b9eac4b39228f33d17c79b71a6efca80a","modified":1430655351000},{"_id":"source/img/nodeFormZero_2/node_2_1.png","shasum":"7a20144a14897068c27a3774dce686e1d6723e67","modified":1439513584000},{"_id":"source/img/nodeFormZero_2/node_2_6.png","shasum":"d1d2dad3b9d48f2917afa31d1ca0d6e5dce3cd7e","modified":1439514447000},{"_id":"source/img/nodeFormZero_2/node_3_1.png","shasum":"af766881c005d057f5c4bf42ea862045419c2977","modified":1439910480000},{"_id":"source/img/nodeFormZero_2/node_2_7.png","shasum":"0b382fb40beb65fe86c2db0268f7624a10a7d092","modified":1439486794000},{"_id":"source/tags/index.md","shasum":"5e767603e5f30191472dcc91836eca84f6c9cf8a","modified":1438479223000},{"_id":"source/img/TTtimer/working_finish.png","shasum":"c5d088b9fb11dff6d5a6a05bd40228be0e19f3b4","modified":1420330570000},{"_id":"source/img/nodeFormZero_2/node_2_4.png","shasum":"b88e1f257e3b690dc13d6015d4a20bfe9d18532b","modified":1439515182000},{"_id":"source/img/nodeFormZero_2/node_4_2.png","shasum":"9073bfc037228e5cde4b1146f57ed82415ce7c41","modified":1440463848000},{"_id":"source/img/nodeFormZero_2/node_2_2.png","shasum":"30cd09a399d8947c2769e5d79c04514d39bb1dd6","modified":1439513573000},{"_id":"source/img/nodeFormZero_2/node_2_3.png","shasum":"e8160d262dbd21a057b603ba8280156052c82cbc","modified":1439513691000},{"_id":"source/img/nodeFormZero_2/node_4_1.png","shasum":"2832afa7bf4ea7dec1f104f983acb5f9eb31eb32","modified":1440463250000},{"_id":"source/img/nodeFormZero_2/node_4_4.png","shasum":"d5489e1d406b4f668106c4e8cea4565104d0b0f2","modified":1440466380000},{"_id":"themes/hueman/Gruntfile.js","shasum":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1438449084000},{"_id":"themes/hueman/languages/en.yml","shasum":"79e127d356bdf5a29098793d48d52eb9fc8e9b5c","modified":1438449084000},{"_id":"themes/hueman/LICENSE","shasum":"3975b7883caeb33f61fada7c0ef4add7ab189849","modified":1438449084000},{"_id":"themes/hueman/README.md","shasum":"cb0615f198b8b322d77452aa9fd2924189995855","modified":1438449084000},{"_id":"themes/hueman/_config.yml.example","shasum":"c005adc3200e1ecbbb591ebf0a9a91296ecdaed2","modified":1438475572000},{"_id":"themes/hueman/languages/zh-CN.yml","shasum":"bdc8f74115cfe9aa4fe4eb20b36aa1030338274b","modified":1438449084000},{"_id":"themes/hueman/layout/_partial/archive.ejs","shasum":"d503cd2de2ad6c569d6cc47208987e00536231be","modified":1438449084000},{"_id":"themes/hueman/languages/zh-TW.yml","shasum":"add71557d2dc7ae40cda856db3304a8159079631","modified":1438475709000},{"_id":"themes/hueman/layout/_partial/after-footer.ejs","shasum":"4c1afa7c23b1c20cbd0445ee2734a78a4e5ac774","modified":1438449084000},{"_id":"themes/hueman/layout/_partial/article.ejs","shasum":"fd5eb9c2323bedbee9901e4632af92fdc87a2fa2","modified":1438449084000},{"_id":"themes/hueman/layout/_partial/google-analytics.ejs","shasum":"b85f018bae6da2c96a09c4c69e1e2aeef896e40c","modified":1438476131000},{"_id":"themes/hueman/layout/_partial/footer.ejs","shasum":"6656f5b97a20479efeda55879b17cf8db61bb698","modified":1438478796000},{"_id":"themes/hueman/layout/_partial/header.ejs","shasum":"5467fed4704f9c4c897c6e7284a3af8bab02bdd8","modified":1439171100000},{"_id":"themes/hueman/layout/_partial/head.ejs","shasum":"d27da77c892559b7ab13e36a84db791a2cdec7bf","modified":1438449084000},{"_id":"themes/hueman/layout/_partial/post/category.ejs","shasum":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1438449084000},{"_id":"themes/hueman/layout/_partial/post/date.ejs","shasum":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1438449084000},{"_id":"themes/hueman/layout/_partial/post/tag.ejs","shasum":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1438449084000},{"_id":"themes/hueman/layout/_partial/post/thumbnail.ejs","shasum":"a1d68ad1eb9092aca74321aff3c9fd42029c9ba6","modified":1438449084000},{"_id":"themes/hueman/layout/_partial/post/gallery.ejs","shasum":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1438449084000},{"_id":"themes/hueman/layout/_partial/post/nav.ejs","shasum":"025a7695be81126dff4fcbeff1face60118da600","modified":1438449084000},{"_id":"themes/hueman/layout/_partial/post/title.ejs","shasum":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1438449084000},{"_id":"themes/hueman/layout/_widget/archive.ejs","shasum":"92fcfd830c011f1ff6e7d95443fe65067d3161f8","modified":1438449084000},{"_id":"themes/hueman/layout/_widget/category.ejs","shasum":"f0bb4be5c625003c0e38312f5079667be3a09ab7","modified":1438449084000},{"_id":"themes/hueman/layout/_partial/sidebar.ejs","shasum":"566ec2c9f9051a9489ef1de0b0c15f5765ca14ad","modified":1438449084000},{"_id":"themes/hueman/layout/_widget/links.ejs","shasum":"e24c5bebe3e9f0bbaaf3b44bce8ef5ce56ae348b","modified":1438449084000},{"_id":"themes/hueman/layout/_widget/recent_posts.ejs","shasum":"0c4c97131131e5d06a886f9dc6e00f5de34e2bd3","modified":1438449084000},{"_id":"themes/hueman/layout/_widget/tag.ejs","shasum":"7b35103049fd0480f2631327b9381b7f4c9f5bcb","modified":1438449084000},{"_id":"themes/hueman/layout/_widget/tagcloud.ejs","shasum":"f4ac20c48e4bd6202e263efc9d320de1ad48d608","modified":1438449084000},{"_id":"themes/hueman/layout/archive.ejs","shasum":"2d86ef0f908b57af4ebf007eb8c6624def84f82a","modified":1438449084000},{"_id":"themes/hueman/layout/category.ejs","shasum":"85f2f7e0fdc16c496927511206364304ec364abe","modified":1438449084000},{"_id":"themes/hueman/layout/index.ejs","shasum":"2d86ef0f908b57af4ebf007eb8c6624def84f82a","modified":1438449084000},{"_id":"themes/hueman/layout/layout.ejs","shasum":"fc59e1e1d6127afdc8e2556e07c5d32fed5bb036","modified":1438474993000},{"_id":"themes/hueman/layout/page.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1438449084000},{"_id":"themes/hueman/layout/post.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1438449084000},{"_id":"themes/hueman/layout/tag.ejs","shasum":"2d86ef0f908b57af4ebf007eb8c6624def84f82a","modified":1438449084000},{"_id":"themes/hueman/scripts/fancybox.js","shasum":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1438449084000},{"_id":"themes/hueman/package.json","shasum":"47c5adba0477e92e742349bf86f28bfeb701b3c1","modified":1438449084000},{"_id":"themes/hueman/source/css/_extend.styl","shasum":"41c5b46a19627571bd592eb4b071e2e279333252","modified":1438449084000},{"_id":"themes/hueman/source/css/_partial/archive.styl","shasum":"c611142866096da7c7428d2ef8fd4079a781f57c","modified":1438449084000},{"_id":"themes/hueman/source/css/_partial/article.styl","shasum":"37700f09b26c2d180ccbc80267a9e9b76b3f0a58","modified":1438449084000},{"_id":"themes/hueman/source/css/_partial/assets.styl","shasum":"38e578af64f98e30fba8dadd5a4699a0972eda8e","modified":1438449084000},{"_id":"themes/hueman/source/css/_partial/comment.styl","shasum":"2683cecb7d69e23a3fb1e80f10141454fb4cb232","modified":1438449084000},{"_id":"themes/hueman/source/css/_partial/footer.styl","shasum":"5758e93569a1baf63de1e65ab7746df1d3130624","modified":1438449084000},{"_id":"themes/hueman/source/css/_partial/highlight.styl","shasum":"9332816d92370cff8e252631ef65cb78c53ebb2a","modified":1438449084000},{"_id":"themes/hueman/source/css/_partial/nav.styl","shasum":"ea1d621a570dec9833dcc6519d039821c72e1d8c","modified":1438449084000},{"_id":"themes/hueman/source/css/_partial/header.styl","shasum":"57db2edb99734989ee147226dc952506cb8f73e2","modified":1438449084000},{"_id":"themes/hueman/source/css/_variables.styl","shasum":"4707e0af2154ae372648eeaec2d6f1babc5f740f","modified":1438820514000},{"_id":"themes/hueman/source/css/_partial/sidebar.styl","shasum":"494e9ba779f4d9ad023135baf76a270b2a6d8c94","modified":1438449084000},{"_id":"themes/hueman/source/css/_retina.styl","shasum":"e0445c7caa049250fe3811f55cc82f389009e90f","modified":1438449084000},{"_id":"themes/hueman/source/css/_responsive.styl","shasum":"7518d511dee2f0f4da85ff635ff0da20060dc9b8","modified":1438449084000},{"_id":"themes/hueman/source/css/fonts/FontAwesome.otf","shasum":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1438449084000},{"_id":"themes/hueman/source/css/fonts/fontawesome-webfont.eot","shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1438449084000},{"_id":"themes/hueman/source/css/images/logo-header.bk.png","shasum":"a874be8f3e33831614a421d1a74d2c13bd5eba59","modified":1438449084000},{"_id":"themes/hueman/source/css/fonts/fontawesome-webfont.woff","shasum":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1438449084000},{"_id":"themes/hueman/source/css/images/logo-header.png","shasum":"614fc0d3770b287e33928233ee0859b2954efcd6","modified":1438821140000},{"_id":"themes/hueman/source/css/images/opacity-10.png","shasum":"bbc979866c5b50e8adb348419154b28b1ff44d78","modified":1438449084000},{"_id":"themes/hueman/source/css/images/s-left.png","shasum":"c8cac4f4e3492606fab93196364bd0f87d93bb98","modified":1438449084000},{"_id":"themes/hueman/source/css/images/thumb-default-small.png","shasum":"e8403b97ed9251f9f5207765b0ce796c5000b4ba","modified":1438449084000},{"_id":"themes/hueman/source/css/images/thumb-default.png","shasum":"2d0ba175d958d342494241c616a74d37f48059fb","modified":1438449084000},{"_id":"themes/hueman/source/css/style.styl","shasum":"0c9a533dacb73437543256f398e31ce8189ab970","modified":1438820491000},{"_id":"themes/hueman/source/fancybox/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1438449084000},{"_id":"themes/hueman/source/fancybox/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1438449084000},{"_id":"themes/hueman/source/fancybox/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1438449084000},{"_id":"themes/hueman/source/fancybox/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1438449084000},{"_id":"themes/hueman/source/fancybox/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1438449084000},{"_id":"themes/hueman/source/fancybox/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1438449084000},{"_id":"themes/hueman/source/fancybox/helpers/jquery.fancybox-buttons.js","shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1438449084000},{"_id":"themes/hueman/source/fancybox/helpers/jquery.fancybox-buttons.css","shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1438449084000},{"_id":"themes/hueman/source/fancybox/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1438449084000},{"_id":"themes/hueman/source/fancybox/helpers/jquery.fancybox-thumbs.css","shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1438449084000},{"_id":"themes/hueman/source/fancybox/helpers/jquery.fancybox-media.js","shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1438449084000},{"_id":"themes/hueman/source/fancybox/jquery.fancybox.css","shasum":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1438449084000},{"_id":"themes/hueman/source/fancybox/helpers/jquery.fancybox-thumbs.js","shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1438449084000},{"_id":"themes/hueman/source/js/html-patch.js","shasum":"f58064e8afcc34e816d8e400dafb850bd064a207","modified":1438449084000},{"_id":"themes/hueman/source/js/script.js","shasum":"3a882ecf9ed0a1a921090d954037f90d4e5089e8","modified":1438449084000},{"_id":"themes/hueman/source/fancybox/jquery.fancybox.pack.js","shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1438449084000},{"_id":"themes/hueman/source/fancybox/jquery.fancybox.js","shasum":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1438449084000},{"_id":"themes/hueman/source/scrollLoading/images/preloader.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1438449084000},{"_id":"themes/hueman/source/scrollLoading/jquery.scrollLoading.js","shasum":"1a3eab1ab2c4644fe1ada921bd1bdb083268a751","modified":1438449084000},{"_id":"themes/hueman/source/scrollLoading/images/preloader@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1438449084000},{"_id":"themes/hueman/source/scrollLoading/main.js","shasum":"d1e92247f199fa93c7b3672e6b2ad9ad74a0a529","modified":1438449084000},{"_id":"themes/hueman/source/scrollLoading/style.css","shasum":"4ee06b1478b786aed0817b629cf58f336e5eff62","modified":1438449084000},{"_id":"themes/hueman/source/css/fonts/fontawesome-webfont.ttf","shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1438449084000},{"_id":"source/img/TTtimer/demo.png","shasum":"7302b852ce5cd11944d3ae345faebf1a7f181b3d","modified":1439972131000},{"_id":"themes/hueman/source/css/fonts/fontawesome-webfont.svg","shasum":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1438449084000},{"_id":"source/img/nodeFormZero_2/node_2_5.png","shasum":"db170cf06b2e83620dd7e2c8dd9908df5a3b1fab","modified":1439513629000},{"_id":"source/img/TTtimer/demo2.png","shasum":"7d6d4bed66ab00e4ece09e7f30e3c6367de40527","modified":1439972512000},{"_id":"source/img/nodeFormZero_2/node_4_3.png","shasum":"ec70ba567c2892eaa13fe62110384813b1f735bd","modified":1440464287000},{"_id":"public/scrollLoading/style.css","modified":1485775057852,"shasum":"4ee06b1478b786aed0817b629cf58f336e5eff62"},{"_id":"public/scrollLoading/main.js","modified":1485775057858,"shasum":"d1e92247f199fa93c7b3672e6b2ad9ad74a0a529"},{"_id":"public/scrollLoading/jquery.scrollLoading.js","modified":1485775057860,"shasum":"1a3eab1ab2c4644fe1ada921bd1bdb083268a751"},{"_id":"public/scrollLoading/images/preloader@2x.gif","modified":1485775057868,"shasum":"273b123496a42ba45c3416adb027cd99745058b0"},{"_id":"public/scrollLoading/images/preloader.gif","modified":1485775057874,"shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c"},{"_id":"public/js/script.js","modified":1485775057878,"shasum":"3a882ecf9ed0a1a921090d954037f90d4e5089e8"},{"_id":"public/js/html-patch.js","modified":1485775057883,"shasum":"f58064e8afcc34e816d8e400dafb850bd064a207"},{"_id":"public/fancybox/jquery.fancybox.pack.js","modified":1485775057891,"shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e"},{"_id":"public/fancybox/jquery.fancybox.js","modified":1485775057895,"shasum":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed"},{"_id":"public/fancybox/jquery.fancybox.css","modified":1485775057898,"shasum":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","modified":1485775057900,"shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","modified":1485775057902,"shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f"},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","modified":1485775057903,"shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","modified":1485775057907,"shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","modified":1485775057911,"shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8"},{"_id":"public/fancybox/helpers/fancybox_buttons.png","modified":1485775057913,"shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3"},{"_id":"public/fancybox/fancybox_sprite@2x.png","modified":1485775057915,"shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8"},{"_id":"public/fancybox/fancybox_sprite.png","modified":1485775057923,"shasum":"17df19f97628e77be09c352bf27425faea248251"},{"_id":"public/fancybox/fancybox_overlay.png","modified":1485775057927,"shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0"},{"_id":"public/fancybox/fancybox_loading@2x.gif","modified":1485775057930,"shasum":"273b123496a42ba45c3416adb027cd99745058b0"},{"_id":"public/fancybox/fancybox_loading.gif","modified":1485775057933,"shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c"},{"_id":"public/fancybox/blank.gif","modified":1485775057936,"shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a"},{"_id":"public/css/style.css","modified":1485775058634,"shasum":"a5a589bdfa146ad0a7c66ba029c58561abfef163"},{"_id":"public/css/images/thumb-default.png","modified":1485775058832,"shasum":"2d0ba175d958d342494241c616a74d37f48059fb"},{"_id":"public/css/images/thumb-default-small.png","modified":1485775058835,"shasum":"e8403b97ed9251f9f5207765b0ce796c5000b4ba"},{"_id":"public/css/images/s-left.png","modified":1485775058837,"shasum":"c8cac4f4e3492606fab93196364bd0f87d93bb98"},{"_id":"public/css/images/opacity-10.png","modified":1485775058839,"shasum":"bbc979866c5b50e8adb348419154b28b1ff44d78"},{"_id":"public/css/images/logo-header.png","modified":1485775058841,"shasum":"614fc0d3770b287e33928233ee0859b2954efcd6"},{"_id":"public/css/images/logo-header.bk.png","modified":1485775058843,"shasum":"a874be8f3e33831614a421d1a74d2c13bd5eba59"},{"_id":"public/css/fonts/fontawesome-webfont.woff","modified":1485775058845,"shasum":"04c3bf56d87a0828935bd6b4aee859995f321693"},{"_id":"public/css/fonts/fontawesome-webfont.ttf","modified":1485775058848,"shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f"},{"_id":"public/css/fonts/fontawesome-webfont.svg","modified":1485775058852,"shasum":"46fcc0194d75a0ddac0a038aee41b23456784814"},{"_id":"public/css/fonts/fontawesome-webfont.eot","modified":1485775058855,"shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e"},{"_id":"public/css/fonts/FontAwesome.otf","modified":1485775058859,"shasum":"b5b4f9be85f91f10799e87a083da1d050f842734"},{"_id":"public/img/nodeFormZero_2/node_4_4.png","modified":1485775058864,"shasum":"d5489e1d406b4f668106c4e8cea4565104d0b0f2"},{"_id":"public/img/nodeFormZero_2/node_4_3.png","modified":1485775058870,"shasum":"ec70ba567c2892eaa13fe62110384813b1f735bd"},{"_id":"public/img/nodeFormZero_2/node_4_2.png","modified":1485775058881,"shasum":"9073bfc037228e5cde4b1146f57ed82415ce7c41"},{"_id":"public/img/nodeFormZero_2/node_4_1.png","modified":1485775058884,"shasum":"2832afa7bf4ea7dec1f104f983acb5f9eb31eb32"},{"_id":"public/img/nodeFormZero_2/node_3_1.png","modified":1485775058892,"shasum":"af766881c005d057f5c4bf42ea862045419c2977"},{"_id":"public/img/nodeFormZero_2/node_2_7.png","modified":1485775058894,"shasum":"0b382fb40beb65fe86c2db0268f7624a10a7d092"},{"_id":"public/img/nodeFormZero_2/node_2_6.png","modified":1485775058897,"shasum":"d1d2dad3b9d48f2917afa31d1ca0d6e5dce3cd7e"},{"_id":"public/img/nodeFormZero_2/node_2_5.png","modified":1485775058900,"shasum":"db170cf06b2e83620dd7e2c8dd9908df5a3b1fab"},{"_id":"public/img/nodeFormZero_2/node_2_4.png","modified":1485775058905,"shasum":"b88e1f257e3b690dc13d6015d4a20bfe9d18532b"},{"_id":"public/img/nodeFormZero_2/node_2_3.png","modified":1485775058908,"shasum":"e8160d262dbd21a057b603ba8280156052c82cbc"},{"_id":"public/img/nodeFormZero_2/node_2_2.png","modified":1485775058913,"shasum":"30cd09a399d8947c2769e5d79c04514d39bb1dd6"},{"_id":"public/img/nodeFormZero_2/node_2_1.png","modified":1485775058915,"shasum":"7a20144a14897068c27a3774dce686e1d6723e67"},{"_id":"public/img/me.jpg","modified":1485775058918,"shasum":"511c9c8b9eac4b39228f33d17c79b71a6efca80a"},{"_id":"public/img/TTtimer/working_finish.png","modified":1485775058924,"shasum":"c5d088b9fb11dff6d5a6a05bd40228be0e19f3b4"},{"_id":"public/img/TTtimer/ic_launcher.png","modified":1485775058927,"shasum":"80deb1892604a3ec7154a9d4bc36477ba8fd2c2f"},{"_id":"public/img/TTtimer/demo2.png","modified":1485775058946,"shasum":"7d6d4bed66ab00e4ece09e7f30e3c6367de40527"},{"_id":"public/img/TTtimer/demo.png","modified":1485775058958,"shasum":"7302b852ce5cd11944d3ae345faebf1a7f181b3d"},{"_id":"public/tags/index.html","modified":1485775059034,"shasum":"1ef0eeaedad5f6a65f2e87583533123b8dd2fd53"},{"_id":"public/categories/index.html","modified":1485775059057,"shasum":"6c06ed0f89af78ca727ba093386eaa2cd8de25d6"},{"_id":"public/2015/08/25/Node從零開始_06/index.html","modified":1485775059122,"shasum":"5d617b163fad4bdb42439c737497339edd3da307"},{"_id":"public/2015/08/25/Node從零開始_05/index.html","modified":1485775059150,"shasum":"4910a9b8f6e935cc14a65210659653854decc1eb"},{"_id":"public/2015/08/19/003_TTtimerForOIT/index.html","modified":1485775059169,"shasum":"435a9aad1431613e632c7a7d7483ab5427a0b956"},{"_id":"public/2015/08/18/Node從零開始_04/index.html","modified":1485775059213,"shasum":"fc4404f504e0d54e19c7276a6584528b44d6691b"},{"_id":"public/2015/08/18/JavaScript_01/index.html","modified":1485775059243,"shasum":"e87dacbd27f9af366e3d5e81c9285f2b8642f0c9"},{"_id":"public/2015/08/16/Node_Redis記憶體快取/index.html","modified":1485775059270,"shasum":"b46263503d3fefb1c15d2372a01308a25259bd98"},{"_id":"public/2015/08/15/Node從零開始_03/index.html","modified":1485775059294,"shasum":"639ff03ec9a47889d625eca4f443f28b934947f4"},{"_id":"public/2015/08/12/Node從零開始_02/index.html","modified":1485775059315,"shasum":"a2c7e30718296cb07c47afbc33dc24287764b4d4"},{"_id":"public/2015/08/09/Node從零開始_01/index.html","modified":1485775059345,"shasum":"4dd7b5a26e4191d127d2c0fb0b7e374593808120"},{"_id":"public/2015/08/02/002_AngularReactOrOther/index.html","modified":1485775059374,"shasum":"d48992cd96a486808da4dd6b0040d77328ea7515"},{"_id":"public/2015/08/02/001_JSDevilDay/index.html","modified":1485775059401,"shasum":"02f1fce92c38f8905d5ecd4e5fd863d122684119"},{"_id":"public/archives/index.html","modified":1485775059434,"shasum":"d8e461e5e7c2aedd93e905954f164554dc4116b3"},{"_id":"public/archives/page/2/index.html","modified":1485775059447,"shasum":"2b75a9802e3b191ca734d6f4ef9111c2f0d15597"},{"_id":"public/archives/2015/index.html","modified":1485775059473,"shasum":"cfb7db32b8f6766bef5734c11efa83218829db8f"},{"_id":"public/archives/2015/page/2/index.html","modified":1485775059489,"shasum":"24add5ee5c40edd84b9f376d534f8edc7efb9e1a"},{"_id":"public/archives/2015/08/index.html","modified":1485775059538,"shasum":"9e987f924fab9e35a1d2be64783c31a5060ae396"},{"_id":"public/archives/2015/08/page/2/index.html","modified":1485775059558,"shasum":"a449bf98f25d9b1732031ebc96cbd9442986f49c"},{"_id":"public/categories/社群活動/index.html","modified":1485775059583,"shasum":"806748db2f45440dc7075bd89393b9e456eb5fdb"},{"_id":"public/categories/Node-js-從零開始/index.html","modified":1485775059606,"shasum":"0ac611918ac76218d406ab071997d64ddfed530d"},{"_id":"public/categories/Node-js/index.html","modified":1485775059643,"shasum":"bca02cf3c4b2f1c2b957f6ca89a317d62244a4f6"},{"_id":"public/categories/JavaScript/index.html","modified":1485775059656,"shasum":"e4e888a23941f669d489582ae1a02f28603eac3d"},{"_id":"public/categories/作品集/index.html","modified":1485775059679,"shasum":"c404dcb63bde7b1e0bbca699c2ad2244193412cd"},{"_id":"public/index.html","modified":1485775059701,"shasum":"241fdf3622cc155f3155806143dd8028dc0195ad"},{"_id":"public/page/2/index.html","modified":1485775059726,"shasum":"a228005adc5f7621e382e7ce0b817e77b7351c20"},{"_id":"public/sitemap.xml","modified":1485775059728,"shasum":"76d06e19ddea2fdd0ece25f4605417a099bddb4d"},{"_id":"public/tags/社群活動/index.html","modified":1485775059748,"shasum":"a61765b398121168066c4071b693fbce7e2cf7b6"},{"_id":"public/tags/JavaScript/index.html","modified":1485775059777,"shasum":"181af9b4951e51b84ea78e02f404b454ac96cc8e"},{"_id":"public/tags/ES6/index.html","modified":1485775059793,"shasum":"1d8736302deddff7b37dba8f6543b12143161565"},{"_id":"public/tags/Node-js/index.html","modified":1485775059818,"shasum":"ee36161de727101709eb59400b2e5b37650cce3b"},{"_id":"public/tags/Node-js-從零開始/index.html","modified":1485775059837,"shasum":"aa26f491ec9592c2e0365f74aa1c737d2b638808"},{"_id":"public/tags/Android/index.html","modified":1485775059852,"shasum":"6d42279873b65f34077431ade3542d43224c3e7d"},{"_id":"public/tags/Java/index.html","modified":1485775059866,"shasum":"0babee0220f030a8303017429a4aaf747c6b5304"},{"_id":"public/tags/作品集/index.html","modified":1485775059890,"shasum":"5fac71756b91d5bb81ff37170a25082fbcaa7eaf"},{"_id":"public/tags/Angular-js/index.html","modified":1485775059914,"shasum":"c76ed5ef3513a2575c395f6857a4dc8fe665184c"},{"_id":"public/tags/React-js/index.html","modified":1485775059922,"shasum":"0d96ff54dad8ff03e92ca4384c294ab9c0f046e8"}],"Category":[{"name":"社群活動","_id":"ciyk03v3800010bu0amduskpg"},{"name":"Node.js 從零開始","_id":"ciyk03v3l000c0bu01egt5igl"},{"name":"Node.js","_id":"ciyk03v4000190bu0hkaaiwei"},{"name":"JavaScript","_id":"ciyk03v43001e0bu0esac1dpc"},{"name":"作品集","_id":"ciyk03v46001i0bu0ap5md7kd"}],"Data":[],"Page":[{"title":"Tags","date":"2015-08-02T01:33:43.000Z","_content":"","source":"tags/index.md","raw":"title: tags\ndate: 2015-08-02 09:33:43\n---\n","updated":"2015-08-02T01:33:43.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ciyk03v3d00090bu03zwgxwlg"},{"title":"Categories","date":"2015-08-02T01:34:09.000Z","_content":"","source":"categories/index.md","raw":"title: categories\ndate: 2015-08-02 09:34:09\n---\n","updated":"2015-08-02T01:34:09.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ciyk03v3i000a0bu0qkron7ik"}],"Post":[{"title":"JS Devil Day 參與心得","date":"2015-08-02T01:05:42.000Z","comments":0,"_content":"\n> 本篇文上是本人Andrew Chen為[JSDC 2015](http://jsdc.tw)撰寫\n> 感謝[Caeser Chi](https://www.facebook.com/clonncd?fref=ts)給予指導\n\n![JS Devil Day](https://lh3.googleusercontent.com/-mm7RHTIWOAw/VXT1RxK7xrI/AAAAAAAAQK0/LQGMSNo2aNE/s0/post-0-0-83751300-1350904929_large.jpg)\n\nJS Devil Day 是本次 JSDC 2015 所舉辦第一場對外 Meetup，也是首次透過北中南三方連線方式進行，本次以參與者角色，記錄此次活動。\n\nJS Devil Day 當天主要有三個主題：Angular.js、ECMAScript6、講者對談與交流。\n\n## 專家分享\n\n儘管對 Angular.js相當不熟悉，透過講者阿梨的分享讓我對Angular.js的概念有些許的了解，事後座談時講者也推薦初學者直接以Angular.js 2.0作為起手版本。\n\n接著是 Jeremy 對 ES6、webpack 提出了幾個重點，在 ES6 中可以明顯地感受到 JavaScript 已經開始嘗試解決 ES5 一些為人詬病的問題，包括區域變數、類別、模組化等等，同時 ES6 內建了 promise 和 generator ，同時在 ES6 解決了過複雜的 callback function和流程控制，另外 ES6 採用許多 coffeeScript 語法讓結構更為簡潔。\n\n個人認為 ES6 讓 Javascript 成為了更完整的開發語言，也讓 Javascript 減少了許多舊有的小問題，也不必仰賴開發者用奇技淫巧去嘗試解決問題。\n\n現今主流瀏覽器諸如：Chrome、Safari、Firefox 等等，已經逐漸開始支援 ES6，但尚未完全支援。在瀏覽器完全支援 ES6 之前，我們可以透過 babel 在程式執行之前將 ES6 的程式碼轉譯成 ES5，讓瀏覽器完全整的支援 ES6 程式碼。\n\n另外 Jeremy 提到 webpack 和 JSCS ，協助團隊開發更為順暢，開發工具和技巧相當的重要。順暢的開發過程除了提高效率之外，也保護了開發者健康的肝。","source":"_posts/001_JSDevilDay.md","raw":"title: JS Devil day 參與心得\ndate: 2015-08-02 09:05:42\ntags:\n- 社群活動\n- JavaScript\n- ES6\ncategories: 社群活動\ncomments: false\n---\n\n> 本篇文上是本人Andrew Chen為[JSDC 2015](http://jsdc.tw)撰寫\n> 感謝[Caeser Chi](https://www.facebook.com/clonncd?fref=ts)給予指導\n\n![JS Devil Day](https://lh3.googleusercontent.com/-mm7RHTIWOAw/VXT1RxK7xrI/AAAAAAAAQK0/LQGMSNo2aNE/s0/post-0-0-83751300-1350904929_large.jpg)\n\nJS Devil Day 是本次 JSDC 2015 所舉辦第一場對外 Meetup，也是首次透過北中南三方連線方式進行，本次以參與者角色，記錄此次活動。\n\nJS Devil Day 當天主要有三個主題：Angular.js、ECMAScript6、講者對談與交流。\n\n## 專家分享\n\n儘管對 Angular.js相當不熟悉，透過講者阿梨的分享讓我對Angular.js的概念有些許的了解，事後座談時講者也推薦初學者直接以Angular.js 2.0作為起手版本。\n\n接著是 Jeremy 對 ES6、webpack 提出了幾個重點，在 ES6 中可以明顯地感受到 JavaScript 已經開始嘗試解決 ES5 一些為人詬病的問題，包括區域變數、類別、模組化等等，同時 ES6 內建了 promise 和 generator ，同時在 ES6 解決了過複雜的 callback function和流程控制，另外 ES6 採用許多 coffeeScript 語法讓結構更為簡潔。\n\n個人認為 ES6 讓 Javascript 成為了更完整的開發語言，也讓 Javascript 減少了許多舊有的小問題，也不必仰賴開發者用奇技淫巧去嘗試解決問題。\n\n現今主流瀏覽器諸如：Chrome、Safari、Firefox 等等，已經逐漸開始支援 ES6，但尚未完全支援。在瀏覽器完全支援 ES6 之前，我們可以透過 babel 在程式執行之前將 ES6 的程式碼轉譯成 ES5，讓瀏覽器完全整的支援 ES6 程式碼。\n\n另外 Jeremy 提到 webpack 和 JSCS ，協助團隊開發更為順暢，開發工具和技巧相當的重要。順暢的開發過程除了提高效率之外，也保護了開發者健康的肝。","slug":"001_JSDevilDay","published":1,"updated":"2015-08-03T11:42:51.000Z","layout":"post","photos":[],"link":"","_id":"ciyk03v3200000bu0hyj7jtak"},{"title":"Part 6 - Express 進階運用 (2)","date":"2015-08-25T02:40:36.000Z","comments":0,"_content":"\n![Express](https://stormpath.com/images/blog/express-and-node-opengraph.png)\n\n## 前言\n\nAPI 有各種需求，為了因應這些需求，API 能使用的操作也不是回應資料這麼簡單，接著介紹常用的 Express API 操作，透過這些操作基本上能應付絕大多數的需求。包含規劃 RESTful API，回應各種使用者操作，回應各種 bug，或是一些簡單的安全技巧。\n\n## 各種資料接收的方式\n\n先前提過的是 `res.query.data` 可以取得 queryString 的值，這邊介紹另外兩種\n\n如果是用 post 傳入的 data，如下：\n\n``` js \n$.ajax({\n\ttype: 'POST',\n\turl: 'http://localhost:8080/login/',\n\tdata: { account: 'admin', pwd: '123' }\n\n\t//取得資料成功觸發\n\tsuccess: function(result){\n\t\t$('#show').append('Hi !' + result.name);\n\t},\n\n\t//失敗顯示 error\n\tfail: function(err){\n\t\tconsole.log('出現錯誤', err);\n\t\t$('#show').append('找不到使用者資料')\n\t}\n  })\n```\n\n想要取得 data 傳送過來的資料相當簡單，運用 `this.body.params`：\n\n```\nrouter.get('/login', function(req, res, next) {\n\n  var account = this.body.account;\n\n  if( this.body.pwd === '123'){\n\n    var data = { name: account, auth: 15 };\n    res.json(data);\n\n  }else{\n    // login fail ...\n  }\n\n});\n```\n\n另外一種是取得 url 傳遞的參數，這種就偏向 RESTful APi 的使用方式，直接看範例：\n\n``` js\nrouter.get('/home/:lan', function(req, res, next) {\n\n  if( this.params.lan === 'zh-TW' )\n    res.render('home', data['zh-TW']);\n  else\n    res.render('home', data.en);\n});\n```\n\n這個範例中讓 `http://localhost:3000/home/zh-TW` 能取得中文的首頁，其餘取得英文的首頁。這跟 QueryString 不同的是，他並不會寫一個很醜的 `?` 在後面，而是直接用路徑就可以傳遞參數，但需要注意的事情是：\n\n`/home/:lan` 和 `/home`\n\n是不同的，意即如果 `/home` 沒有接其他路徑，是會找不到頁面的，在規劃 Express Router 時需要多注意的地方。\n\n\n## return\n\n善用 return 來結束 API，同一支 API 不能回應兩次。也就是說 `res` 不能使用兩次，使用到第二次的時候 Node.js 就會出現錯誤。但 `res.json` 或是 `res.render` 等等操作，其實並不具備結束的功能。\n\n``` js\nrouter.get('/getName', function(req, res, next) {\n\n  var data = { name: 'Andrew Chen' };\n  res.json( data );\n  res.json( data );\n});\n```\n\n![Node.js 回報的錯誤](http://polarbearandrew.github.io/blog/img/nodeFormZero_2/node_4_4.png)\n\n當然直接 `res.json( data );` 寫兩次的這個錯誤不太容易發生，實際上容易發生的情況為：\n\n\n``` js\nrouter.get('/getName', function(req, res, next) {\n\n  var data = { name: 'Andrew Chen', auth: 15 };\n\n  if( data.auth >= 10){\n    res.json( data );\n  }\n\n  res.json( data );\n});\n```\n\n有可能針對要回應(從資料庫裡撈出來的)的資料進行一些小檢查，用 if 做了簡單的判斷，往往在複雜的操作過後，會忘記最後面還有一個無論如何都會執行的 `res.json(data);`。因此在撰寫習慣下，建議在每個操作的末端，都補上 `return`。確保 API 的 function 有結束\n\n``` js\nrouter.get('/getName', function(req, res, next) {\n\n  var data = { name: 'Andrew Chen', auth: 15 };\n\n  if( data.auth >= 10){\n    return res.json( data );\n  }\n\n  return res.json( data );\n});\n```\n\n## http status code\n\n從 API 中設定 http 的狀態碼，只需要使用 `res.status(200)`，替換數字即可，讓我們可以明確的操作這些狀態。使用在後面會有介紹。\n\n## Express 常用操作\n\n以下為四種常用到的操作：\n\n``` js\nres.render('index', data); //回應頁面\n\nres.json( data );   \t\t//回應 JSON 格式的資料\n\nres.send( data );\t\t\t//回應各種資料，可以回應字串\n\nres.status(204).end();\t\t//無聲的回應\n```\n\n需要解釋的是最後一種 \"無聲的回應\"。http code 204 是回應使用 “已經收到訊息，但要有任何動作”，也就是使用者端會感覺什麼事情都沒有發生，ajax 也不會觸發任何 success 或 fail 的操作。那 `.end()` 是透過 Express 發送 API 結束訊號，單純撰寫 `res.status(204)` 也可以，但並不會回傳任何訊息，ajax 的請求就會進入乾等，等到拋出遇時錯誤。因此透過 `.end()` 的操作讓 API 在無操作時明確的結束。\n\n關於 status 204 的這種操作，感謝 [Dca](https://www.facebook.com/dca.hsu?fref=ts) 的教導。\n\n## 回應錯誤\n\n回應錯誤有兩種方式：\n\n因為避免使用者看到太多不相干的資訊可以直接用 404 查無頁面回應使用者，這樣確保使用者不會發現我們的 code 有 bug。\n\n``` js\nres.status(404).end();\n```\n\n不過在 Express 中有另外更美的解決手段，透過 Middleware 去讀取 Express 預設的 404 page，只要啟用 Middleware 的 `next()` 即可。\n\n``` js\nrouter.get('/login', function(req, res, next) {\n  var err = { msg: '登入錯誤' }\n  return next(err);\n});\n```\n\n這邊的 err 僅僅是個範例，有可能是我們從其他模組承接過來的 err，我們只要直接塞到下一個操作中，將自己想像成 Middleware 即可。加上return 同樣是確保結束。\n\n## RESTful API\n\n那怎麼使用 RESTful API 所提到的各種操作種，原先我們都是使用 `router.get(...)` ，因此只要\n\n* `router.post(...)`\n* `router.get(...)`\n* `router.put(...)`\n* `router.delete(...)`\n\n分別對應到 RESTful API 的操作！ \n\n## 結語\n\n綜合以上的操作，可以開始規劃 Express Router，以下是我在其中一個專案中規劃的，僅供參考，大致上是後台管理系統對使用者資料的操作：\n\n新增使用者資料\t\t`[POST] /user/`\n取得所有使用者資料 \t`[GET] /user/`\n取得幾筆使用者資料 \t`[GET] /user/:count`\n刪除使用者\t\t\t`[DELETE] /user/`\n修改使用者\t\t\t`[PUT] /user`\n\n但在規劃上並沒有絕對強制的用法，主要是看團隊習慣或是主流文化。在不同的情況下嘗試使用 RESTful API 下去規劃，我個人就在規畫初期撞到好幾次錯誤，起出認為的功能和前端街口會產生誤會，例如 \"取得幾筆使用者資料 \t`[GET] /user/:count`\" 這種操作就引人遐想，`:count` 是指第幾比到第幾比，或是一次抓幾筆，甚至是使用者編號？因此 params 的正確命名並且和前端良好的溝通是維持整機制運作的重點。如果是全端開發，也要注意正確的語意，別在後期開發自己雷到自己。","source":"_posts/Node從零開始_06.md","raw":"title: Part 6 - express 進階運用 (2)\ndate: 2015-08-25 10:40:36\ntags:\n- Node.js\n- Node.js 從零開始\n- JavaScript\ncategories: Node.js 從零開始\ncomments: false\n---\n\n![Express](https://stormpath.com/images/blog/express-and-node-opengraph.png)\n\n## 前言\n\nAPI 有各種需求，為了因應這些需求，API 能使用的操作也不是回應資料這麼簡單，接著介紹常用的 Express API 操作，透過這些操作基本上能應付絕大多數的需求。包含規劃 RESTful API，回應各種使用者操作，回應各種 bug，或是一些簡單的安全技巧。\n\n## 各種資料接收的方式\n\n先前提過的是 `res.query.data` 可以取得 queryString 的值，這邊介紹另外兩種\n\n如果是用 post 傳入的 data，如下：\n\n``` js \n$.ajax({\n\ttype: 'POST',\n\turl: 'http://localhost:8080/login/',\n\tdata: { account: 'admin', pwd: '123' }\n\n\t//取得資料成功觸發\n\tsuccess: function(result){\n\t\t$('#show').append('Hi !' + result.name);\n\t},\n\n\t//失敗顯示 error\n\tfail: function(err){\n\t\tconsole.log('出現錯誤', err);\n\t\t$('#show').append('找不到使用者資料')\n\t}\n  })\n```\n\n想要取得 data 傳送過來的資料相當簡單，運用 `this.body.params`：\n\n```\nrouter.get('/login', function(req, res, next) {\n\n  var account = this.body.account;\n\n  if( this.body.pwd === '123'){\n\n    var data = { name: account, auth: 15 };\n    res.json(data);\n\n  }else{\n    // login fail ...\n  }\n\n});\n```\n\n另外一種是取得 url 傳遞的參數，這種就偏向 RESTful APi 的使用方式，直接看範例：\n\n``` js\nrouter.get('/home/:lan', function(req, res, next) {\n\n  if( this.params.lan === 'zh-TW' )\n    res.render('home', data['zh-TW']);\n  else\n    res.render('home', data.en);\n});\n```\n\n這個範例中讓 `http://localhost:3000/home/zh-TW` 能取得中文的首頁，其餘取得英文的首頁。這跟 QueryString 不同的是，他並不會寫一個很醜的 `?` 在後面，而是直接用路徑就可以傳遞參數，但需要注意的事情是：\n\n`/home/:lan` 和 `/home`\n\n是不同的，意即如果 `/home` 沒有接其他路徑，是會找不到頁面的，在規劃 Express Router 時需要多注意的地方。\n\n\n## return\n\n善用 return 來結束 API，同一支 API 不能回應兩次。也就是說 `res` 不能使用兩次，使用到第二次的時候 Node.js 就會出現錯誤。但 `res.json` 或是 `res.render` 等等操作，其實並不具備結束的功能。\n\n``` js\nrouter.get('/getName', function(req, res, next) {\n\n  var data = { name: 'Andrew Chen' };\n  res.json( data );\n  res.json( data );\n});\n```\n\n![Node.js 回報的錯誤](http://polarbearandrew.github.io/blog/img/nodeFormZero_2/node_4_4.png)\n\n當然直接 `res.json( data );` 寫兩次的這個錯誤不太容易發生，實際上容易發生的情況為：\n\n\n``` js\nrouter.get('/getName', function(req, res, next) {\n\n  var data = { name: 'Andrew Chen', auth: 15 };\n\n  if( data.auth >= 10){\n    res.json( data );\n  }\n\n  res.json( data );\n});\n```\n\n有可能針對要回應(從資料庫裡撈出來的)的資料進行一些小檢查，用 if 做了簡單的判斷，往往在複雜的操作過後，會忘記最後面還有一個無論如何都會執行的 `res.json(data);`。因此在撰寫習慣下，建議在每個操作的末端，都補上 `return`。確保 API 的 function 有結束\n\n``` js\nrouter.get('/getName', function(req, res, next) {\n\n  var data = { name: 'Andrew Chen', auth: 15 };\n\n  if( data.auth >= 10){\n    return res.json( data );\n  }\n\n  return res.json( data );\n});\n```\n\n## http status code\n\n從 API 中設定 http 的狀態碼，只需要使用 `res.status(200)`，替換數字即可，讓我們可以明確的操作這些狀態。使用在後面會有介紹。\n\n## Express 常用操作\n\n以下為四種常用到的操作：\n\n``` js\nres.render('index', data); //回應頁面\n\nres.json( data );   \t\t//回應 JSON 格式的資料\n\nres.send( data );\t\t\t//回應各種資料，可以回應字串\n\nres.status(204).end();\t\t//無聲的回應\n```\n\n需要解釋的是最後一種 \"無聲的回應\"。http code 204 是回應使用 “已經收到訊息，但要有任何動作”，也就是使用者端會感覺什麼事情都沒有發生，ajax 也不會觸發任何 success 或 fail 的操作。那 `.end()` 是透過 Express 發送 API 結束訊號，單純撰寫 `res.status(204)` 也可以，但並不會回傳任何訊息，ajax 的請求就會進入乾等，等到拋出遇時錯誤。因此透過 `.end()` 的操作讓 API 在無操作時明確的結束。\n\n關於 status 204 的這種操作，感謝 [Dca](https://www.facebook.com/dca.hsu?fref=ts) 的教導。\n\n## 回應錯誤\n\n回應錯誤有兩種方式：\n\n因為避免使用者看到太多不相干的資訊可以直接用 404 查無頁面回應使用者，這樣確保使用者不會發現我們的 code 有 bug。\n\n``` js\nres.status(404).end();\n```\n\n不過在 Express 中有另外更美的解決手段，透過 Middleware 去讀取 Express 預設的 404 page，只要啟用 Middleware 的 `next()` 即可。\n\n``` js\nrouter.get('/login', function(req, res, next) {\n  var err = { msg: '登入錯誤' }\n  return next(err);\n});\n```\n\n這邊的 err 僅僅是個範例，有可能是我們從其他模組承接過來的 err，我們只要直接塞到下一個操作中，將自己想像成 Middleware 即可。加上return 同樣是確保結束。\n\n## RESTful API\n\n那怎麼使用 RESTful API 所提到的各種操作種，原先我們都是使用 `router.get(...)` ，因此只要\n\n* `router.post(...)`\n* `router.get(...)`\n* `router.put(...)`\n* `router.delete(...)`\n\n分別對應到 RESTful API 的操作！ \n\n## 結語\n\n綜合以上的操作，可以開始規劃 Express Router，以下是我在其中一個專案中規劃的，僅供參考，大致上是後台管理系統對使用者資料的操作：\n\n新增使用者資料\t\t`[POST] /user/`\n取得所有使用者資料 \t`[GET] /user/`\n取得幾筆使用者資料 \t`[GET] /user/:count`\n刪除使用者\t\t\t`[DELETE] /user/`\n修改使用者\t\t\t`[PUT] /user`\n\n但在規劃上並沒有絕對強制的用法，主要是看團隊習慣或是主流文化。在不同的情況下嘗試使用 RESTful API 下去規劃，我個人就在規畫初期撞到好幾次錯誤，起出認為的功能和前端街口會產生誤會，例如 \"取得幾筆使用者資料 \t`[GET] /user/:count`\" 這種操作就引人遐想，`:count` 是指第幾比到第幾比，或是一次抓幾筆，甚至是使用者編號？因此 params 的正確命名並且和前端良好的溝通是維持整機制運作的重點。如果是全端開發，也要注意正確的語意，別在後期開發自己雷到自己。","slug":"Node從零開始_06","published":1,"updated":"2015-08-25T03:14:25.000Z","layout":"post","photos":[],"link":"","_id":"ciyk03v3k000b0bu0up3f7hbx"},{"title":"Part 5 - Express 進階運用","date":"2015-08-25T01:21:00.000Z","comments":0,"_content":"\n![Express](https://stormpath.com/images/blog/express-and-node-opengraph.png)\n\n## 簡介\n\n前一篇介紹過模板 Jade 的基本操作，並且透過 Express 朝 Jade 傳遞資料，在學習連接並操作 DB 之前，先來了解如何撰寫回應資料的 API，在撰寫 API 之前要來談談 RESTful api 這件事情，了解如何撰寫、規劃好的 API 架構。\n\n有趣的事情是，RESTful API 指的是一種規劃 API 的方式，嚴格來說也不一定要遵守，看看外國網站 [nodeframework](http://nodeframework.com) 的對 Express 框架的分類，相當有趣的事情是被分類到 MVC 架構中的，不過主因是 Express 主要仰賴模板來結合資料與畫面。但再次說明，RESTful API 是一種規劃 API 的觀念與方式，因此我們仍然能在 Express 框架下撰寫 RESTful API。\n\n這樣是不是緣木求魚呢？\n\n並不是的，除非只想製作單純顯示資料的網頁，也就是單向從伺服器向使用者回應資料，那並不需要 API 規劃，把頁面跟 router 規劃好即可。但往往只要稍多的 API 資料操作，就容易造成整個 router 的混亂。因此撰寫 RESTful API 就像物件導向一樣，是一種好習慣，明沒有所謂的 MVC 架構下就沒有 RESTful API 的觀念。\n\n對於 RESTful API 的討論推薦參考 [Amigo 陳兆祥](http://www.slideshare.net/AmigoChan?utm_campaign=profiletracking&utm_medium=sssite&utm_source=ssslideview) 前輩的 [slide](http://www.slideshare.net/AmigoChan/restful-api-design) 裡面觀念講解的相當詳細。\n\n## 撰寫自己的 API\n\nAPI 很難嗎？不會的，超簡單。其實大家早就會了。\n\n這是原先回應網頁給使用者的方式。\n\n``` js\nrouter.get('/home', function(req, res, next) {\n  res.render('andrew', { name: 'Andrew Chen' } ); \n});\n```\n\n改成這樣就能回應資料了，這次回應的資料是 JSON，包裝 name 這個資料\n\n``` js\nrouter.get('/getName', function(req, res, next) {\n  res.json({ name: 'Andrew Chen' });\n});\n```\n\n相當易懂，使用 `localhost:3000/home` 就能拿到 `{ name: 'Andrew Chen' }` 這筆資料了。\n\n![回應資料狀況](http://polarbearandrew.github.io/blog/img/nodeFormZero_2/node_4_1.png)\n\n但這樣並不符合需求，我們改變取得資料的方式。建立一個新的 .html 檔案。當然這個頁面以可以用 jade 撰寫，不過為了表示使用 API 並不需要是從伺服器產生的頁面，我們另外開一個。\n\n``` html \n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>RESTful AIP</title>\n\n  <!-- jQuery CDN -->\n  <script src=\"https://code.jquery.com/jquery-2.1.4.min.js\"></script>\n\n  <script>\n\n  // ajax 操作\n  $.ajax({\n    type: 'GET',\n    url: 'http://localhost:8080/getName/',\n\n    //取得資料成功觸發\n    success: function(data){\n      console.log('取得資料', data);\n    },\n\n    //失敗顯示 error\n    fail: function(err){\n      console.log('出現錯誤', err);\n    }\n  })\n  </script>\n\n</head>\n<body>\n\n  <!-- 使用者看到的畫面 -->\n  <h1> API DEMO 頁面</h1>\n\n</body>\n</html>\n```\n\n接著啟動這個頁面，就會看到在前一篇題過的 XMLHttpRequest 錯誤，這個錯誤並沒有相當大，僅僅是 server 沒有給予 ajax 操作的權限而已。\n\n![XMLHttpRequest 錯誤訊息](http://polarbearandrew.github.io/blog/img/nodeFormZero_2/node_4_2.png)\n\n解決方式如下\n\n### header 設定問題\n\n如果需要 Node.js 中設定 http header 的話，在 `app.use` 各種 router 之前補上這段，讓非本機的連線能獲得請求的許可。這種問題在日後較容易出現，因為連線的權限不足需要許可。記得是在 `app.use` 各種 router 之前補上這段，補在之後是沒有用的。\n\n``` js\n//set haeder\napp.use(function(req, res, next) {\n    res.header('Access-Control-Allow-Origin', \"*\");\n    res.header('Access-Control-Allow-Headers', 'Content-Type');\n    res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE');\n    next();\n});\n```\n\n接著就能看到 ajax 成功的取得資料。\n\n![完成的成果](http://polarbearandrew.github.io/blog/img/nodeFormZero_2/node_4_3.png)\n\n這種非同步的資料讀取方式，可以運用在很多不同的地方，舉例來說：\n\n* Google 瀏覽器的輸入建議\n* 在列表中進一步展開的詳細資訊\n* 類似 Facebook 的聊天視窗\n\n這些都是類似 ajax 的操作，當然類似功能的有 `request`、`fetch` 這些其他的功能會在日後提到，有興趣的朋友可去看看 `fetch`，最近相當火紅。稍微修改一下測試用的 html，簡易的 demo 一下 ajax 的運作狀況。\n\n``` html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>RESTful AIP</title>\n\n  <!-- jQuery CDN -->\n  <script src=\"https://code.jquery.com/jquery-2.1.4.min.js\"></script>\n\n  <script>\n\n  $('html, body').on('click', '#btn', function(){\n\n    // ajax 操作\n    $.ajax({\n      type: 'GET',\n      url: 'http://localhost:8080/getName/',\n\n      //取得資料成功觸發\n      success: function(data){\n        console.log('取得資料', data);\n        $('#show').append('Hi !' + data.name);\n      },\n\n      //失敗顯示 error\n      fail: function(err){\n        console.log('出現錯誤', err);\n        $('#show').append('找不到使用者資料')\n      }\n    })\n  });\n  </script>\n\n</head>\n<body>\n\n  <!-- 使用者看到的畫面 -->\n  <h1> API DEMO 頁面</h1>\n  <button id=\"btn\">取得資料</button>\n  <hr/>\n  <div id=\"show\"></div>\n\n</body>\n</html>\n```\n\n## 結語\n\nAPI 是使用者端跟伺服器溝通或取得資料的一種方式，下篇會介紹 Express 中的 RESTful API 操作，和各種傳遞資料的方式。\n\n如果測試 API 時每次都要撰寫新的 html 相當麻煩。有兩種解決方式，一是撰寫測試程式碼，二是用 GUI 工具 [Postman](https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop)，我個人推薦使用 Postman 先度過還不會寫測試的階段。\n\n## 參考資料\n\n* [Express](http://expressjs.com)\n* [Postman](https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop)\n* [XMLHttpRequest](https://developer.mozilla.org/zh-TW/docs/Web/API/XMLHttpRequest)","source":"_posts/Node從零開始_05.md","raw":"title: Part 5 - express 進階運用\ndate: 2015-08-25 09:21:00\ntags:\n- Node.js\n- Node.js 從零開始\n- JavaScript\ncategories: Node.js 從零開始\ncomments: false\n---\n\n![Express](https://stormpath.com/images/blog/express-and-node-opengraph.png)\n\n## 簡介\n\n前一篇介紹過模板 Jade 的基本操作，並且透過 Express 朝 Jade 傳遞資料，在學習連接並操作 DB 之前，先來了解如何撰寫回應資料的 API，在撰寫 API 之前要來談談 RESTful api 這件事情，了解如何撰寫、規劃好的 API 架構。\n\n有趣的事情是，RESTful API 指的是一種規劃 API 的方式，嚴格來說也不一定要遵守，看看外國網站 [nodeframework](http://nodeframework.com) 的對 Express 框架的分類，相當有趣的事情是被分類到 MVC 架構中的，不過主因是 Express 主要仰賴模板來結合資料與畫面。但再次說明，RESTful API 是一種規劃 API 的觀念與方式，因此我們仍然能在 Express 框架下撰寫 RESTful API。\n\n這樣是不是緣木求魚呢？\n\n並不是的，除非只想製作單純顯示資料的網頁，也就是單向從伺服器向使用者回應資料，那並不需要 API 規劃，把頁面跟 router 規劃好即可。但往往只要稍多的 API 資料操作，就容易造成整個 router 的混亂。因此撰寫 RESTful API 就像物件導向一樣，是一種好習慣，明沒有所謂的 MVC 架構下就沒有 RESTful API 的觀念。\n\n對於 RESTful API 的討論推薦參考 [Amigo 陳兆祥](http://www.slideshare.net/AmigoChan?utm_campaign=profiletracking&utm_medium=sssite&utm_source=ssslideview) 前輩的 [slide](http://www.slideshare.net/AmigoChan/restful-api-design) 裡面觀念講解的相當詳細。\n\n## 撰寫自己的 API\n\nAPI 很難嗎？不會的，超簡單。其實大家早就會了。\n\n這是原先回應網頁給使用者的方式。\n\n``` js\nrouter.get('/home', function(req, res, next) {\n  res.render('andrew', { name: 'Andrew Chen' } ); \n});\n```\n\n改成這樣就能回應資料了，這次回應的資料是 JSON，包裝 name 這個資料\n\n``` js\nrouter.get('/getName', function(req, res, next) {\n  res.json({ name: 'Andrew Chen' });\n});\n```\n\n相當易懂，使用 `localhost:3000/home` 就能拿到 `{ name: 'Andrew Chen' }` 這筆資料了。\n\n![回應資料狀況](http://polarbearandrew.github.io/blog/img/nodeFormZero_2/node_4_1.png)\n\n但這樣並不符合需求，我們改變取得資料的方式。建立一個新的 .html 檔案。當然這個頁面以可以用 jade 撰寫，不過為了表示使用 API 並不需要是從伺服器產生的頁面，我們另外開一個。\n\n``` html \n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>RESTful AIP</title>\n\n  <!-- jQuery CDN -->\n  <script src=\"https://code.jquery.com/jquery-2.1.4.min.js\"></script>\n\n  <script>\n\n  // ajax 操作\n  $.ajax({\n    type: 'GET',\n    url: 'http://localhost:8080/getName/',\n\n    //取得資料成功觸發\n    success: function(data){\n      console.log('取得資料', data);\n    },\n\n    //失敗顯示 error\n    fail: function(err){\n      console.log('出現錯誤', err);\n    }\n  })\n  </script>\n\n</head>\n<body>\n\n  <!-- 使用者看到的畫面 -->\n  <h1> API DEMO 頁面</h1>\n\n</body>\n</html>\n```\n\n接著啟動這個頁面，就會看到在前一篇題過的 XMLHttpRequest 錯誤，這個錯誤並沒有相當大，僅僅是 server 沒有給予 ajax 操作的權限而已。\n\n![XMLHttpRequest 錯誤訊息](http://polarbearandrew.github.io/blog/img/nodeFormZero_2/node_4_2.png)\n\n解決方式如下\n\n### header 設定問題\n\n如果需要 Node.js 中設定 http header 的話，在 `app.use` 各種 router 之前補上這段，讓非本機的連線能獲得請求的許可。這種問題在日後較容易出現，因為連線的權限不足需要許可。記得是在 `app.use` 各種 router 之前補上這段，補在之後是沒有用的。\n\n``` js\n//set haeder\napp.use(function(req, res, next) {\n    res.header('Access-Control-Allow-Origin', \"*\");\n    res.header('Access-Control-Allow-Headers', 'Content-Type');\n    res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE');\n    next();\n});\n```\n\n接著就能看到 ajax 成功的取得資料。\n\n![完成的成果](http://polarbearandrew.github.io/blog/img/nodeFormZero_2/node_4_3.png)\n\n這種非同步的資料讀取方式，可以運用在很多不同的地方，舉例來說：\n\n* Google 瀏覽器的輸入建議\n* 在列表中進一步展開的詳細資訊\n* 類似 Facebook 的聊天視窗\n\n這些都是類似 ajax 的操作，當然類似功能的有 `request`、`fetch` 這些其他的功能會在日後提到，有興趣的朋友可去看看 `fetch`，最近相當火紅。稍微修改一下測試用的 html，簡易的 demo 一下 ajax 的運作狀況。\n\n``` html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>RESTful AIP</title>\n\n  <!-- jQuery CDN -->\n  <script src=\"https://code.jquery.com/jquery-2.1.4.min.js\"></script>\n\n  <script>\n\n  $('html, body').on('click', '#btn', function(){\n\n    // ajax 操作\n    $.ajax({\n      type: 'GET',\n      url: 'http://localhost:8080/getName/',\n\n      //取得資料成功觸發\n      success: function(data){\n        console.log('取得資料', data);\n        $('#show').append('Hi !' + data.name);\n      },\n\n      //失敗顯示 error\n      fail: function(err){\n        console.log('出現錯誤', err);\n        $('#show').append('找不到使用者資料')\n      }\n    })\n  });\n  </script>\n\n</head>\n<body>\n\n  <!-- 使用者看到的畫面 -->\n  <h1> API DEMO 頁面</h1>\n  <button id=\"btn\">取得資料</button>\n  <hr/>\n  <div id=\"show\"></div>\n\n</body>\n</html>\n```\n\n## 結語\n\nAPI 是使用者端跟伺服器溝通或取得資料的一種方式，下篇會介紹 Express 中的 RESTful API 操作，和各種傳遞資料的方式。\n\n如果測試 API 時每次都要撰寫新的 html 相當麻煩。有兩種解決方式，一是撰寫測試程式碼，二是用 GUI 工具 [Postman](https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop)，我個人推薦使用 Postman 先度過還不會寫測試的階段。\n\n## 參考資料\n\n* [Express](http://expressjs.com)\n* [Postman](https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop)\n* [XMLHttpRequest](https://developer.mozilla.org/zh-TW/docs/Web/API/XMLHttpRequest)","slug":"Node從零開始_05","published":1,"updated":"2015-08-25T01:26:10.000Z","layout":"post","photos":[],"link":"","_id":"ciyk03v3m000j0bu0gsl3vjwh"},{"title":"Part 4 - Express 基礎操作","date":"2015-08-18T14:30:15.000Z","comments":0,"_content":"\n![Express](https://stormpath.com/images/blog/express-and-node-opengraph.png)\n\n## 簡介\n\nExpress 是目前 Node.js 相當流行的框架之一，使用 Express 建立網頁伺服器節省掉了建置伺服器、解析請求資訊等等，相當方便，開發者只需要專心資料處理的問題即可。\n\n## 新增回應頁面\n\n以下我們需要做幾件事情，由上而下是從最簡單的頁面，到可以放入自己想要的資料的頁面：\n\n* 新增一個 express route 回應新頁面\n* 用的 jade 模板製作新頁面\n* 加入 nodemon 開發工具，加速開發\n* 在頁面中放入動態的資訊\n* 讓使用者可以只用 query string 動態修改頁面的變數\n\n首先我們打開 `myApp/routes/index.js` ，檔案內容如下：\n\n``` js\nvar express = require('express');\nvar router = express.Router();\n\n/* GET home page. */\nrouter.get('/', function(req, res, next) {\n  res.render('index', { title: 'Express' });\n});\n\nmodule.exports = router;\n```\n\n檔案中，前兩行引入了 express 的模組，並且使用了模組裡面 router 的功能。router 顧名思義就是為這個網頁伺服器建立一個路由器，解析使用者的請求，並執行所對應到的工作或是回應正確的頁面。顯而易見的註解 `/* GET home page. */` 直接說明了些下來這段程式碼是用來回應使用者網站首頁。路由器中只有一個功能 `router.get( url, callback)`，即是當使用者輸入了路徑 `url` 的話，開始執行 `callback`。而 callback 中的 `res.render('index', { title: 'Express' });` 是用來回應正確的頁面，我在後面再做解釋。這邊先解釋 router 本身運作的原理。接著我們看到最後一行，`module.exports = router;` 將路由器輸出成模組，模組在 app.js 中被載入。\n\n接下來就是 express 整個路由器運作的重點。\n\n打開 app.js 中找到第 8 行和第 25 行，因為 express-generator 有可能有不同的更新版本，行號有可能不同，因此找到以下兩行為：\n\n``` js\nvar routes = require('./routes/index');\napp.use('/', routes);\n```\n\n因為這邊 `routes` 的命名會導致後續的解釋相當饒舌，先將它改成 `pages`，用 `pages` 來逐一理解狀況。\n\n``` js\nvar pages = require('./routes/index');\napp.use('/', pages);\n```\n\n前面是引入了檔案 index.js 將其儲存在 pages 的變數中，而其實 index.js 中的最後一行是 `module.exports = router;` 輸出了 `router` 作為模組，所以這邊 `pages` 是拿到了一個 `express.Router();` 的模組。換個角度說，在 index.js 中，從 express 的模組中取用了 `express.Router();` 的路由器模組，加入取得首頁的功能後並輸出成模組。在 app.js 中透過引入這個模組拿到這個路由器的功能。\n\n為什麼要搞得這麼複雜？如果網站較為複雜，有 50 個頁面時，如果將 50 種不同的路由行為通通寫在同一個檔案中，會相當混亂，拆分路由是 express 中很重要的事情，有助於整個伺服器的結構更清晰。\n\n接著是 `app.use('/', pages);` 使用了 `pages` 剛剛載入的路由模組，而前面的 `/` 的意思是，在 pages 檔案中的路由，前面通通要接上 `/`。看看另一行更容易了解 express 的做法：`app.use('/users', users);`，載入了 `users` 這個模組，並且在前面通通接上 `/users`，即是區別 `users` 和 `pages` 這兩種操作。在設計時我們可以將針對不同對象的操作，分別放在不同的檔案中，並且在 app.js 載入時，給他們一個統一的路徑。並大幅簡化在該模組檔案中的路徑長度。\n\n以目前的狀況來說，在 index.js 中回應 home page 的這個操作，`/` 代表的是root，即是沒有接任何其他路徑的意思。透過這個路徑我們就能進行對應的操作，而此路徑對應的操作就是返回一個 express-generator 預設的歡迎頁面，使用的路徑就是：\n\n伺服器的位址 + app.js 賦予該模組的位址 + 該路由其需求的位址 = 實際發出請求的 url\n\n`http://localhost` + `/` + `/`  => `http://localhost/`\n\n舉例來說，我們可能有一個使用者登入/登出/個人檔案的頁面，那我們就可以寫成這樣，相當方便的歸類方式：\n\n`http://localhost` + `/users` + `/login`  => `http://localhost/users/login`\n\n`http://localhost` + `/users` + `/logout`  => `http://localhost/users/logout`\n\n`http://localhost` + `/users` + `/profile`  => `http://localhost/users/profile`\n\n接著我們複製並修改程式碼，讓我們能過過另一個路徑也能取得預設的首頁，在這之前可嘗試使用 `http://localhost/home` 送出請求，伺服器會回應 404 page not found。\n\n``` js\nvar express = require('express');\nvar router = express.Router();\n\n/* GET home page. */\nrouter.get('/', function(req, res, next) {\n  res.render('index', { title: 'Express' });\n});\n\n/* GET home page 2. */\nrouter.get('/home', function(req, res, next) {\n  res.render('index', { title: 'Express' });\n});\n\nmodule.exports = router;\n```\n\n在終端機按下 `ctrl + c` 中斷 Node.js server，並重新啟動 `node app.js`。接著就能透過 `http://localhost/home` 拿到預設頁面。\n\n在開發 Node.js 實需要重新啟動才能讓新的程式碼重新載入生成伺服器，但是在開發時不斷的重啟伺服器相當麻煩。Node.js 中有相當多的輔助工具可以協助開發，依照目前的需求，推薦使用一套名為 nodemon 套件， `$ npm install nodemon -g` 即可使用 `$ nodemon app.js` 啟動伺服器，而 nodemon 會在伺服器的 Javascript 檔案儲存修改時，自動重新啟動伺服器，讓我們免去手動重啟。\n\n除了 nodemon 之外，仍然有幾個相似的套件可以參考。以下兩者適用於產品發佈，個人覺得並不太適合開發時期。\n\n* [Forever](https://github.com/foreverjs/forever)\n* [PM2](https://github.com/Unitech/pm2)\n\n接著我們新增一個屬於自己的頁面，express 並不是直接回應 html 的頁面，而是編譯模板後產生 html 頁面返還給使用者。預設使用模板是 [jade](http://jade-lang.com)，jade 寫起來真的非常漂亮簡潔，帶入參數時更是方便，唯一的缺點就是在編譯的過程並不如其他模板來得快，不過在目前的需求上差異並不大。另外知名的模板有 [ejs](http://www.embeddedjs.com) ，此教學先以 jade 作為範例。請在 `myApp/views/` 下面新增一個屬於自己的 `andrew.jade` 頁面。並在裡面寫上以下內容，如果要複製以下這段程式碼，請注意排版，排版是 jade 要命脈：\n\n```\n<!DOCTYPE html>\nhtml(lang=\"en\")\nhead\n  meta(charset=\"UTF-8\")\n  title Document\nbody\n  h1 Hello world\n  p express demo\n```\n\n學習 jade 直接看官方的 Github 文件即可，相當易懂且又是中文的。[Jade-Github](https://github.com/jadejs/jade/blob/master/Readme_zh-cn.md)，jade並沒有非常難，每次縮排就是代表 html 標籤的內部子元素，往下建立新的一層子元素的意思。這邊有幾個重點需要注意，屬於常犯的 jade 錯誤：\n\n* jade 仰賴縮排編譯程式碼，因要完全正確的縮排與空白\n* 前面的縮排需要統一，使用 `tab` 或 `2個空白` 或 `4個空白`，任一種，但一定要統一\n* h1, p 內容之前，都有一個小空白，注意不要漏掉了\n\n接著我們修改 `'/home'` 這個路由，讓我們能拿到我們自己新增的頁面。\n\n``` js\nvar express = require('express');\nvar router = express.Router();\n\n/* GET home page. */\nrouter.get('/', function(req, res, next) {\n  res.render('index', { title: 'Express' });\n});\n\n/* GET my page 2. */\nrouter.get('/home', function(req, res, next) {\n  res.render('andrew'); //andrew 為檔案名稱\n});\n\nmodule.exports = router;\n```\n`res.render('andrew');` 的功能及時回傳 `andrew` 這個頁面。express 會在 views 的資料夾中找到 `andrew.jade` 的頁面。接著就瀏覽器會顯示 h1 大小的 Hello World 和一般的 express demo，正確顯示的話就能進行到下一步。\n\n接著我們要對這個頁面傳入參數，傳入的方式其實在取得 home page 的方式中已經多少有點提示：\n\n``` js\n/* GET my page 2. */\nrouter.get('/home', function(req, res, next) {\n  res.render('andrew', { name: 'Andrew Chen'} );\n});\n```\n\n```\n<!DOCTYPE html>\nhtml(lang=\"en\")\nhead\n  meta(charset=\"UTF-8\")\n  title Document\nbody\n  h1= name\n  p express demo\n```\n\n以 JOSN 的格式包裝資料，丟在第二個參數傳進去後可以直接使用對應變數名稱在 .jade 中打開，修改後的效果會顯示 h1 大小的 Andrew Chen 和一般的 express demo。當然 express demo 也可換成自己想要的字串。到目前為止的技術已經足夠創造一個基礎的靜態網頁伺服器了。\n\n接著我們來說明如何從使用者端訊息到伺服器端，最簡易的傳送方式就是 `GET`，使用 query string 要傳送方式，將 url 改成 `http://localhost:3000/home?name=Andrew` 可以透過 query string 將 `Andrew` 這個字串傳送到伺服器端。在伺服器端承接 query string 的參數的方式為：\n\n``` js\n/* GET my page 2. */\nrouter.get('/home', function(req, res, next) {\n  var name = req.query.name; //取得queryString的資料\n  res.render('andrew', { name: name}); // 再將 name 當成資料傳給 .jade\n});\n```\n\n```\n<!DOCTYPE html>\nhtml(lang=\"en\")\nhead\n  meta(charset=\"UTF-8\")\n  title Document\nbody\n  h1= 'Hi! ' + name\n  p express demo\n```\n\n`req` 在這邊代表 request，請求的意思。代表客戶端的請求，請求中的 `query` 所夾帶的 `name` 的參數。目前的畫面如下，除了字體很醜之外，沒什麼大問題了。\n\n![目前成果](http://polarbearandrew.github.io/blog/img/nodeFormZero_2/node_3_1.png)\n\n常用的資料傳遞操作的方式還有幾種，將會在下一章節撰寫 API 時逐一介紹。\n\n## Express middleware\n\nExpress middleware 是用來撰寫每個網頁的請求都需要執行的功能，可以想像成 \"中間人\"，所有的 router 檢查時都會路過這個 function，而在執行這個 function 後會繼續檢查並尋找原先請求的路徑。直接看範例相當清楚：\n\n``` js\nvar express = require('express');\nvar router = express.Router();\n\n// I am middleware !\nrouter.use( function(req, res, next){\n  console.log('middleware in index.js');\n  next();\n});\n\n/* GET home page. */\nrouter.get('/', function(req, res, next) {\n  res.render('index', { title: 'Express' });\n});\n\n/* GET my page 2. */\nrouter.get('/home', function(req, res, next) {\n  res.render('andrew', { name: 'Andrew Chen' } ); //andrew 為檔案名稱\n});\nmodule.exports = router;\n```\n\n接著去看終端機中的 log，會發現 'middleware in index.js' 先被顯示出來，伺服器才回應這個頁面。Middleware 可以用來做實作登入檢查機制或是身任認證。例如使用到某些特定的功能，那在整個 router 下的操作都需要檢查，那可以先透過 middleware 先檢查後在執行。\n\n那如果是一般的路由請求中使用 `next()` 這個操作，把自己當作中間人，下一個人會是誰？下一個是用來承接錯誤的 function，通常用來承接找尋不到指定頁面或是伺服器運算錯誤的狀況，就出現在 app.js 中。\n\n``` js\n// production error handler\n// no stacktraces leaked to user\napp.use(function(err, req, res, next) {\n    res.status(err.status || 500);\n    res.render('error', {\n        message: err.message,\n        error: {}\n    });\n});\n```\n\n這段程式碼就是在最終，如果上方所有的路由都找尋不到指定頁面，就會進入到這個 function，他會回覆使用者 404 not found 的訊息。\n\n## header 設定問題\n\n如果需要 Node.js 中設定 http header 的話，在 `app.use` 各種 router 之前補上這段，讓非本機的連線能獲得請求的許可。這種問題在日後較容易出現，因為連線的權限不足需要許可。這種設定方式也是利用 Middleware 的特性，讓每個請求都能擁有這些 header 的設定。\n\n![XMLHttpRequest 錯誤訊息](http://polarbearandrew.github.io/blog/img/nodeFormZero_2/node_4_2.png)\n\n解決的設定方式如下，記得是在 `app.use` 各種 router 之前補上這段。\n\n``` js\n//set haeder\napp.use(function(req, res, next) {\n    res.header('Access-Control-Allow-Origin', \"*\");\n    res.header('Access-Control-Allow-Headers', 'Content-Type');\n    res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE');\n    next();\n});\n```\n\n## 結語\n\nexpress 擁有對絕大多數網頁伺服器所需要的操作，大幅了簡化開發的難度，上述的 query string 和 router 完全不需要擔心操作請求字串的解析，輕鬆的就能取得參數和回傳頁面，透過這些基礎的功能，就能建立起一個簡易的網頁伺服器。善用 express 模組能撰寫自己的 API 與資料庫連線，就學會一套相當完整的網頁伺服器。\n","source":"_posts/Node從零開始_04.md","raw":"title: Part 4 - express 基礎操作\ndate: 2015-08-18 22:30:15\ntags:\n- Node.js\n- Node.js 從零開始\n- JavaScript\ncategories: Node.js 從零開始\ncomments: false\n---\n\n![Express](https://stormpath.com/images/blog/express-and-node-opengraph.png)\n\n## 簡介\n\nExpress 是目前 Node.js 相當流行的框架之一，使用 Express 建立網頁伺服器節省掉了建置伺服器、解析請求資訊等等，相當方便，開發者只需要專心資料處理的問題即可。\n\n## 新增回應頁面\n\n以下我們需要做幾件事情，由上而下是從最簡單的頁面，到可以放入自己想要的資料的頁面：\n\n* 新增一個 express route 回應新頁面\n* 用的 jade 模板製作新頁面\n* 加入 nodemon 開發工具，加速開發\n* 在頁面中放入動態的資訊\n* 讓使用者可以只用 query string 動態修改頁面的變數\n\n首先我們打開 `myApp/routes/index.js` ，檔案內容如下：\n\n``` js\nvar express = require('express');\nvar router = express.Router();\n\n/* GET home page. */\nrouter.get('/', function(req, res, next) {\n  res.render('index', { title: 'Express' });\n});\n\nmodule.exports = router;\n```\n\n檔案中，前兩行引入了 express 的模組，並且使用了模組裡面 router 的功能。router 顧名思義就是為這個網頁伺服器建立一個路由器，解析使用者的請求，並執行所對應到的工作或是回應正確的頁面。顯而易見的註解 `/* GET home page. */` 直接說明了些下來這段程式碼是用來回應使用者網站首頁。路由器中只有一個功能 `router.get( url, callback)`，即是當使用者輸入了路徑 `url` 的話，開始執行 `callback`。而 callback 中的 `res.render('index', { title: 'Express' });` 是用來回應正確的頁面，我在後面再做解釋。這邊先解釋 router 本身運作的原理。接著我們看到最後一行，`module.exports = router;` 將路由器輸出成模組，模組在 app.js 中被載入。\n\n接下來就是 express 整個路由器運作的重點。\n\n打開 app.js 中找到第 8 行和第 25 行，因為 express-generator 有可能有不同的更新版本，行號有可能不同，因此找到以下兩行為：\n\n``` js\nvar routes = require('./routes/index');\napp.use('/', routes);\n```\n\n因為這邊 `routes` 的命名會導致後續的解釋相當饒舌，先將它改成 `pages`，用 `pages` 來逐一理解狀況。\n\n``` js\nvar pages = require('./routes/index');\napp.use('/', pages);\n```\n\n前面是引入了檔案 index.js 將其儲存在 pages 的變數中，而其實 index.js 中的最後一行是 `module.exports = router;` 輸出了 `router` 作為模組，所以這邊 `pages` 是拿到了一個 `express.Router();` 的模組。換個角度說，在 index.js 中，從 express 的模組中取用了 `express.Router();` 的路由器模組，加入取得首頁的功能後並輸出成模組。在 app.js 中透過引入這個模組拿到這個路由器的功能。\n\n為什麼要搞得這麼複雜？如果網站較為複雜，有 50 個頁面時，如果將 50 種不同的路由行為通通寫在同一個檔案中，會相當混亂，拆分路由是 express 中很重要的事情，有助於整個伺服器的結構更清晰。\n\n接著是 `app.use('/', pages);` 使用了 `pages` 剛剛載入的路由模組，而前面的 `/` 的意思是，在 pages 檔案中的路由，前面通通要接上 `/`。看看另一行更容易了解 express 的做法：`app.use('/users', users);`，載入了 `users` 這個模組，並且在前面通通接上 `/users`，即是區別 `users` 和 `pages` 這兩種操作。在設計時我們可以將針對不同對象的操作，分別放在不同的檔案中，並且在 app.js 載入時，給他們一個統一的路徑。並大幅簡化在該模組檔案中的路徑長度。\n\n以目前的狀況來說，在 index.js 中回應 home page 的這個操作，`/` 代表的是root，即是沒有接任何其他路徑的意思。透過這個路徑我們就能進行對應的操作，而此路徑對應的操作就是返回一個 express-generator 預設的歡迎頁面，使用的路徑就是：\n\n伺服器的位址 + app.js 賦予該模組的位址 + 該路由其需求的位址 = 實際發出請求的 url\n\n`http://localhost` + `/` + `/`  => `http://localhost/`\n\n舉例來說，我們可能有一個使用者登入/登出/個人檔案的頁面，那我們就可以寫成這樣，相當方便的歸類方式：\n\n`http://localhost` + `/users` + `/login`  => `http://localhost/users/login`\n\n`http://localhost` + `/users` + `/logout`  => `http://localhost/users/logout`\n\n`http://localhost` + `/users` + `/profile`  => `http://localhost/users/profile`\n\n接著我們複製並修改程式碼，讓我們能過過另一個路徑也能取得預設的首頁，在這之前可嘗試使用 `http://localhost/home` 送出請求，伺服器會回應 404 page not found。\n\n``` js\nvar express = require('express');\nvar router = express.Router();\n\n/* GET home page. */\nrouter.get('/', function(req, res, next) {\n  res.render('index', { title: 'Express' });\n});\n\n/* GET home page 2. */\nrouter.get('/home', function(req, res, next) {\n  res.render('index', { title: 'Express' });\n});\n\nmodule.exports = router;\n```\n\n在終端機按下 `ctrl + c` 中斷 Node.js server，並重新啟動 `node app.js`。接著就能透過 `http://localhost/home` 拿到預設頁面。\n\n在開發 Node.js 實需要重新啟動才能讓新的程式碼重新載入生成伺服器，但是在開發時不斷的重啟伺服器相當麻煩。Node.js 中有相當多的輔助工具可以協助開發，依照目前的需求，推薦使用一套名為 nodemon 套件， `$ npm install nodemon -g` 即可使用 `$ nodemon app.js` 啟動伺服器，而 nodemon 會在伺服器的 Javascript 檔案儲存修改時，自動重新啟動伺服器，讓我們免去手動重啟。\n\n除了 nodemon 之外，仍然有幾個相似的套件可以參考。以下兩者適用於產品發佈，個人覺得並不太適合開發時期。\n\n* [Forever](https://github.com/foreverjs/forever)\n* [PM2](https://github.com/Unitech/pm2)\n\n接著我們新增一個屬於自己的頁面，express 並不是直接回應 html 的頁面，而是編譯模板後產生 html 頁面返還給使用者。預設使用模板是 [jade](http://jade-lang.com)，jade 寫起來真的非常漂亮簡潔，帶入參數時更是方便，唯一的缺點就是在編譯的過程並不如其他模板來得快，不過在目前的需求上差異並不大。另外知名的模板有 [ejs](http://www.embeddedjs.com) ，此教學先以 jade 作為範例。請在 `myApp/views/` 下面新增一個屬於自己的 `andrew.jade` 頁面。並在裡面寫上以下內容，如果要複製以下這段程式碼，請注意排版，排版是 jade 要命脈：\n\n```\n<!DOCTYPE html>\nhtml(lang=\"en\")\nhead\n  meta(charset=\"UTF-8\")\n  title Document\nbody\n  h1 Hello world\n  p express demo\n```\n\n學習 jade 直接看官方的 Github 文件即可，相當易懂且又是中文的。[Jade-Github](https://github.com/jadejs/jade/blob/master/Readme_zh-cn.md)，jade並沒有非常難，每次縮排就是代表 html 標籤的內部子元素，往下建立新的一層子元素的意思。這邊有幾個重點需要注意，屬於常犯的 jade 錯誤：\n\n* jade 仰賴縮排編譯程式碼，因要完全正確的縮排與空白\n* 前面的縮排需要統一，使用 `tab` 或 `2個空白` 或 `4個空白`，任一種，但一定要統一\n* h1, p 內容之前，都有一個小空白，注意不要漏掉了\n\n接著我們修改 `'/home'` 這個路由，讓我們能拿到我們自己新增的頁面。\n\n``` js\nvar express = require('express');\nvar router = express.Router();\n\n/* GET home page. */\nrouter.get('/', function(req, res, next) {\n  res.render('index', { title: 'Express' });\n});\n\n/* GET my page 2. */\nrouter.get('/home', function(req, res, next) {\n  res.render('andrew'); //andrew 為檔案名稱\n});\n\nmodule.exports = router;\n```\n`res.render('andrew');` 的功能及時回傳 `andrew` 這個頁面。express 會在 views 的資料夾中找到 `andrew.jade` 的頁面。接著就瀏覽器會顯示 h1 大小的 Hello World 和一般的 express demo，正確顯示的話就能進行到下一步。\n\n接著我們要對這個頁面傳入參數，傳入的方式其實在取得 home page 的方式中已經多少有點提示：\n\n``` js\n/* GET my page 2. */\nrouter.get('/home', function(req, res, next) {\n  res.render('andrew', { name: 'Andrew Chen'} );\n});\n```\n\n```\n<!DOCTYPE html>\nhtml(lang=\"en\")\nhead\n  meta(charset=\"UTF-8\")\n  title Document\nbody\n  h1= name\n  p express demo\n```\n\n以 JOSN 的格式包裝資料，丟在第二個參數傳進去後可以直接使用對應變數名稱在 .jade 中打開，修改後的效果會顯示 h1 大小的 Andrew Chen 和一般的 express demo。當然 express demo 也可換成自己想要的字串。到目前為止的技術已經足夠創造一個基礎的靜態網頁伺服器了。\n\n接著我們來說明如何從使用者端訊息到伺服器端，最簡易的傳送方式就是 `GET`，使用 query string 要傳送方式，將 url 改成 `http://localhost:3000/home?name=Andrew` 可以透過 query string 將 `Andrew` 這個字串傳送到伺服器端。在伺服器端承接 query string 的參數的方式為：\n\n``` js\n/* GET my page 2. */\nrouter.get('/home', function(req, res, next) {\n  var name = req.query.name; //取得queryString的資料\n  res.render('andrew', { name: name}); // 再將 name 當成資料傳給 .jade\n});\n```\n\n```\n<!DOCTYPE html>\nhtml(lang=\"en\")\nhead\n  meta(charset=\"UTF-8\")\n  title Document\nbody\n  h1= 'Hi! ' + name\n  p express demo\n```\n\n`req` 在這邊代表 request，請求的意思。代表客戶端的請求，請求中的 `query` 所夾帶的 `name` 的參數。目前的畫面如下，除了字體很醜之外，沒什麼大問題了。\n\n![目前成果](http://polarbearandrew.github.io/blog/img/nodeFormZero_2/node_3_1.png)\n\n常用的資料傳遞操作的方式還有幾種，將會在下一章節撰寫 API 時逐一介紹。\n\n## Express middleware\n\nExpress middleware 是用來撰寫每個網頁的請求都需要執行的功能，可以想像成 \"中間人\"，所有的 router 檢查時都會路過這個 function，而在執行這個 function 後會繼續檢查並尋找原先請求的路徑。直接看範例相當清楚：\n\n``` js\nvar express = require('express');\nvar router = express.Router();\n\n// I am middleware !\nrouter.use( function(req, res, next){\n  console.log('middleware in index.js');\n  next();\n});\n\n/* GET home page. */\nrouter.get('/', function(req, res, next) {\n  res.render('index', { title: 'Express' });\n});\n\n/* GET my page 2. */\nrouter.get('/home', function(req, res, next) {\n  res.render('andrew', { name: 'Andrew Chen' } ); //andrew 為檔案名稱\n});\nmodule.exports = router;\n```\n\n接著去看終端機中的 log，會發現 'middleware in index.js' 先被顯示出來，伺服器才回應這個頁面。Middleware 可以用來做實作登入檢查機制或是身任認證。例如使用到某些特定的功能，那在整個 router 下的操作都需要檢查，那可以先透過 middleware 先檢查後在執行。\n\n那如果是一般的路由請求中使用 `next()` 這個操作，把自己當作中間人，下一個人會是誰？下一個是用來承接錯誤的 function，通常用來承接找尋不到指定頁面或是伺服器運算錯誤的狀況，就出現在 app.js 中。\n\n``` js\n// production error handler\n// no stacktraces leaked to user\napp.use(function(err, req, res, next) {\n    res.status(err.status || 500);\n    res.render('error', {\n        message: err.message,\n        error: {}\n    });\n});\n```\n\n這段程式碼就是在最終，如果上方所有的路由都找尋不到指定頁面，就會進入到這個 function，他會回覆使用者 404 not found 的訊息。\n\n## header 設定問題\n\n如果需要 Node.js 中設定 http header 的話，在 `app.use` 各種 router 之前補上這段，讓非本機的連線能獲得請求的許可。這種問題在日後較容易出現，因為連線的權限不足需要許可。這種設定方式也是利用 Middleware 的特性，讓每個請求都能擁有這些 header 的設定。\n\n![XMLHttpRequest 錯誤訊息](http://polarbearandrew.github.io/blog/img/nodeFormZero_2/node_4_2.png)\n\n解決的設定方式如下，記得是在 `app.use` 各種 router 之前補上這段。\n\n``` js\n//set haeder\napp.use(function(req, res, next) {\n    res.header('Access-Control-Allow-Origin', \"*\");\n    res.header('Access-Control-Allow-Headers', 'Content-Type');\n    res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE');\n    next();\n});\n```\n\n## 結語\n\nexpress 擁有對絕大多數網頁伺服器所需要的操作，大幅了簡化開發的難度，上述的 query string 和 router 完全不需要擔心操作請求字串的解析，輕鬆的就能取得參數和回傳頁面，透過這些基礎的功能，就能建立起一個簡易的網頁伺服器。善用 express 模組能撰寫自己的 API 與資料庫連線，就學會一套相當完整的網頁伺服器。\n","slug":"Node從零開始_04","published":1,"updated":"2015-09-25T10:10:52.000Z","layout":"post","photos":[],"link":"","_id":"ciyk03v3p000o0bu0udhfp3xb"},{"title":"Part 3 - NPM 基礎","date":"2015-08-15T13:55:00.000Z","comments":0,"_content":"\n<center>\n![NPM](https://www.npmjs.com/static/images/wombat-by-night.svg)\n</center>\n\n前一篇提到的 [NPM](https://www.npmjs.com) ，是 Node.js 運作中最重要的一個環節， Node.js 仰賴 NPM 進行套件整理並安裝，包含了基本安裝、相依性安裝、指定版本安裝等等，簡而言之 NPM 處理所有我們在 Node.js 開發時跟套件相關的基本操作，同時也讓 Node.js 的模組得以快速發展。\n\n介紹 NPM 主要有幾個重點：\n\n* NPM 的 package.json\n* 透過 NPM 安裝套件\n* 爲專案設定專用指令\n\n## package.json\n\npackage.json 是 npm 最重要的核心，每個專案都會擁有一個 package.josn 的檔案，目前 express-generator 產生的看起來是這樣：\n\n``` josn\n{\n  \"name\": \"myApp\",\n  \"version\": \"0.0.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"start\": \"node ./bin/www\"\n  },\n  \"dependencies\": {\n    \"body-parser\": \"~1.10.2\",\n    \"cookie-parser\": \"~1.3.3\",\n    \"debug\": \"~2.1.1\",\n    \"express\": \"~4.11.1\",\n    \"jade\": \"~1.9.1\",\n    \"morgan\": \"~1.5.1\",\n    \"serve-favicon\": \"~2.2.0\"\n  }\n}\n```\n\n在第一層的目錄就能找到，如果不使用 express-generator，當然也可以用 `npm init` 去自行初始化 package.json，指令會一步一步的引導完成。逐一解釋 package.json 裡面的參數，`name` `version` `private`，分別是使用者可以自行設定的參數，並不會直接影響專案的運行。 `script` 我們後面在介紹。接著是紀錄在 package.json中的相依性的資訊，除了現在看到的 dependencies 外還有 Devdependencies，差異為：\n\n* dependencies：啟動時，必要的相依性套件\n* Devdependencies：開發時，必要的相依性套件，通常是輔助工具。\n\n下面會教如何自動產生這段訊息，當然也可以自己手動補上資訊，然後讓 npm 讀取 package.json 再一次安裝(手動並沒有比較方便)。\n\n## 使用 NPM 安裝模組(套件)\n\n在上一篇 \"Node.js從零開始\" 的教學中已經用過了某些 `npm install` 的指令但並沒有詳細介紹。以下為指令做逐一的詳細解釋，別急著看第一種就使用，建議看完後尋找適當且符合情況的指令來使用。\n\n1. 基本安裝\n\n\t`$ npm install <套件名稱>` 指令會在目前的目錄下安裝指定的 `<套件名稱>` 套件。範例如下：\n\n\t``` bat\n\t$ npm install express\n\t```\n\n\t安裝完成的套件會出現在 `node_modules` 的資料夾內。\n\n2. 安裝指定版本\n\n\t`$ npm install <套件名稱>@<版本號碼>` 指令會在目前的目錄下安裝指定 `<版本號碼>` 版本的 `<套件名稱>`套件。請注意中間有一個 `@` 的符號喔。範例如下：\n\n\t``` bat\n\t$ npm install express@4.11.1\n\t```\n\n\t如果你非常清楚版本的差異，想要用指定的版本，可以設定一個區間：\n\n\t``` bat\n\t$ npm install express@\">=1.0.0 <2.0.0\"\n\t```\n\n\t一般來說，不需要指定版本，或是指定單一版本即可正確的安裝。較少的情況會使用到指定版本區間的指令。另外，如果沒有指定版本，使用一般的 `npm install` ，NPM 會聰明地選擇當下 Node.js 版本能相容的最新版本。\n\n3. 安裝為全域套件\n\n\t全域套件顧名思義，與全域變數的概念雷同，全域套件並不會出現在專案中，以下以兩種狀況會安裝全域套件：\n\n\t* 以後會頻繁使用的套件\n\t* 與專案本身無關的套件\n\n\t就以 express-generator 來說， generator 其實是與專案無關的，僅僅進行專案初始化的動作，初始化完成後其實並不需要 express-generator 才能運轉，所以在 \"相依性套件\" 的思考上，建置完成的專案並不依賴 express-generator，也就是沒有 express-generator 專案也能啟動。此時我會選擇將 express-generator 安裝在全域，全域安裝其實是安裝在  `node/bin` 的資料夾下。全域安裝的模組可以在許多專案間可以共用、重複使用，例如某些 babel 的套件也是此情況。而會重複使用的套件，同樣是 express-generator 可以協助我初始化不同的專案，基於方便，一次安裝為全域套件即可，不需要在每次初始化專案時就重新安裝 express-generator。\n\t\n\t備註：某些套件本身就會要求使用全域安裝，如：[nodemon](https://www.npmjs.com/package/nodemon)\n\n\t安裝全域套件相當簡單：`npm install <套件名稱> -g`，在尾端接上 `-g` 代表 global 的參數即可。\n\n\t``` bat\n\t$ npm install express-generator -g\n\t```\n\n\t`-g` 可以跟安裝指定版本的方式混用，並不衝突，同樣是在後方接上 `-g` 的參數即可。通常全域安裝會需要 `sudo` 的加持，才會有足夠的權限，因為 Node.js 本身是裝在系統資料夾下面。\n\n4. 安裝並儲存在 package.json 中\n\n\t紀錄相依性的資訊在 package.json 中，分為一般的 dependencies 和 Devdependencies，差異為：\n\n\t* dependencies：啟動時，必要的相依性套件\n\t* Devdependencies：開發時，必要的相依性套件，通常是輔助工具。\n\n\t為什麼需要將資訊儲存在 package.json 中，主要原因是在於團隊開發時，會使用版本控管來同步各個成員之間的進度，而將套件內容列入版本監控內，不僅僅不利於網路傳輸，也會拖慢動態監控的速度。一般會在 package.json 中紀錄清楚使用了哪些套件，其他成員僅需要一次性的安裝即可，這樣可以大幅降低版本控管系統的負擔。此舉動其實在使用 express-generator 時已經發生過，express-generator 僅會產生適當的 package.json，並沒有幫我們下載對應的模組，\n\n\t指令為 `$ npm install <package name> --save` 和 `$ npm install <package name> --save-dev`\n\n\t``` bat\n\t$ npm install express --save  // dependencies\n\t$ npm install gulp --save-dev // Devdependencies\n\t```\n\n5. 自動安裝 package.json 中所有的相依性套件\n\n\t相當直接的指令。npm 會自行尋找目錄下的 package.json 檔案，並且進行安裝。\n\n\t``` bat\n\t$ npm install\n\t```\n\n\t這邊大家應該會多少有點納悶，如果擁有使用 Git 的經驗，那請在專案的最頂層的資料夾(root),新增 `.gitignore` 這個檔案，的確直接新增即可，整個檔案名稱及是 `.gitignore` ，接著在裡面打上 `node_modules` 排除 Git 追蹤 node_modules 的資料夾，這樣在同步時就可上去 node_modules 的內容了。\n\n## 什麼是模組、套件\n\n在 NPM 裡面非常明顯的大量使用了別人撰寫的套件與模組，那這些東西又是什麼？聽起來相當困難？\n\n其實模組只是其他高手已經寫好的 JavaScript 檔案而已，經過正規的包裝，大家可以透過 NPM 的系統下載。使用 Node.js 架設伺服器需要寫很多程式碼，就有高手們推出了 Express 的模組，包裝好網頁伺服器的程式碼，讓一般開發者能順手順心的使用。這邊淺談 Node.js 的模組運作機制。\n\n首先我們找個新的資料夾，開一個新的 `demo.js` 的檔案，在裡面寫下：\n\n``` js\n//demo.js\nconsole.log('Demo start');\n```\n\n我們先使用 `$ node demo.js` 測試一下，如果有看到 Demo start 的訊息，就可以繼續往下。再開另一個新的檔案，`message.js` 的檔案，寫下：\n\n``` js\n//message.js\nvar message = {\n  show : function(){\n    console.log('hello world !');\n  }\n}\n\nmodule.exports = message;\n```\n\n建立一個 message 的物件，並且包裝了 show 的 function 在內，特別的地方是最後 `module.exports = message` 的動作，他將 message 的物件輸出成 Node.js 能理解的模組，僅僅多這行，就能將過往我們熟悉的 Javascript 模組化。接著我們回頭去修改 demo.js 讓它引入並且使用這個我們自己製作的模組。\n\n``` js\n//demo.js\nconsole.log('Demo start');\n\n//引入模組\nvar msg = require('./message.js'); \nmsg.show();\n```\n\n接著去操作 `$ node demo.js` 的指令，這次就會多看到 hello world ! 的訊息了！模組其實挺直觀的，當然 NPM 上大家時常使用的模組，裡面都包裝了相當複雜的邏輯或是功能，幫助大家解決各種問題。\n\n備註：引入模組時的路徑是撰寫 './message.js' 而不是 'message.js'，差異相當大：\n\n* 'message.js' 代表 Node.js 會去 node_modules 裡面尋找名為 message.js 的模組，想當然爾找不到。\n* './message.js' 代表 Node.js 會在相對路徑下尋找模組，也就會尋找到 message.js 這個檔案。\n\n請注意這兩者的差別，這是容易犯的小差錯。\n\n## 結語\n\nNPM 是撐起整個 Node.js 世界的大引擎，有優良的套件協助大家工作，才會吸引更多開發者加入 Node.js 的行列，最明顯的例子就是 Ruby，Ruby 在 Ruby on Rail 出現後瞬間人氣高漲，良好的社群或是模組支援，會對其造成一定程度的影響。\n\n對以上的 NPM 指令只要稍作熟悉，以後在專案流程中不時會需要增補一功能，當然有朝一日，也能參與 Node.js 的模組開法，推出屬於自己的模組。\n","source":"_posts/Node從零開始_03.md","raw":"title: Part 3 - NPM 基礎\ndate: 2015-08-15 21:55:00\ntags:\n- Node.js\n- Node.js 從零開始\n- JavaScript\ncategories: Node.js 從零開始\ncomments: false\n---\n\n<center>\n![NPM](https://www.npmjs.com/static/images/wombat-by-night.svg)\n</center>\n\n前一篇提到的 [NPM](https://www.npmjs.com) ，是 Node.js 運作中最重要的一個環節， Node.js 仰賴 NPM 進行套件整理並安裝，包含了基本安裝、相依性安裝、指定版本安裝等等，簡而言之 NPM 處理所有我們在 Node.js 開發時跟套件相關的基本操作，同時也讓 Node.js 的模組得以快速發展。\n\n介紹 NPM 主要有幾個重點：\n\n* NPM 的 package.json\n* 透過 NPM 安裝套件\n* 爲專案設定專用指令\n\n## package.json\n\npackage.json 是 npm 最重要的核心，每個專案都會擁有一個 package.josn 的檔案，目前 express-generator 產生的看起來是這樣：\n\n``` josn\n{\n  \"name\": \"myApp\",\n  \"version\": \"0.0.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"start\": \"node ./bin/www\"\n  },\n  \"dependencies\": {\n    \"body-parser\": \"~1.10.2\",\n    \"cookie-parser\": \"~1.3.3\",\n    \"debug\": \"~2.1.1\",\n    \"express\": \"~4.11.1\",\n    \"jade\": \"~1.9.1\",\n    \"morgan\": \"~1.5.1\",\n    \"serve-favicon\": \"~2.2.0\"\n  }\n}\n```\n\n在第一層的目錄就能找到，如果不使用 express-generator，當然也可以用 `npm init` 去自行初始化 package.json，指令會一步一步的引導完成。逐一解釋 package.json 裡面的參數，`name` `version` `private`，分別是使用者可以自行設定的參數，並不會直接影響專案的運行。 `script` 我們後面在介紹。接著是紀錄在 package.json中的相依性的資訊，除了現在看到的 dependencies 外還有 Devdependencies，差異為：\n\n* dependencies：啟動時，必要的相依性套件\n* Devdependencies：開發時，必要的相依性套件，通常是輔助工具。\n\n下面會教如何自動產生這段訊息，當然也可以自己手動補上資訊，然後讓 npm 讀取 package.json 再一次安裝(手動並沒有比較方便)。\n\n## 使用 NPM 安裝模組(套件)\n\n在上一篇 \"Node.js從零開始\" 的教學中已經用過了某些 `npm install` 的指令但並沒有詳細介紹。以下為指令做逐一的詳細解釋，別急著看第一種就使用，建議看完後尋找適當且符合情況的指令來使用。\n\n1. 基本安裝\n\n\t`$ npm install <套件名稱>` 指令會在目前的目錄下安裝指定的 `<套件名稱>` 套件。範例如下：\n\n\t``` bat\n\t$ npm install express\n\t```\n\n\t安裝完成的套件會出現在 `node_modules` 的資料夾內。\n\n2. 安裝指定版本\n\n\t`$ npm install <套件名稱>@<版本號碼>` 指令會在目前的目錄下安裝指定 `<版本號碼>` 版本的 `<套件名稱>`套件。請注意中間有一個 `@` 的符號喔。範例如下：\n\n\t``` bat\n\t$ npm install express@4.11.1\n\t```\n\n\t如果你非常清楚版本的差異，想要用指定的版本，可以設定一個區間：\n\n\t``` bat\n\t$ npm install express@\">=1.0.0 <2.0.0\"\n\t```\n\n\t一般來說，不需要指定版本，或是指定單一版本即可正確的安裝。較少的情況會使用到指定版本區間的指令。另外，如果沒有指定版本，使用一般的 `npm install` ，NPM 會聰明地選擇當下 Node.js 版本能相容的最新版本。\n\n3. 安裝為全域套件\n\n\t全域套件顧名思義，與全域變數的概念雷同，全域套件並不會出現在專案中，以下以兩種狀況會安裝全域套件：\n\n\t* 以後會頻繁使用的套件\n\t* 與專案本身無關的套件\n\n\t就以 express-generator 來說， generator 其實是與專案無關的，僅僅進行專案初始化的動作，初始化完成後其實並不需要 express-generator 才能運轉，所以在 \"相依性套件\" 的思考上，建置完成的專案並不依賴 express-generator，也就是沒有 express-generator 專案也能啟動。此時我會選擇將 express-generator 安裝在全域，全域安裝其實是安裝在  `node/bin` 的資料夾下。全域安裝的模組可以在許多專案間可以共用、重複使用，例如某些 babel 的套件也是此情況。而會重複使用的套件，同樣是 express-generator 可以協助我初始化不同的專案，基於方便，一次安裝為全域套件即可，不需要在每次初始化專案時就重新安裝 express-generator。\n\t\n\t備註：某些套件本身就會要求使用全域安裝，如：[nodemon](https://www.npmjs.com/package/nodemon)\n\n\t安裝全域套件相當簡單：`npm install <套件名稱> -g`，在尾端接上 `-g` 代表 global 的參數即可。\n\n\t``` bat\n\t$ npm install express-generator -g\n\t```\n\n\t`-g` 可以跟安裝指定版本的方式混用，並不衝突，同樣是在後方接上 `-g` 的參數即可。通常全域安裝會需要 `sudo` 的加持，才會有足夠的權限，因為 Node.js 本身是裝在系統資料夾下面。\n\n4. 安裝並儲存在 package.json 中\n\n\t紀錄相依性的資訊在 package.json 中，分為一般的 dependencies 和 Devdependencies，差異為：\n\n\t* dependencies：啟動時，必要的相依性套件\n\t* Devdependencies：開發時，必要的相依性套件，通常是輔助工具。\n\n\t為什麼需要將資訊儲存在 package.json 中，主要原因是在於團隊開發時，會使用版本控管來同步各個成員之間的進度，而將套件內容列入版本監控內，不僅僅不利於網路傳輸，也會拖慢動態監控的速度。一般會在 package.json 中紀錄清楚使用了哪些套件，其他成員僅需要一次性的安裝即可，這樣可以大幅降低版本控管系統的負擔。此舉動其實在使用 express-generator 時已經發生過，express-generator 僅會產生適當的 package.json，並沒有幫我們下載對應的模組，\n\n\t指令為 `$ npm install <package name> --save` 和 `$ npm install <package name> --save-dev`\n\n\t``` bat\n\t$ npm install express --save  // dependencies\n\t$ npm install gulp --save-dev // Devdependencies\n\t```\n\n5. 自動安裝 package.json 中所有的相依性套件\n\n\t相當直接的指令。npm 會自行尋找目錄下的 package.json 檔案，並且進行安裝。\n\n\t``` bat\n\t$ npm install\n\t```\n\n\t這邊大家應該會多少有點納悶，如果擁有使用 Git 的經驗，那請在專案的最頂層的資料夾(root),新增 `.gitignore` 這個檔案，的確直接新增即可，整個檔案名稱及是 `.gitignore` ，接著在裡面打上 `node_modules` 排除 Git 追蹤 node_modules 的資料夾，這樣在同步時就可上去 node_modules 的內容了。\n\n## 什麼是模組、套件\n\n在 NPM 裡面非常明顯的大量使用了別人撰寫的套件與模組，那這些東西又是什麼？聽起來相當困難？\n\n其實模組只是其他高手已經寫好的 JavaScript 檔案而已，經過正規的包裝，大家可以透過 NPM 的系統下載。使用 Node.js 架設伺服器需要寫很多程式碼，就有高手們推出了 Express 的模組，包裝好網頁伺服器的程式碼，讓一般開發者能順手順心的使用。這邊淺談 Node.js 的模組運作機制。\n\n首先我們找個新的資料夾，開一個新的 `demo.js` 的檔案，在裡面寫下：\n\n``` js\n//demo.js\nconsole.log('Demo start');\n```\n\n我們先使用 `$ node demo.js` 測試一下，如果有看到 Demo start 的訊息，就可以繼續往下。再開另一個新的檔案，`message.js` 的檔案，寫下：\n\n``` js\n//message.js\nvar message = {\n  show : function(){\n    console.log('hello world !');\n  }\n}\n\nmodule.exports = message;\n```\n\n建立一個 message 的物件，並且包裝了 show 的 function 在內，特別的地方是最後 `module.exports = message` 的動作，他將 message 的物件輸出成 Node.js 能理解的模組，僅僅多這行，就能將過往我們熟悉的 Javascript 模組化。接著我們回頭去修改 demo.js 讓它引入並且使用這個我們自己製作的模組。\n\n``` js\n//demo.js\nconsole.log('Demo start');\n\n//引入模組\nvar msg = require('./message.js'); \nmsg.show();\n```\n\n接著去操作 `$ node demo.js` 的指令，這次就會多看到 hello world ! 的訊息了！模組其實挺直觀的，當然 NPM 上大家時常使用的模組，裡面都包裝了相當複雜的邏輯或是功能，幫助大家解決各種問題。\n\n備註：引入模組時的路徑是撰寫 './message.js' 而不是 'message.js'，差異相當大：\n\n* 'message.js' 代表 Node.js 會去 node_modules 裡面尋找名為 message.js 的模組，想當然爾找不到。\n* './message.js' 代表 Node.js 會在相對路徑下尋找模組，也就會尋找到 message.js 這個檔案。\n\n請注意這兩者的差別，這是容易犯的小差錯。\n\n## 結語\n\nNPM 是撐起整個 Node.js 世界的大引擎，有優良的套件協助大家工作，才會吸引更多開發者加入 Node.js 的行列，最明顯的例子就是 Ruby，Ruby 在 Ruby on Rail 出現後瞬間人氣高漲，良好的社群或是模組支援，會對其造成一定程度的影響。\n\n對以上的 NPM 指令只要稍作熟悉，以後在專案流程中不時會需要增補一功能，當然有朝一日，也能參與 Node.js 的模組開法，推出屬於自己的模組。\n","slug":"Node從零開始_03","published":1,"updated":"2015-08-15T15:55:16.000Z","layout":"post","photos":[],"link":"","_id":"ciyk03v3r000t0bu0az42vrz7"},{"title":"Part 2 - 快速建立網頁伺服器","date":"2015-08-12T13:04:24.000Z","comments":0,"_content":"\n### Node.js 從零開始\n\n![Node.js](http://lamb-mei.com/wp-content/uploads/2014/09/nodejs-1024x768-1.png)\n\n## Node.js 簡介\n\n用簡單一點的解釋方式來說， Node.js 就是寫在伺服器端的 JavaScript。單純以網頁伺服器而言，其實並沒有相當複雜。仔細想想只要處理幾件事情：\n\n* 解析 Client 提出的請求\n* 跟資料庫要求資料\n* 對資料做一些處理：檢查、篩選等等商業邏輯\n* 回應對應的資料給 Client\n\n初次學習 Node.js，我們先用最簡單的方式建立 Node.js http server，先看到效果，細節在日後在逐一去解釋、了解。首要目標是利用框架快速建立一個網頁伺服器，我們透過 Node.js 框架 [Express](http://expressjs.com) 來建立網站伺服器。Express 是相當容易學習的框架之一。\n\n安裝 Node.js 的框架與套件需要使用 NPM (Node Package Manager) 來，NVM 跟 NPM 是相當不同的輔助管理工具，稍微釐清一下兩者：\n\n* NVM：安裝/管理不同版本的 Node.js\n* NPM：安裝/管理各種 Node.js 的套件\n\n往後 NPM 會比 NVM 還頻繁的出現，NPM的細節與運作方式會在下一章節進行介紹，在此依照著操作即可完成。\n\n1. 安裝第一個必要套件：express-generator\n\n\t首先在電腦中找個習慣的地方建置一個資料夾，在資料夾下透過 NPM 指令安裝 express-generator 簡易的架構產生器：\n\n\t``` bat\n\t$ npm install -g express-generator\n\t$ sudo npm install -g express-generator\n\t```\n\n\t正確情況：\n\t![安裝成功](http://polarbearandrew.github.io/blog/img/nodeFormZero_2/node_2_1.png)\n\n\t錯誤情況：\n\t![安裝失敗 需要權限才能建立資料夾](http://polarbearandrew.github.io/blog/img/nodeFormZero_2/node_2_2.png)\n\n\t某些情況下需要系統管理員的權限才能 `npm install`，單純只是因為建立資料夾的地方權限不足而已，如果權限不足會噴出很明顯的錯誤訊息(error message)告訴我們無法建立資料夾。\n\n2. 透過express-generator建立網站基本結構\n\n\t接著透過產生器提供的指令，產生出整個專案的基礎架構，日後也可以使用產生器產生伺服器基礎的架構，再去修改或補足想要的其它套件。\n\n\t``` bat\n\t$ express myApp\n\t```\n\n\t馬上跳出基本結構建立的結果的訊息\n\n\t```bat\n\t$ express myApp\n\n\t   create : myApp\n\t   create : myApp/package.json\n\t   create : myApp/app.js\n\t   create : myApp/public\n\t   create : myApp/public/javascripts\n\t   create : myApp/public/images\n\t   create : myApp/public/stylesheets\n\t   create : myApp/public/stylesheets/style.css\n\t   create : myApp/routes\n\t   create : myApp/routes/index.js\n\t   create : myApp/routes/users.js\n\t   create : myApp/views\n\t   create : myApp/views/index.jade\n\t   create : myApp/views/layout.jade\n\t   create : myApp/views/error.jade\n\t   create : myApp/bin\n\t   create : myApp/bin/www\n\n\t   install dependencies:\n\t     $ cd myApp && npm install\n\n\t   run the app:\n\t     $ DEBUG=myApp:* ./bin/www\n\t```\n\n\t輸入指令 `ls -l` 可以看到目前的資料夾下的狀況， `node_modules` 的資料夾要完成後面的安裝後才會出現。\n\n\t![myApp 資料夾內的狀況](http://polarbearandrew.github.io/blog/img/nodeFormZero_2/node_2_4.png)\n\n\t此操作是建立基本的 Node.js http server 的框架，接著是進入到伺服器的資料夾內，將相依性的套件安裝起來。可以理解成汽車的結構幾乎都完成了，現在只要打開引擎蓋把引擎放進去。\n\n3. 安裝網站所需要的一切核心套件\n\n\t上方所說的\"所需要的一切核心套件\"，專業來說就是\"相依性套件\"或是在 npm 中專頁名詞為 \"dependencies\"。進入伺服器的資料夾，myApp 是剛剛自動產生時所使用的名稱，可以隨專案需求更換。進入後直接用 NPM 指令安裝整個套件。\n\n\t``` bat\n\t$ cd myApp\n\t$ npm install\n\t```\n\n\t`npm install` 這個指令是安裝此專案目錄下需要的相依性套件，NPM 會很聰明地把需要安裝的套件通通下載下來自動安裝，包括對應的版本也會正確地抓取，甚至是相依性套件的相依性套件。初始化的 `npm install` 需要一些時間，與需要安裝的套件數量成正比，稍作等帶後即可看到長長一串的安裝清單，沒有錯誤訊息的話即可繼續往下。\n\n\t註：`npm install` 的細節會再下一篇教學中解說。\n\n4. 撰寫啟動伺服器的程式碼\n\n\t用任何習慣的編輯器打開 `myApp` 資料夾之下的 `app.js`。 `app.js` 是整個 server 的啟動檔案，express-generator相當完整將我們基本需要的程式碼 99% 都寫完了，只需要在最後方補上 server 監聽 port 的動作。在檔案尾端找到 `module.exports = app;` 將以下程式補在該行之前：\n\n\t``` js\n\tapp.listen(3000, function(){\n\t    console.log('server started -> http://localhost:3000');\n\t});\n\n\tmodule.exports = app; //<-- 原先就有這行\n\t```\n\n\t或是我個人認為比較漂亮的寫法，port的值可以是從其他設定檔中抓取。\n\n\t``` js\n\tvar port = 3000; //值可能是從其他設定檔中抓取\n\n\tapp.listen(port, function(){\n\t    console.log('listening -> http://localhost:' + port);\n\t});\n\n\tmodule.exports = app; //原先就有這行\n\t```\n\n\t![ app.js ](http://polarbearandrew.github.io/blog/img/nodeFormZero_2/node_2_5.png)\n\n## 使用 Node.js 啟動伺服器\n\n嚴格來說沒什麼太大的差異，單純抽取 port 這個參數而已。確認補上上方這段程式碼後，接著回到終端幾啟動伺服器。在 `myApp` 的資料夾內輸入啟動指令：( 使用 Node.js 讀取 app.js ，啟動這個伺服器)\n\n``` bat\n$ node app.js\n```\n\n啟動後再終端幾內會看到游標卡在那邊，並沒有跳出下一行。這樣就是正確的情況，代表伺服器啟動了，正在監聽我們所正定的 port 3000 ：\n\n![node app.js](http://polarbearandrew.github.io/blog/img/nodeFormZero_2/node_2_6.png)\n\n然後在瀏覽器的網址列輸入[http://localh\u001eost:3000](http://localhost:3000)即可看到 express-generator 自動產生的歡迎頁面！\n\n![Express welcome page](http://polarbearandrew.github.io/blog/img/nodeFormZero_2/node_2_7.png)\n\n## 小小的做個修改\n\n看到預設的 Express welcome 頁面就代表成功囉，我們小小的修改一個參數，來讓網頁看起來像自己的。開啟 `route` 資料夾內的 `index.js` 然後將修改裡面的 Express 字串為自己的英文名字或是任何想要顯示的字串，刷新瀏覽器即可看到結果。\n\n``` js\n//修改前\nres.render('index', { title: 'Express' });\n\n//修改後 \nres.render('index', { title: 'Andrew Chen' });\n```\n\n## 結語\n\nexpress-generator 使用名為 express 的框架建置最基本的網站伺服器架構，建置完架構後可以再手動進行修改以符合個人習慣或專案需求。 express 是目前 Node.js 套件中優秀好用的框架之一，之後的 **Node.js 從零開始** 的教程會使用 express 做為主軸，更之後會進一步撰寫有關 Koa.js 的文章。\n\n\n## 參考資料\n\n* [express](http://expressjs.com/starter/generator.html)\n* [express-generator(npm)](https://www.npmjs.com/package/express-generator)\n","source":"_posts/Node從零開始_02.md","raw":"title: Part 2 - 快速建立網頁伺服器\ndate: 2015-08-12 21:04:24\ntags:\n- Node.js\n- Node.js 從零開始\n- JavaScript\ncategories: Node.js 從零開始\ncomments: false\n---\n\n### Node.js 從零開始\n\n![Node.js](http://lamb-mei.com/wp-content/uploads/2014/09/nodejs-1024x768-1.png)\n\n## Node.js 簡介\n\n用簡單一點的解釋方式來說， Node.js 就是寫在伺服器端的 JavaScript。單純以網頁伺服器而言，其實並沒有相當複雜。仔細想想只要處理幾件事情：\n\n* 解析 Client 提出的請求\n* 跟資料庫要求資料\n* 對資料做一些處理：檢查、篩選等等商業邏輯\n* 回應對應的資料給 Client\n\n初次學習 Node.js，我們先用最簡單的方式建立 Node.js http server，先看到效果，細節在日後在逐一去解釋、了解。首要目標是利用框架快速建立一個網頁伺服器，我們透過 Node.js 框架 [Express](http://expressjs.com) 來建立網站伺服器。Express 是相當容易學習的框架之一。\n\n安裝 Node.js 的框架與套件需要使用 NPM (Node Package Manager) 來，NVM 跟 NPM 是相當不同的輔助管理工具，稍微釐清一下兩者：\n\n* NVM：安裝/管理不同版本的 Node.js\n* NPM：安裝/管理各種 Node.js 的套件\n\n往後 NPM 會比 NVM 還頻繁的出現，NPM的細節與運作方式會在下一章節進行介紹，在此依照著操作即可完成。\n\n1. 安裝第一個必要套件：express-generator\n\n\t首先在電腦中找個習慣的地方建置一個資料夾，在資料夾下透過 NPM 指令安裝 express-generator 簡易的架構產生器：\n\n\t``` bat\n\t$ npm install -g express-generator\n\t$ sudo npm install -g express-generator\n\t```\n\n\t正確情況：\n\t![安裝成功](http://polarbearandrew.github.io/blog/img/nodeFormZero_2/node_2_1.png)\n\n\t錯誤情況：\n\t![安裝失敗 需要權限才能建立資料夾](http://polarbearandrew.github.io/blog/img/nodeFormZero_2/node_2_2.png)\n\n\t某些情況下需要系統管理員的權限才能 `npm install`，單純只是因為建立資料夾的地方權限不足而已，如果權限不足會噴出很明顯的錯誤訊息(error message)告訴我們無法建立資料夾。\n\n2. 透過express-generator建立網站基本結構\n\n\t接著透過產生器提供的指令，產生出整個專案的基礎架構，日後也可以使用產生器產生伺服器基礎的架構，再去修改或補足想要的其它套件。\n\n\t``` bat\n\t$ express myApp\n\t```\n\n\t馬上跳出基本結構建立的結果的訊息\n\n\t```bat\n\t$ express myApp\n\n\t   create : myApp\n\t   create : myApp/package.json\n\t   create : myApp/app.js\n\t   create : myApp/public\n\t   create : myApp/public/javascripts\n\t   create : myApp/public/images\n\t   create : myApp/public/stylesheets\n\t   create : myApp/public/stylesheets/style.css\n\t   create : myApp/routes\n\t   create : myApp/routes/index.js\n\t   create : myApp/routes/users.js\n\t   create : myApp/views\n\t   create : myApp/views/index.jade\n\t   create : myApp/views/layout.jade\n\t   create : myApp/views/error.jade\n\t   create : myApp/bin\n\t   create : myApp/bin/www\n\n\t   install dependencies:\n\t     $ cd myApp && npm install\n\n\t   run the app:\n\t     $ DEBUG=myApp:* ./bin/www\n\t```\n\n\t輸入指令 `ls -l` 可以看到目前的資料夾下的狀況， `node_modules` 的資料夾要完成後面的安裝後才會出現。\n\n\t![myApp 資料夾內的狀況](http://polarbearandrew.github.io/blog/img/nodeFormZero_2/node_2_4.png)\n\n\t此操作是建立基本的 Node.js http server 的框架，接著是進入到伺服器的資料夾內，將相依性的套件安裝起來。可以理解成汽車的結構幾乎都完成了，現在只要打開引擎蓋把引擎放進去。\n\n3. 安裝網站所需要的一切核心套件\n\n\t上方所說的\"所需要的一切核心套件\"，專業來說就是\"相依性套件\"或是在 npm 中專頁名詞為 \"dependencies\"。進入伺服器的資料夾，myApp 是剛剛自動產生時所使用的名稱，可以隨專案需求更換。進入後直接用 NPM 指令安裝整個套件。\n\n\t``` bat\n\t$ cd myApp\n\t$ npm install\n\t```\n\n\t`npm install` 這個指令是安裝此專案目錄下需要的相依性套件，NPM 會很聰明地把需要安裝的套件通通下載下來自動安裝，包括對應的版本也會正確地抓取，甚至是相依性套件的相依性套件。初始化的 `npm install` 需要一些時間，與需要安裝的套件數量成正比，稍作等帶後即可看到長長一串的安裝清單，沒有錯誤訊息的話即可繼續往下。\n\n\t註：`npm install` 的細節會再下一篇教學中解說。\n\n4. 撰寫啟動伺服器的程式碼\n\n\t用任何習慣的編輯器打開 `myApp` 資料夾之下的 `app.js`。 `app.js` 是整個 server 的啟動檔案，express-generator相當完整將我們基本需要的程式碼 99% 都寫完了，只需要在最後方補上 server 監聽 port 的動作。在檔案尾端找到 `module.exports = app;` 將以下程式補在該行之前：\n\n\t``` js\n\tapp.listen(3000, function(){\n\t    console.log('server started -> http://localhost:3000');\n\t});\n\n\tmodule.exports = app; //<-- 原先就有這行\n\t```\n\n\t或是我個人認為比較漂亮的寫法，port的值可以是從其他設定檔中抓取。\n\n\t``` js\n\tvar port = 3000; //值可能是從其他設定檔中抓取\n\n\tapp.listen(port, function(){\n\t    console.log('listening -> http://localhost:' + port);\n\t});\n\n\tmodule.exports = app; //原先就有這行\n\t```\n\n\t![ app.js ](http://polarbearandrew.github.io/blog/img/nodeFormZero_2/node_2_5.png)\n\n## 使用 Node.js 啟動伺服器\n\n嚴格來說沒什麼太大的差異，單純抽取 port 這個參數而已。確認補上上方這段程式碼後，接著回到終端幾啟動伺服器。在 `myApp` 的資料夾內輸入啟動指令：( 使用 Node.js 讀取 app.js ，啟動這個伺服器)\n\n``` bat\n$ node app.js\n```\n\n啟動後再終端幾內會看到游標卡在那邊，並沒有跳出下一行。這樣就是正確的情況，代表伺服器啟動了，正在監聽我們所正定的 port 3000 ：\n\n![node app.js](http://polarbearandrew.github.io/blog/img/nodeFormZero_2/node_2_6.png)\n\n然後在瀏覽器的網址列輸入[http://localh\u001eost:3000](http://localhost:3000)即可看到 express-generator 自動產生的歡迎頁面！\n\n![Express welcome page](http://polarbearandrew.github.io/blog/img/nodeFormZero_2/node_2_7.png)\n\n## 小小的做個修改\n\n看到預設的 Express welcome 頁面就代表成功囉，我們小小的修改一個參數，來讓網頁看起來像自己的。開啟 `route` 資料夾內的 `index.js` 然後將修改裡面的 Express 字串為自己的英文名字或是任何想要顯示的字串，刷新瀏覽器即可看到結果。\n\n``` js\n//修改前\nres.render('index', { title: 'Express' });\n\n//修改後 \nres.render('index', { title: 'Andrew Chen' });\n```\n\n## 結語\n\nexpress-generator 使用名為 express 的框架建置最基本的網站伺服器架構，建置完架構後可以再手動進行修改以符合個人習慣或專案需求。 express 是目前 Node.js 套件中優秀好用的框架之一，之後的 **Node.js 從零開始** 的教程會使用 express 做為主軸，更之後會進一步撰寫有關 Koa.js 的文章。\n\n\n## 參考資料\n\n* [express](http://expressjs.com/starter/generator.html)\n* [express-generator(npm)](https://www.npmjs.com/package/express-generator)\n","slug":"Node從零開始_02","published":1,"updated":"2015-08-14T02:01:22.000Z","layout":"post","photos":[],"link":"","_id":"ciyk03v3u000y0bu0pd61xv2q"},{"title":"Part 1 - 簡介與安裝","date":"2015-08-09T10:41:42.000Z","comments":0,"_content":"\n### Node.js 從零開始\n\n![Node.js](http://lamb-mei.com/wp-content/uploads/2014/09/nodejs-1024x768-1.png)\n\n## Node.js 簡介\n\n* [Node.js 官方](https://nodejs.org/)\n* [Node.js 台灣社群](http://nodejs.tw)\n* [Node.js Facabook 台灣社群](https://www.facebook.com/groups/node.js.tw/)\n\n隨著Google V8 引擎優秀的效能，JavaScript在近幾年迅速地竄紅，並透過Node.js的作者Ryan Dahl，讓JavaScript正式地能運作於伺服器端。\n\nNode.js在 I/O 這方面表現相當優，主要歸功於非同步事件驅動的核心。Node.js 的非同步 I/O 適合在 I/O 密集的情況下使用，正是現今大部份網站面臨的情況。\n\nNode.js 透過非阻塞式、非同步的 I/O 應付大量的請求，在以往阻塞式的伺服器語言設計中，後續資料需要等待前方 I/O 完成後才能繼續，或是需要開啟新的執行緒，在流量相當大的伺服器相對會造成一定時間的延遲。\n\n一般來說會仰賴提升伺服器或是增加伺服器數量來分擔流量，但現今網路世界蓬勃發展，高流量已經相當常見，開發者不得不正視效能問題。\n\n舉例來說新聞網站、部落格等，伺服器要能大量的回應資料，不需要牽涉到複雜的演算。使用 Node.js 伺服器能大大的解決 I/O 的需求。Node.js也相當適合配上 Single Page App 和 API，大量的 I/O 和少量的運算，Node.js 符合這一類型的需求。\n\n\n## Node.js 快速安裝 (on MAC)\n\n別急著下載Node.js官方的安裝檔，我們用更聰明的方式處理。\n\nNode.js 近來版本更新快速，現階段又即將跟 Node.js 的分支 io.js 進行整合，Node.js 將版本大躍進到4.0版。以 PHP 來說，開發時往往有版號的問題，Node.js 亦有相同的情形，因此我們透過 Node Version Managerer (NVM) 來進行各個版本的：安裝、刪除、切換，讓我們在各個版本之間輕鬆自在的遊走！\n\n那 NVM 又要怎麼安裝呢？MAC 使用者請使用 [Homebrew](http://brew.sh) 進行安裝，安裝Homebrew相當簡單，開啟終端及(Terminal)，然後複製[官網](http://brew.sh)上的安裝指令，即是以下指令，貼上直行即可。\n\n備註：`$ xxx` 代表著要在終端機輸入 `xxx` 指令\n\n\n``` bat\n$ ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\n因為 MAC 原生就有安裝 Ruby，因此可以直接使用 Ruby 指令，基本上沒有大問題。接著再次確認 Homebrew 有正確安裝，查看Homebrew在本機的位址或是版本皆可。\n\n``` bat\n$ which brew          <--查詢路徑\n/usr/local/bin/brew   <--路徑\n$ brew -v             <--查詢版本\nHomebrew 0.9.5        <--當前版本\n```\n\n接著就可以使用 Homebrew 安裝 NVM 囉：\n\n``` bat\n$ brew install nvm\n```\n接著請等終端機運行完畢即可。\n接著要在終端機的指令集裡面補上 NVM 的指令，如果不熟悉 Linux 或 vim 的話，操作稍微比較麻煩一點，可依照以下說明一步步操作。\n\n1. 使用 vim 打開 .bash_profile\n\n\t``` bat\n\t$ vim ~/.bash_profile\n\t```\n\t輸入上面 vim 的指令後，會看到一個相當不友善的編輯界面， vim 的操作需要一段時間才能熟悉，目前我們就將就學習會用到的部分就好。 \n\t\n2. 用 vim 編輯 .bash_profile 檔案\n\n\tvim 也是仰賴指令來操作，將游標移動到想要的位置後按下鍵盤 `a` 可以開始編輯，接著使用一般的複製貼上 `cmd⌘+c`  `cmd⌘+v` 將以下兩串字貼進去：\n\n\t``` bat\n\texport NVM_DIR=~/.nvm\n\tsource $(brew --prefix nvm)/nvm.sh\n\t```\n\n3. 用 vim 儲存並離開\n\n\t(1) 按下 `esc`先離開編輯環境\n\t\n\t(2) 按下 `shift+:`\n\t\n\t(3) 輸入指令 `wq`\n\t\n\t(4) 按下 `enter`\n\t\n\t就會儲存並離開拉！\n\n4. 使用指令 `$ . ~/.bash_profile` 讓終端機重新載入這定檔案，關掉終端機並且重新開機可以確保刷新剛剛修改的設定的檔案。\n\n## 確定 NVM 安裝完成\n\n藉著測試有沒有安裝成功。測試在開發過程中是最重要，紀律性的測試可以避免掉很多不必要的錯誤，這邊測試 Node.js 正卻安裝只是一個小小步驟，以後會有更重要的程式碼品質檢測出現。只要直接輸入 `$ nvm` 這個指令，終端機回應如下：\n\n基本上就是 NVM 有哪些指令的目錄。\n\n``` bat\nNode Version Manager\n\nUsage:\n  nvm help                              Show this message\n  nvm --version                         Print out the latest released version of nvm\n  nvm install [-s] <version>            Download and install a <version>, [-s] from source. Uses .nvmrc if available\n  nvm uninstall <version>               Uninstall a version\n  nvm use <version>                     Modify PATH to use <version>. Uses .nvmrc if available\n  nvm run <version> [<args>]            Run <version> with <args> as arguments. Uses .nvmrc if available for <version>\n  nvm current                           Display currently activated version\n  nvm ls                                List installed versions\n  nvm ls <version>                      List versions matching a given description\n  nvm ls-remote                         List remote versions available for install\n  nvm deactivate                        Undo effects of `nvm` on current shell\n  nvm alias [<pattern>]                 Show all aliases beginning with <pattern>\n  nvm alias <name> <version>            Set an alias named <name> pointing to <version>\n  nvm unalias <name>                    Deletes the alias named <name>\n  nvm reinstall-packages <version>      Reinstall global `npm` packages contained in <version> to current version\n  nvm unload                            Unload `nvm` from shell\n  nvm which [<version>]                 Display path to installed node version. Uses .nvmrc if available\n\nExample:\n  nvm install v0.10.32                  Install a specific version number\n  nvm use 0.10                          Use the latest available 0.10.x release\n  nvm run 0.10.32 app.js                Run app.js using node v0.10.32\n  nvm exec 0.10.32 node app.js          Run `node app.js` with the PATH pointing to node v0.10.32\n  nvm alias default 0.10.32             Set default node version on a shell\n\nNote:\n  to remove, delete, or uninstall nvm - just remove ~/.nvm, ~/.npm, and ~/.bower folders\n```\n\n如果測試成功的話，那就可以開始安裝 Node.js 了！上面辛苦的安裝 NVM 可以為未來 Node.js 的版本切換省下許多功夫。\n\n## 用 NVM 安裝 Node.js \n\n1. 讓 NVM 找出目前所有能安裝的版本，使用這個指令需要等待一下，然後會跑出一堆 Node.js 和 io.js 的版本。\n\n\t``` bat\n\t$ nvm ls-remote \n\t```\n\n2. 安裝指定想要的版本，推薦使用 0.10.24 或是 0.12.2 這幾個版本，如果有買任何 Node.js 的書籍，請參閱書籍使用的版本，在個版本中是存在著些微的差異的，使用不同的版本在學習的過程上多多少會造成不必要的麻煩。\n\n\t``` bat\n\t$ nvm install 0.12.2\n\t```\n\n3. 切換指定使用的版本\n\n\t``` bat\n\t$ nvm use 0.12.2\n\t```\n\n4. 查詢 nvm 的現狀，以下即是列印出來的狀況，可以查看當前使用的版本、預設使用的版本、穩定版本等等資訊...，方便日後切換版本時查看。\n\n\t``` bat\n\t$ nvm ls\n\t       v0.12.2\n\tdefault -> v0.10.24\n\tnode -> stable (-> v0.12.2) (default)\n\tstable -> 0.12 (-> v0.12.2) (default)\n\tiojs -> iojs- (-> N/A) (default)\n\t```\n\n5. 測試 node.js 安裝完成\n\n\t``` bat\n\t$ node -v \n\tv0.10.24\n\t$ which \n\t/usr/local/opt/nvm/v0.10.24/bin/node\n\t```\n\n6. 補上 nvm 預設使用版本\n\n\t如果以上都成功的話，可以利用指令 `$ nvm alias default <版本>` 補上 nvm 預設的版本，免去每次啟動不同的終端幾時都要重新 ` $nvm use <版本>` 一次。\n\n\t``` bat\n\t$ nvm alias default 0.10.24\n\t```\t\n\n\t接著重新開一個終端機的視窗使用 `$ node -v`確認有沒有 Node.js 的安裝路徑即可囉。\n\n## 結語\n\n以個人的經驗而已，在 Node.js 的版本之間切換並沒有非常頻繁，社群通常都通用 v0.12.2 或是 v0.10.24 左右的版本，這幾的版本本身並沒有相當大的排斥性，但總偶爾會遇到其他版本的使用情況，如果沒有 nvm ，屆時就只能乖乖的移除並重新安裝。\n\n在第一次安裝時把這個 NVM 安裝完成，能省解決掉不少問題，如果直接安裝 Node.js 事後又再補上 NVM ，在許多設定細節上也相當困擾。總之，一開始就裝好就對了！\n\n## 參考文章\n* [Homebrew](http://brew.sh)\n* [stackflow-nvm](http://stackoverflow.com/questions/tagged/nvm)\n* [stackflow-nvm command not found](http://stackoverflow.com/questions/16904658/node-version-manager-install-nvm-command-not-found)\n* [Max OSX 新手入門](http://mac-osx-for-newbie-book.kejyun.com/software/softwareWebDeveloperNodeJS.html)\n* [Node.js 安裝與版本切換教學 (for MAC)](http://icarus4.logdown.com/posts/175092-nodejs-installation-guide)\n* [Homebrew: 新一代 OSX 套件管理工具](https://ihower.tw/blog/archives/4308/comment-page-1)\n","source":"_posts/Node從零開始_01.md","raw":"title: Part 1 - 簡介與安裝\ndate: 2015-08-09 18:41:42\ntags:\n- Node.js\n- Node.js 從零開始\n- JavaScript\ncategories: Node.js 從零開始\ncomments: false\n---\n\n### Node.js 從零開始\n\n![Node.js](http://lamb-mei.com/wp-content/uploads/2014/09/nodejs-1024x768-1.png)\n\n## Node.js 簡介\n\n* [Node.js 官方](https://nodejs.org/)\n* [Node.js 台灣社群](http://nodejs.tw)\n* [Node.js Facabook 台灣社群](https://www.facebook.com/groups/node.js.tw/)\n\n隨著Google V8 引擎優秀的效能，JavaScript在近幾年迅速地竄紅，並透過Node.js的作者Ryan Dahl，讓JavaScript正式地能運作於伺服器端。\n\nNode.js在 I/O 這方面表現相當優，主要歸功於非同步事件驅動的核心。Node.js 的非同步 I/O 適合在 I/O 密集的情況下使用，正是現今大部份網站面臨的情況。\n\nNode.js 透過非阻塞式、非同步的 I/O 應付大量的請求，在以往阻塞式的伺服器語言設計中，後續資料需要等待前方 I/O 完成後才能繼續，或是需要開啟新的執行緒，在流量相當大的伺服器相對會造成一定時間的延遲。\n\n一般來說會仰賴提升伺服器或是增加伺服器數量來分擔流量，但現今網路世界蓬勃發展，高流量已經相當常見，開發者不得不正視效能問題。\n\n舉例來說新聞網站、部落格等，伺服器要能大量的回應資料，不需要牽涉到複雜的演算。使用 Node.js 伺服器能大大的解決 I/O 的需求。Node.js也相當適合配上 Single Page App 和 API，大量的 I/O 和少量的運算，Node.js 符合這一類型的需求。\n\n\n## Node.js 快速安裝 (on MAC)\n\n別急著下載Node.js官方的安裝檔，我們用更聰明的方式處理。\n\nNode.js 近來版本更新快速，現階段又即將跟 Node.js 的分支 io.js 進行整合，Node.js 將版本大躍進到4.0版。以 PHP 來說，開發時往往有版號的問題，Node.js 亦有相同的情形，因此我們透過 Node Version Managerer (NVM) 來進行各個版本的：安裝、刪除、切換，讓我們在各個版本之間輕鬆自在的遊走！\n\n那 NVM 又要怎麼安裝呢？MAC 使用者請使用 [Homebrew](http://brew.sh) 進行安裝，安裝Homebrew相當簡單，開啟終端及(Terminal)，然後複製[官網](http://brew.sh)上的安裝指令，即是以下指令，貼上直行即可。\n\n備註：`$ xxx` 代表著要在終端機輸入 `xxx` 指令\n\n\n``` bat\n$ ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\n因為 MAC 原生就有安裝 Ruby，因此可以直接使用 Ruby 指令，基本上沒有大問題。接著再次確認 Homebrew 有正確安裝，查看Homebrew在本機的位址或是版本皆可。\n\n``` bat\n$ which brew          <--查詢路徑\n/usr/local/bin/brew   <--路徑\n$ brew -v             <--查詢版本\nHomebrew 0.9.5        <--當前版本\n```\n\n接著就可以使用 Homebrew 安裝 NVM 囉：\n\n``` bat\n$ brew install nvm\n```\n接著請等終端機運行完畢即可。\n接著要在終端機的指令集裡面補上 NVM 的指令，如果不熟悉 Linux 或 vim 的話，操作稍微比較麻煩一點，可依照以下說明一步步操作。\n\n1. 使用 vim 打開 .bash_profile\n\n\t``` bat\n\t$ vim ~/.bash_profile\n\t```\n\t輸入上面 vim 的指令後，會看到一個相當不友善的編輯界面， vim 的操作需要一段時間才能熟悉，目前我們就將就學習會用到的部分就好。 \n\t\n2. 用 vim 編輯 .bash_profile 檔案\n\n\tvim 也是仰賴指令來操作，將游標移動到想要的位置後按下鍵盤 `a` 可以開始編輯，接著使用一般的複製貼上 `cmd⌘+c`  `cmd⌘+v` 將以下兩串字貼進去：\n\n\t``` bat\n\texport NVM_DIR=~/.nvm\n\tsource $(brew --prefix nvm)/nvm.sh\n\t```\n\n3. 用 vim 儲存並離開\n\n\t(1) 按下 `esc`先離開編輯環境\n\t\n\t(2) 按下 `shift+:`\n\t\n\t(3) 輸入指令 `wq`\n\t\n\t(4) 按下 `enter`\n\t\n\t就會儲存並離開拉！\n\n4. 使用指令 `$ . ~/.bash_profile` 讓終端機重新載入這定檔案，關掉終端機並且重新開機可以確保刷新剛剛修改的設定的檔案。\n\n## 確定 NVM 安裝完成\n\n藉著測試有沒有安裝成功。測試在開發過程中是最重要，紀律性的測試可以避免掉很多不必要的錯誤，這邊測試 Node.js 正卻安裝只是一個小小步驟，以後會有更重要的程式碼品質檢測出現。只要直接輸入 `$ nvm` 這個指令，終端機回應如下：\n\n基本上就是 NVM 有哪些指令的目錄。\n\n``` bat\nNode Version Manager\n\nUsage:\n  nvm help                              Show this message\n  nvm --version                         Print out the latest released version of nvm\n  nvm install [-s] <version>            Download and install a <version>, [-s] from source. Uses .nvmrc if available\n  nvm uninstall <version>               Uninstall a version\n  nvm use <version>                     Modify PATH to use <version>. Uses .nvmrc if available\n  nvm run <version> [<args>]            Run <version> with <args> as arguments. Uses .nvmrc if available for <version>\n  nvm current                           Display currently activated version\n  nvm ls                                List installed versions\n  nvm ls <version>                      List versions matching a given description\n  nvm ls-remote                         List remote versions available for install\n  nvm deactivate                        Undo effects of `nvm` on current shell\n  nvm alias [<pattern>]                 Show all aliases beginning with <pattern>\n  nvm alias <name> <version>            Set an alias named <name> pointing to <version>\n  nvm unalias <name>                    Deletes the alias named <name>\n  nvm reinstall-packages <version>      Reinstall global `npm` packages contained in <version> to current version\n  nvm unload                            Unload `nvm` from shell\n  nvm which [<version>]                 Display path to installed node version. Uses .nvmrc if available\n\nExample:\n  nvm install v0.10.32                  Install a specific version number\n  nvm use 0.10                          Use the latest available 0.10.x release\n  nvm run 0.10.32 app.js                Run app.js using node v0.10.32\n  nvm exec 0.10.32 node app.js          Run `node app.js` with the PATH pointing to node v0.10.32\n  nvm alias default 0.10.32             Set default node version on a shell\n\nNote:\n  to remove, delete, or uninstall nvm - just remove ~/.nvm, ~/.npm, and ~/.bower folders\n```\n\n如果測試成功的話，那就可以開始安裝 Node.js 了！上面辛苦的安裝 NVM 可以為未來 Node.js 的版本切換省下許多功夫。\n\n## 用 NVM 安裝 Node.js \n\n1. 讓 NVM 找出目前所有能安裝的版本，使用這個指令需要等待一下，然後會跑出一堆 Node.js 和 io.js 的版本。\n\n\t``` bat\n\t$ nvm ls-remote \n\t```\n\n2. 安裝指定想要的版本，推薦使用 0.10.24 或是 0.12.2 這幾個版本，如果有買任何 Node.js 的書籍，請參閱書籍使用的版本，在個版本中是存在著些微的差異的，使用不同的版本在學習的過程上多多少會造成不必要的麻煩。\n\n\t``` bat\n\t$ nvm install 0.12.2\n\t```\n\n3. 切換指定使用的版本\n\n\t``` bat\n\t$ nvm use 0.12.2\n\t```\n\n4. 查詢 nvm 的現狀，以下即是列印出來的狀況，可以查看當前使用的版本、預設使用的版本、穩定版本等等資訊...，方便日後切換版本時查看。\n\n\t``` bat\n\t$ nvm ls\n\t       v0.12.2\n\tdefault -> v0.10.24\n\tnode -> stable (-> v0.12.2) (default)\n\tstable -> 0.12 (-> v0.12.2) (default)\n\tiojs -> iojs- (-> N/A) (default)\n\t```\n\n5. 測試 node.js 安裝完成\n\n\t``` bat\n\t$ node -v \n\tv0.10.24\n\t$ which \n\t/usr/local/opt/nvm/v0.10.24/bin/node\n\t```\n\n6. 補上 nvm 預設使用版本\n\n\t如果以上都成功的話，可以利用指令 `$ nvm alias default <版本>` 補上 nvm 預設的版本，免去每次啟動不同的終端幾時都要重新 ` $nvm use <版本>` 一次。\n\n\t``` bat\n\t$ nvm alias default 0.10.24\n\t```\t\n\n\t接著重新開一個終端機的視窗使用 `$ node -v`確認有沒有 Node.js 的安裝路徑即可囉。\n\n## 結語\n\n以個人的經驗而已，在 Node.js 的版本之間切換並沒有非常頻繁，社群通常都通用 v0.12.2 或是 v0.10.24 左右的版本，這幾的版本本身並沒有相當大的排斥性，但總偶爾會遇到其他版本的使用情況，如果沒有 nvm ，屆時就只能乖乖的移除並重新安裝。\n\n在第一次安裝時把這個 NVM 安裝完成，能省解決掉不少問題，如果直接安裝 Node.js 事後又再補上 NVM ，在許多設定細節上也相當困擾。總之，一開始就裝好就對了！\n\n## 參考文章\n* [Homebrew](http://brew.sh)\n* [stackflow-nvm](http://stackoverflow.com/questions/tagged/nvm)\n* [stackflow-nvm command not found](http://stackoverflow.com/questions/16904658/node-version-manager-install-nvm-command-not-found)\n* [Max OSX 新手入門](http://mac-osx-for-newbie-book.kejyun.com/software/softwareWebDeveloperNodeJS.html)\n* [Node.js 安裝與版本切換教學 (for MAC)](http://icarus4.logdown.com/posts/175092-nodejs-installation-guide)\n* [Homebrew: 新一代 OSX 套件管理工具](https://ihower.tw/blog/archives/4308/comment-page-1)\n","slug":"Node從零開始_01","published":1,"updated":"2015-08-18T10:59:39.000Z","layout":"post","photos":[],"link":"","_id":"ciyk03v3x00130bu0ssd6tvfy"},{"title":"Redis - Node.js 記憶體快取","date":"2015-08-16T03:01:07.000Z","comments":0,"_content":"\n<center>\n![Redis](http://acom.azurecomcdn.net/80C57D/cdn/images/cvt-13f9af988a3bce151b5f3666660fb76825069825048a47e2c3f78ca61c38c685/page/services/cache/redis.png?t=popn)\n</center>\n\n* [Redis](http://redis.io)\n* [Redis - 官方文件](http://redis.io/documentation)\n* [Redis - npm](https://www.npmjs.com/package/redis)\n* [Redis - GUI](http://redisdesktop.com)\n\n## 簡介\n\nRedis 是以 key-value 的形式在伺服器的記憶體中儲存資訊的方式，為伺服器命名做快取(cache)。有別於其他 noSQL 或是 RDB，key-value 即是使用一個 key 的值對應到一筆資料。而 Redis 的特色就是將這筆資料，寫在記憶體裡面。\n\n大概有幾種狀況會將資料寫入到快取中：\n\n* 在一定時間內會被大量請求的資料，如：新聞的 Top 10。\n* 某些伺服器會頻繁使用的資料，或全域變數。如：\n* 測試用的資料，短時間內要使用的假資料。\n* 也能當成 Session 使用。(相當不健康的觀念)\n\nRedis 本身會瓜分伺服器的記憶體來使用，Node.js 連線所使用的記憶體相對於 PHP/Apache 較少，除非能非常準確地掌握 Session 的數量，否則不建議 Redit 當成 Session 使用，同樣的意思不應該將 Redis 當成資料庫來只用。如果對 Redis 有相當大的需求，應該特地架設 Redis 的伺服器，避免兩套系統互相搶奪記憶體資源。\n\n## 安裝\n\n先從官方網站下載 Redis，解開壓縮檔之後，在資料夾下執行以下指令\n\n``` bat\n$ make \n```\n\n輸入指令後，Redis 會自行安裝，需要一段時間\n\n``` bat\n$ make test\n```\n\nRedis 會自行進行測試，測時完成後即可啟動，啟動並不需要在指定的資料夾下，屬於全域的\n\n``` bat\n$ redis-server\n```\n\n接著在 [Redis - GUI](http://redisdesktop.com) 的介面中進行連線就可以檢視現在 Redis 內的資料。\n\n\n## 使用\n\n在 Node.js 引用 Redis 的套件並且連線\n\n``` js\nvar redis = require(\"redis\").createClient('6379', '127.0.0.1'); //port, IP\n```\n\nredis.set 寫入值\n\n``` js\nredis.set( key, value, function( err, reply ){\n  console.log( reply.toString() ); // 新增成功會回傳 ok\n});\n```\n\nredis.get 取得值\n\n``` js\nredis.get( key, function( err, reply ){\n  console.log( reply.toString() ); // 新增會回傳 value\n});\n```\n\ncache 資料的存活時間\n\n``` js\nredis.expire( key, 60);\n```\n\nredis 錯誤 callback function\n\n``` js\nredis.on( \"connect\", callback );\n```\n\nredis 錯誤 callback function\n\n``` js\nredis.on( \"error\", callback );\n```\n\nredis 驗證\n如果在 redis.conf 中有設定需要驗證的話，須在在此填入驗證碼，類似密碼的意思。\n\n``` js\nredis.auth(\"AndrewChen\");\n```\n\n## 結語\n\nRedis 基本上安裝完成就成功一半了，簡易的 set/get 即可使用，Redis 的操作本身不難，但謹慎的使用，小心記憶體的使用量，避免超額使用或是佔據了伺服器的空間。另外定期簡單的透過GUI介面檢查 Redis 的狀況也是相當不錯的選擇。","source":"_posts/Node_Redis記憶體快取.md","raw":"title: Redis - Node.js 記憶體快取\ndate: 2015-08-16 11:01:07\ntags:\n- Node.js\n- JavaScript\ncategories: Node.js\ncomments: false\n---\n\n<center>\n![Redis](http://acom.azurecomcdn.net/80C57D/cdn/images/cvt-13f9af988a3bce151b5f3666660fb76825069825048a47e2c3f78ca61c38c685/page/services/cache/redis.png?t=popn)\n</center>\n\n* [Redis](http://redis.io)\n* [Redis - 官方文件](http://redis.io/documentation)\n* [Redis - npm](https://www.npmjs.com/package/redis)\n* [Redis - GUI](http://redisdesktop.com)\n\n## 簡介\n\nRedis 是以 key-value 的形式在伺服器的記憶體中儲存資訊的方式，為伺服器命名做快取(cache)。有別於其他 noSQL 或是 RDB，key-value 即是使用一個 key 的值對應到一筆資料。而 Redis 的特色就是將這筆資料，寫在記憶體裡面。\n\n大概有幾種狀況會將資料寫入到快取中：\n\n* 在一定時間內會被大量請求的資料，如：新聞的 Top 10。\n* 某些伺服器會頻繁使用的資料，或全域變數。如：\n* 測試用的資料，短時間內要使用的假資料。\n* 也能當成 Session 使用。(相當不健康的觀念)\n\nRedis 本身會瓜分伺服器的記憶體來使用，Node.js 連線所使用的記憶體相對於 PHP/Apache 較少，除非能非常準確地掌握 Session 的數量，否則不建議 Redit 當成 Session 使用，同樣的意思不應該將 Redis 當成資料庫來只用。如果對 Redis 有相當大的需求，應該特地架設 Redis 的伺服器，避免兩套系統互相搶奪記憶體資源。\n\n## 安裝\n\n先從官方網站下載 Redis，解開壓縮檔之後，在資料夾下執行以下指令\n\n``` bat\n$ make \n```\n\n輸入指令後，Redis 會自行安裝，需要一段時間\n\n``` bat\n$ make test\n```\n\nRedis 會自行進行測試，測時完成後即可啟動，啟動並不需要在指定的資料夾下，屬於全域的\n\n``` bat\n$ redis-server\n```\n\n接著在 [Redis - GUI](http://redisdesktop.com) 的介面中進行連線就可以檢視現在 Redis 內的資料。\n\n\n## 使用\n\n在 Node.js 引用 Redis 的套件並且連線\n\n``` js\nvar redis = require(\"redis\").createClient('6379', '127.0.0.1'); //port, IP\n```\n\nredis.set 寫入值\n\n``` js\nredis.set( key, value, function( err, reply ){\n  console.log( reply.toString() ); // 新增成功會回傳 ok\n});\n```\n\nredis.get 取得值\n\n``` js\nredis.get( key, function( err, reply ){\n  console.log( reply.toString() ); // 新增會回傳 value\n});\n```\n\ncache 資料的存活時間\n\n``` js\nredis.expire( key, 60);\n```\n\nredis 錯誤 callback function\n\n``` js\nredis.on( \"connect\", callback );\n```\n\nredis 錯誤 callback function\n\n``` js\nredis.on( \"error\", callback );\n```\n\nredis 驗證\n如果在 redis.conf 中有設定需要驗證的話，須在在此填入驗證碼，類似密碼的意思。\n\n``` js\nredis.auth(\"AndrewChen\");\n```\n\n## 結語\n\nRedis 基本上安裝完成就成功一半了，簡易的 set/get 即可使用，Redis 的操作本身不難，但謹慎的使用，小心記憶體的使用量，避免超額使用或是佔據了伺服器的空間。另外定期簡單的透過GUI介面檢查 Redis 的狀況也是相當不錯的選擇。","slug":"Node_Redis記憶體快取","published":1,"updated":"2015-08-16T03:12:50.000Z","layout":"post","photos":[],"link":"","_id":"ciyk03v3z00180bu0t3puvowv"},{"title":"JavaScript - .Bind() .Apply() .Call()","date":"2015-08-18T14:30:15.000Z","comments":0,"_content":"\n#### function .bind()\n\n.bind() 不會立即執行 function，並設定 `this` 範疇與傳入參數。傳入第一個參數是 scope，指定 function 內 `this` 的範疇。\n\n``` js\nfunc.bind( null, 1 ,2 ,3 ) ;   // 不會立即執行\n```\n\n#### function .call()\n\n.call() 呼叫 function，並設定 `this` 範疇與傳入參數。傳入第一個參數是 scope，指定 function 內 `this` 的範疇。\n\n``` js\nfunc.call( null, 1 ,2 ,3 ) ;   // 逐一傳入參數 (立即執行)\n```\n\n#### function .apply()\n\n.apply() 呼叫 function，並設定 `this` 範疇與傳入參數。傳入第一個參數是 scope，指定 function 內 `this` 的範疇。而參數是統一用一個陣列包起來，apply 會自行拆開傳入。\n\n\n``` js \nfunc.apply( null, [ 1, 2, 3 ] );  // 參數統一用 array 傳入 (立即執行)\n```","source":"_posts/JavaScript_01.md","raw":"title: JavaScript - .bind() .apply() .call()\ndate: 2015-08-18 22:30:15\ntags:\n- JavaScript\ncategories: JavaScript\ncomments: false\n---\n\n#### function .bind()\n\n.bind() 不會立即執行 function，並設定 `this` 範疇與傳入參數。傳入第一個參數是 scope，指定 function 內 `this` 的範疇。\n\n``` js\nfunc.bind( null, 1 ,2 ,3 ) ;   // 不會立即執行\n```\n\n#### function .call()\n\n.call() 呼叫 function，並設定 `this` 範疇與傳入參數。傳入第一個參數是 scope，指定 function 內 `this` 的範疇。\n\n``` js\nfunc.call( null, 1 ,2 ,3 ) ;   // 逐一傳入參數 (立即執行)\n```\n\n#### function .apply()\n\n.apply() 呼叫 function，並設定 `this` 範疇與傳入參數。傳入第一個參數是 scope，指定 function 內 `this` 的範疇。而參數是統一用一個陣列包起來，apply 會自行拆開傳入。\n\n\n``` js \nfunc.apply( null, [ 1, 2, 3 ] );  // 參數統一用 array 傳入 (立即執行)\n```","slug":"JavaScript_01","published":1,"updated":"2015-09-11T07:49:34.000Z","layout":"post","photos":[],"link":"","_id":"ciyk03v43001d0bu0257o281t"},{"title":"Android App - TTtimer","date":"2015-08-19T07:46:12.000Z","comments":0,"_content":"\n<center>\n![TTtimer](http://polarbearandrew.github.io/blog/img/TTtimer/ic_launcher.png)\n</center>\n\n名稱：TTtimer\n類型：Andriod App / Java, 未上架\n時間：2015/1 (大三上學期)\n用途：期末作業\nLicense：MIT\n\n## 簡介\n\nAndroid APP - TTtime 是我在大三上學期修 Amy 老師 Java 課程的期末作品。這隻 APP 大概是我個人最喜歡期末作品之一，包括結構和設計是我個人最喜歡的，當時我有不少的時間與不曉得發揮空間。TTtimer 的設計概念出自於 10,000 小時，意指在某一個專業區域中努力 10,000 小時才能成為該專業領域中的佼佼者。而 TTtimer 即是此類型的計時器，選擇目標的專業項目後，持續累計時間來達成最初設定的目標，並透過累計時間的百分比、累計總數來給予獎勵或是頭銜的稱號。\n\n<center>\n<img src=\"http://polarbearandrew.github.io/blog/img/TTtimer/working_finish.png\" alt=\"TTtimer Working\" style=\"width: 200px;\"/>\n</center>\n\n以下為 APP 使用到的技術重點，有需要的同學可以在裡面尋找相關自訓。有機會的話相我想把這個 APP 上架，最為一次學習經驗。\n\n## Source Code 分享\n\nSource Code 放置在 Google Drive 上面，分享給需要範例的同學們。\n\n適用於 Andriod Studio 版本：\n[[Android APP]  TTtimer-for-AS-v1.0](https://drive.google.com/open?id=0B1p_o3Z5VQBeXzlXUlRNWExCUVE)\n\n適用於 Eclipse 版本：\n[[Android APP]  TTtimer-for-eclipse-v1.0](https://drive.google.com/open?id=0B1p_o3Z5VQBeYjM5ZEVQWVpWOWs)\n\n## 技術簡介\n\n#### 物件導向設計\n\nAPP 中，每個 `任務` 都是以一個物件包裝，包括包裝這個 `任務` 本身的資訊、進度、累計時間等等。而累計時間輸出時，可是轉換成百分比的函數，也是包裝在 PlaneToTime 的類別裡面。物件導向設計可參考的是以下主要幾個類別：\n\n* MyTimer\n* MicroTimer\n* Plan\n* PlanToTime\n\nMyTimer 和 MicroTimer 類別主要功能就是計時器，在每個計畫中都會使用到一個計時計，並且有簡化一些時間I/O的機制，主要是根據我當時自己的需求所包裝的。而 Plan 和 PlanToTime 包裝了 `計畫` 和 `有時目標間的計畫`，事實上在最後 APP 實作的時候，並沒有 `無目標時間的計畫`，也就是說類別 Plan 只是單純被 PlanToTime 繼承，作用類似於一個基底類別，其實並沒有實作的功能，這屬於我個人設計錯誤，因為一開始有構想 `無目標時間的計畫`。因此在後面會發現，底層設計的取得獎勵的方式，略有不同，僅僅因為當初規劃時我的想法岔開了。\n\n包裝這四個類別，在我專案開發中後期其為吃香，傳送資料時不太需要考慮資料格式。簡單思考：傳遞一個物件比起傳遞四個不同型別的參數，何者容易？當然是包裝好的一個物件，一次傳遞來得輕鬆方便。另外，包裝物件可以在多人開發時，資料格式的缺漏檢查，或是避免掉不必要的資料傳遞誤會與錯誤。\n\n#### 計時器\n\n計時器只有兩個原則，每秒(或是其他時間)的觸發事件，然後再撰寫自己紀錄的方式。計時器 Andriod 有預設事件，少量的計時器每秒的 tick 相當精準，不要一次開一大堆就好。也別用計時器去處理監聽事件，基本上 Andriod 大部份的物件都有自己的監聽事件，不需要自行去撰寫計時器去檢查。在 TTtimer 中牽涉到的類別如下：\n\n* MainActivity\n* TiemRiver\n* SysSet\n\n之前被問過幾次 Android App 的計時計怎麼處理，計時器的影子可以在 `Mainctivity` 中找到，當初設計是在 APP 一啟動時，背後就有一個碼表在計時，而計時計的參數被我抽取到 `TimeRiver` 和 `SysSet` 的類別中，其實 `TimeRiver` 的類別中的設定參數直接抽取到 `SysSet`，目前的方式是多個任務會共用同一個碼錶，避免每開一起一個新的任務就啟用新的碼表消耗效能。\n\n#### SQLite\n\n如果 SQLite 無法正常啟用，記得注意 Android 本身的版本是否要更新，之前個人在測試時就發生過無法啟動的狀況。情急之下用 txt 自己刻了一套類似功能的 documentation SQL。現在想想挺好笑的，結果期中考過後我發現手機系統要更新，更新好就能使用 SQLite 了，只好默默的砍掉整個手刻的 SQL。\n\n關於 SQLite 我使用在兩個部分：儲存計畫、系統參數。\n\n* PlanSQL\n* SystemSettingSQL\n\n兩者都相當直接的包裝了基本的 Sqlite 的 CRUD (新增/修改/刪除/查詢)，基本上 SQLite 在類別設計完成後，撰寫一次，確認每次 APP 開啟後跟 SQLite 的 IO 正常後，我就再也沒有修改過內部的程式碼。所以理想的話只要努力一次就好，並不需要開發途中不斷地維護那段程式碼。 SQLite 需要注意的重點是測試資料的問題。在開發時頻繁的測試過程中，程式碼除錯時會頻繁地影響到資料庫資料的變動，導致錯誤解決了卻仍然出現問題。主因是資料錯誤，產生 Garbage in garbage out 的結果。建議在開發期間每次 APP 啟動時就初始化一次資料，清空資料庫並且寫入測試用的資料，最終在 APP 發佈時只要將初始化資料的程式碼註解掉即可。\n\n另外需要注意的事情是，程式碼要有解析空資料的能力。意思是多半在測試時，資料庫內已經有測試資料，往往忽略了有可能無資料的情況，反而在拿掉測試資料後才發現 APP 啟動的一瞬間就會因為資料讀取失敗而崩潰。\n\n#### 動態新增控制項\n\n這大概是我被詢問最頻繁的項目了。處理這部分的是以下兩個類別：\n\n* AddBtn\n* ViewList\n\n動態新增控制項的步驟就是：宣告 > 設定 > 掛載。除非是要做 APP 遊戲，不然 Andriod 內建的 ListView 應該能解決大部份的問題，當初我在這塊也是修改了好幾個版本，一開始因為好玩也是手刻 ListView，再建立 Scroll view。不過內建的 ListView 和手刻的邏輯基本上是相同的，先將想要動態新增的物件製作成一份 ListItem 再由 ListView 去重複就對了。\n\n#### Android Lifecycle 生命週期\n\n![Andriod 生命週期 ](http://ext.pimg.tw/style77125tech/1369341764-3430810860.png)\n\n撰寫 Andriod APP 最重要的就是生命週期。簡而言之，生命週期就是我們在手機各種操作時，切換到 APP 畫面時對程式運行的影響，例如執行中的 APP 在按下 Home 鍵後會進入到 `onPause()` 的狀態，不同的狀態不可能讓 APP 一直處於運轉中，因此 APP 作業流程設計會圍繞著 Android Lifecycle 在運轉，也是設計的核心。但記得在 Lifecycle 中，我個人認為最不能仰賴 `onDestroy()`，仰賴關閉 APP 時才去執行，無法預測 APP 是在什麼情況下被關閉的，可能執行緒被中斷、手機沒電等等狀況。重要的資料同步，盡可能不要放在 `onDestroy` 的部分。\n\n#### 雙語系\n\nTTtiemr 支援雙語系，支援 `zh-Tw` 和 `en` 語系，根據手機設定的國籍去做辨識。在手機中抓取字串的方式都需要使用 `android:text=\"@string/show\"` 抓取，之前有聽過反映這樣相當不友善(且不容易辨識)，不過在後期翻譯時相當有趣，單純翻譯 `string` 的設定檔就可完成。如果從一開始就有遵守紀律，將對應的字串寫在設定檔內，在專案末期好好享受輕鬆翻譯 APP 語言的成果吧!\n\n#### 多解析度圖片\n\n在多解析度圖片這部分，我個人處理得相當糟糕，當初在 PC 上測試時雨手機上測試時發現差距極大，因此我大量的改用百分比去做設計。解決問題後我就沒有再去對多種解析度的螢幕下去做設計。\n\n#### Animation 動畫效果\n\n在 `WorkingActivity` 可以大量使用到動畫，Android 的動畫使用大致上是：宣告 > 設定參數 > 啟動。需要注意的是 Animation 的狀態，需要將正確的資料流操作掛載載正確的 Animation 事件上面，避免掉發生動畫時件不同步或是執行順序有問題的情況。Animation 玩起來相當有趣且有成就看，相當推薦大家玩玩。\n\n![screen shot](http://polarbearandrew.github.io/blog/img/TTtimer/demo.png)\n\n## 檔案簡介\n\npath: src/main/java/tw/com/oit/andrew/\n\n##### myclass/MyTimer\n\n計時計類別，主要是依照需求包裝了計時器去配合之後的 Andriod time tick。\n\n##### myclass/MicroTimer\n\n繼承了 MyTimer，加入了秒數的欄位，最後這兩個計時器使用的類別會被包在 Plan 和 PlanToTime 中使用。\n\n#### myclass/Plan\n\n包裝了每個計畫項目資訊，屬於 PlanToTime 的父類別，絕大多數重要的功能也是在這裡。\n\n#### myclass/PlanToTime\n\n在計畫項目資訊增加了目標時間，之後的 Activity 中使用的都是這個 class。兩個 Plan 相關的 class 是整個 APP 中 CP 最高的，但也是被反覆修改最多次的，良好的物件設計讓我在整個 APP 開發的後期有了相當不錯的資料控管，我能清楚的掌握資料的傳輸。\n\n#### system/Notify\n\n包裝了所有使用的通知視窗(Dialog)，從外部可以輕鬆的呼叫視窗，僅需要傳入必要的字串需求即可。\n\n#### system/SysSet\n\n系統設定檔。應該與 TimeRiver 合併。\n\n#### system/TimeRiver\n\n系統設定檔。主要是針對計時器的部分，這部分的設定會被記錄在 SQLite 中，確保每次重新啟動時都會是使用者設定的值。\n\n#### tenthousandtimer/MainActivity\n\n主要介面的操作，拿讀取進來的資料動態新增控制項，並且宣告、啟動計時器。\n\n#### tenthousandtimer/MetalsActivity\n\n單純檢視獎牌與頭銜等訊息，可以視為單純的 ListView Demo。\n\n#### tenthousandtimer/MyMenu\n\n針對 Menu 包裝操作，命名並沒有使用 Activity 是用來區別這個是一包裝操作的 class 並非直接掛載在頁面上的。\n\n#### tenthousandtimer/SettingActivity\n\n設定頁面，設邊使用了固定的控制項，然後將設定的資訊寫在上面的 system 類別中，並儲存在 SQLite。\n\n#### tenthousandtimer/WelcomActivity\n\n歡迎界面，在裡面載入 SQLite 的資料，其實這沒有必要，在 MainActivity 中載入即可，單純為了好看。\n\n#### tenthousandtimer/WorkingActivity\n\n在 WorkingActivity 中大量的使用了 Animation，如果在事後才掛上 Animation 容易導致先前設計的資料流多少出現錯誤。仔細研究 Animation 與主程式非同步的關係，就能解決這個問題，並不至於需要 APP 大改寫。\n\n#### tttsql/PlanSQL & tttsql/SystemSettingSQL\n\n包裝了 SQLite 的操作，包含了整批資料的 CRUD，這邊對於 SQLite 的操作相當基本，依據我的印象，資料更新的操作是直接用覆蓋的。基本上也不會出錯，在小量的資料下，效能也沒有問題。PlanSQL 和 SystemSettingSQL 分別包裝了不同的資料而已，基本上觀念完全相同。皆是在載入畫面時會讀取資料。記得注意 Andriod 的版本問題，另外 SQLite 自己也有版本問題，請確保測試資料正確，紀律性的測試可以省去很多麻煩。\n\n#### viewlist/AddBtn & viewlist/ViewList\n\n這兩個類別都包裝了動態新增物件的功能，新增動態物件其實相當麻煩，要考慮物件本身、事件、資料，因此我會盡可能將資訊都封裝在類別內，屆時只需要傳入必要參數即可，如任務有用物件包裝好，那理所當然直接傳遞物件即可。\n\n![screen shot](http://polarbearandrew.github.io/blog/img/TTtimer/demo2.png)\n\n## 結語\n\nTTtiemr 亦有存在問題，目前我個人也不知道該如何解決。TTtimer 似乎在重複開啟太多任務後，會導致手機效能降低，吃掉太多CPU或記憶體。但此部分已經超過我對 Andriod APP 的認知，需要更專業的技術。但 TTtimer 所使用的技術，除了連線的需求之外，能滿足絕大部份的 APP 開發。這次的 Andriod APP - TTtimer 分享希望能幫助到大家，如果有任何問題也可以 [Facebook](https://www.facebook.com/profile.php?id=100001317746154) 敲我或是寄信給我詢問細節，但請標明是誰詢問與相關的問題資訊。","source":"_posts/003_TTtimerForOIT.md","raw":"title: Android App - TTtimer\ndate: 2015-08-19 15:46:12\ntags:\n- Android\n- Java\n- 作品集\ncategories: 作品集\ncomments: false\n---\n\n<center>\n![TTtimer](http://polarbearandrew.github.io/blog/img/TTtimer/ic_launcher.png)\n</center>\n\n名稱：TTtimer\n類型：Andriod App / Java, 未上架\n時間：2015/1 (大三上學期)\n用途：期末作業\nLicense：MIT\n\n## 簡介\n\nAndroid APP - TTtime 是我在大三上學期修 Amy 老師 Java 課程的期末作品。這隻 APP 大概是我個人最喜歡期末作品之一，包括結構和設計是我個人最喜歡的，當時我有不少的時間與不曉得發揮空間。TTtimer 的設計概念出自於 10,000 小時，意指在某一個專業區域中努力 10,000 小時才能成為該專業領域中的佼佼者。而 TTtimer 即是此類型的計時器，選擇目標的專業項目後，持續累計時間來達成最初設定的目標，並透過累計時間的百分比、累計總數來給予獎勵或是頭銜的稱號。\n\n<center>\n<img src=\"http://polarbearandrew.github.io/blog/img/TTtimer/working_finish.png\" alt=\"TTtimer Working\" style=\"width: 200px;\"/>\n</center>\n\n以下為 APP 使用到的技術重點，有需要的同學可以在裡面尋找相關自訓。有機會的話相我想把這個 APP 上架，最為一次學習經驗。\n\n## Source Code 分享\n\nSource Code 放置在 Google Drive 上面，分享給需要範例的同學們。\n\n適用於 Andriod Studio 版本：\n[[Android APP]  TTtimer-for-AS-v1.0](https://drive.google.com/open?id=0B1p_o3Z5VQBeXzlXUlRNWExCUVE)\n\n適用於 Eclipse 版本：\n[[Android APP]  TTtimer-for-eclipse-v1.0](https://drive.google.com/open?id=0B1p_o3Z5VQBeYjM5ZEVQWVpWOWs)\n\n## 技術簡介\n\n#### 物件導向設計\n\nAPP 中，每個 `任務` 都是以一個物件包裝，包括包裝這個 `任務` 本身的資訊、進度、累計時間等等。而累計時間輸出時，可是轉換成百分比的函數，也是包裝在 PlaneToTime 的類別裡面。物件導向設計可參考的是以下主要幾個類別：\n\n* MyTimer\n* MicroTimer\n* Plan\n* PlanToTime\n\nMyTimer 和 MicroTimer 類別主要功能就是計時器，在每個計畫中都會使用到一個計時計，並且有簡化一些時間I/O的機制，主要是根據我當時自己的需求所包裝的。而 Plan 和 PlanToTime 包裝了 `計畫` 和 `有時目標間的計畫`，事實上在最後 APP 實作的時候，並沒有 `無目標時間的計畫`，也就是說類別 Plan 只是單純被 PlanToTime 繼承，作用類似於一個基底類別，其實並沒有實作的功能，這屬於我個人設計錯誤，因為一開始有構想 `無目標時間的計畫`。因此在後面會發現，底層設計的取得獎勵的方式，略有不同，僅僅因為當初規劃時我的想法岔開了。\n\n包裝這四個類別，在我專案開發中後期其為吃香，傳送資料時不太需要考慮資料格式。簡單思考：傳遞一個物件比起傳遞四個不同型別的參數，何者容易？當然是包裝好的一個物件，一次傳遞來得輕鬆方便。另外，包裝物件可以在多人開發時，資料格式的缺漏檢查，或是避免掉不必要的資料傳遞誤會與錯誤。\n\n#### 計時器\n\n計時器只有兩個原則，每秒(或是其他時間)的觸發事件，然後再撰寫自己紀錄的方式。計時器 Andriod 有預設事件，少量的計時器每秒的 tick 相當精準，不要一次開一大堆就好。也別用計時器去處理監聽事件，基本上 Andriod 大部份的物件都有自己的監聽事件，不需要自行去撰寫計時器去檢查。在 TTtimer 中牽涉到的類別如下：\n\n* MainActivity\n* TiemRiver\n* SysSet\n\n之前被問過幾次 Android App 的計時計怎麼處理，計時器的影子可以在 `Mainctivity` 中找到，當初設計是在 APP 一啟動時，背後就有一個碼表在計時，而計時計的參數被我抽取到 `TimeRiver` 和 `SysSet` 的類別中，其實 `TimeRiver` 的類別中的設定參數直接抽取到 `SysSet`，目前的方式是多個任務會共用同一個碼錶，避免每開一起一個新的任務就啟用新的碼表消耗效能。\n\n#### SQLite\n\n如果 SQLite 無法正常啟用，記得注意 Android 本身的版本是否要更新，之前個人在測試時就發生過無法啟動的狀況。情急之下用 txt 自己刻了一套類似功能的 documentation SQL。現在想想挺好笑的，結果期中考過後我發現手機系統要更新，更新好就能使用 SQLite 了，只好默默的砍掉整個手刻的 SQL。\n\n關於 SQLite 我使用在兩個部分：儲存計畫、系統參數。\n\n* PlanSQL\n* SystemSettingSQL\n\n兩者都相當直接的包裝了基本的 Sqlite 的 CRUD (新增/修改/刪除/查詢)，基本上 SQLite 在類別設計完成後，撰寫一次，確認每次 APP 開啟後跟 SQLite 的 IO 正常後，我就再也沒有修改過內部的程式碼。所以理想的話只要努力一次就好，並不需要開發途中不斷地維護那段程式碼。 SQLite 需要注意的重點是測試資料的問題。在開發時頻繁的測試過程中，程式碼除錯時會頻繁地影響到資料庫資料的變動，導致錯誤解決了卻仍然出現問題。主因是資料錯誤，產生 Garbage in garbage out 的結果。建議在開發期間每次 APP 啟動時就初始化一次資料，清空資料庫並且寫入測試用的資料，最終在 APP 發佈時只要將初始化資料的程式碼註解掉即可。\n\n另外需要注意的事情是，程式碼要有解析空資料的能力。意思是多半在測試時，資料庫內已經有測試資料，往往忽略了有可能無資料的情況，反而在拿掉測試資料後才發現 APP 啟動的一瞬間就會因為資料讀取失敗而崩潰。\n\n#### 動態新增控制項\n\n這大概是我被詢問最頻繁的項目了。處理這部分的是以下兩個類別：\n\n* AddBtn\n* ViewList\n\n動態新增控制項的步驟就是：宣告 > 設定 > 掛載。除非是要做 APP 遊戲，不然 Andriod 內建的 ListView 應該能解決大部份的問題，當初我在這塊也是修改了好幾個版本，一開始因為好玩也是手刻 ListView，再建立 Scroll view。不過內建的 ListView 和手刻的邏輯基本上是相同的，先將想要動態新增的物件製作成一份 ListItem 再由 ListView 去重複就對了。\n\n#### Android Lifecycle 生命週期\n\n![Andriod 生命週期 ](http://ext.pimg.tw/style77125tech/1369341764-3430810860.png)\n\n撰寫 Andriod APP 最重要的就是生命週期。簡而言之，生命週期就是我們在手機各種操作時，切換到 APP 畫面時對程式運行的影響，例如執行中的 APP 在按下 Home 鍵後會進入到 `onPause()` 的狀態，不同的狀態不可能讓 APP 一直處於運轉中，因此 APP 作業流程設計會圍繞著 Android Lifecycle 在運轉，也是設計的核心。但記得在 Lifecycle 中，我個人認為最不能仰賴 `onDestroy()`，仰賴關閉 APP 時才去執行，無法預測 APP 是在什麼情況下被關閉的，可能執行緒被中斷、手機沒電等等狀況。重要的資料同步，盡可能不要放在 `onDestroy` 的部分。\n\n#### 雙語系\n\nTTtiemr 支援雙語系，支援 `zh-Tw` 和 `en` 語系，根據手機設定的國籍去做辨識。在手機中抓取字串的方式都需要使用 `android:text=\"@string/show\"` 抓取，之前有聽過反映這樣相當不友善(且不容易辨識)，不過在後期翻譯時相當有趣，單純翻譯 `string` 的設定檔就可完成。如果從一開始就有遵守紀律，將對應的字串寫在設定檔內，在專案末期好好享受輕鬆翻譯 APP 語言的成果吧!\n\n#### 多解析度圖片\n\n在多解析度圖片這部分，我個人處理得相當糟糕，當初在 PC 上測試時雨手機上測試時發現差距極大，因此我大量的改用百分比去做設計。解決問題後我就沒有再去對多種解析度的螢幕下去做設計。\n\n#### Animation 動畫效果\n\n在 `WorkingActivity` 可以大量使用到動畫，Android 的動畫使用大致上是：宣告 > 設定參數 > 啟動。需要注意的是 Animation 的狀態，需要將正確的資料流操作掛載載正確的 Animation 事件上面，避免掉發生動畫時件不同步或是執行順序有問題的情況。Animation 玩起來相當有趣且有成就看，相當推薦大家玩玩。\n\n![screen shot](http://polarbearandrew.github.io/blog/img/TTtimer/demo.png)\n\n## 檔案簡介\n\npath: src/main/java/tw/com/oit/andrew/\n\n##### myclass/MyTimer\n\n計時計類別，主要是依照需求包裝了計時器去配合之後的 Andriod time tick。\n\n##### myclass/MicroTimer\n\n繼承了 MyTimer，加入了秒數的欄位，最後這兩個計時器使用的類別會被包在 Plan 和 PlanToTime 中使用。\n\n#### myclass/Plan\n\n包裝了每個計畫項目資訊，屬於 PlanToTime 的父類別，絕大多數重要的功能也是在這裡。\n\n#### myclass/PlanToTime\n\n在計畫項目資訊增加了目標時間，之後的 Activity 中使用的都是這個 class。兩個 Plan 相關的 class 是整個 APP 中 CP 最高的，但也是被反覆修改最多次的，良好的物件設計讓我在整個 APP 開發的後期有了相當不錯的資料控管，我能清楚的掌握資料的傳輸。\n\n#### system/Notify\n\n包裝了所有使用的通知視窗(Dialog)，從外部可以輕鬆的呼叫視窗，僅需要傳入必要的字串需求即可。\n\n#### system/SysSet\n\n系統設定檔。應該與 TimeRiver 合併。\n\n#### system/TimeRiver\n\n系統設定檔。主要是針對計時器的部分，這部分的設定會被記錄在 SQLite 中，確保每次重新啟動時都會是使用者設定的值。\n\n#### tenthousandtimer/MainActivity\n\n主要介面的操作，拿讀取進來的資料動態新增控制項，並且宣告、啟動計時器。\n\n#### tenthousandtimer/MetalsActivity\n\n單純檢視獎牌與頭銜等訊息，可以視為單純的 ListView Demo。\n\n#### tenthousandtimer/MyMenu\n\n針對 Menu 包裝操作，命名並沒有使用 Activity 是用來區別這個是一包裝操作的 class 並非直接掛載在頁面上的。\n\n#### tenthousandtimer/SettingActivity\n\n設定頁面，設邊使用了固定的控制項，然後將設定的資訊寫在上面的 system 類別中，並儲存在 SQLite。\n\n#### tenthousandtimer/WelcomActivity\n\n歡迎界面，在裡面載入 SQLite 的資料，其實這沒有必要，在 MainActivity 中載入即可，單純為了好看。\n\n#### tenthousandtimer/WorkingActivity\n\n在 WorkingActivity 中大量的使用了 Animation，如果在事後才掛上 Animation 容易導致先前設計的資料流多少出現錯誤。仔細研究 Animation 與主程式非同步的關係，就能解決這個問題，並不至於需要 APP 大改寫。\n\n#### tttsql/PlanSQL & tttsql/SystemSettingSQL\n\n包裝了 SQLite 的操作，包含了整批資料的 CRUD，這邊對於 SQLite 的操作相當基本，依據我的印象，資料更新的操作是直接用覆蓋的。基本上也不會出錯，在小量的資料下，效能也沒有問題。PlanSQL 和 SystemSettingSQL 分別包裝了不同的資料而已，基本上觀念完全相同。皆是在載入畫面時會讀取資料。記得注意 Andriod 的版本問題，另外 SQLite 自己也有版本問題，請確保測試資料正確，紀律性的測試可以省去很多麻煩。\n\n#### viewlist/AddBtn & viewlist/ViewList\n\n這兩個類別都包裝了動態新增物件的功能，新增動態物件其實相當麻煩，要考慮物件本身、事件、資料，因此我會盡可能將資訊都封裝在類別內，屆時只需要傳入必要參數即可，如任務有用物件包裝好，那理所當然直接傳遞物件即可。\n\n![screen shot](http://polarbearandrew.github.io/blog/img/TTtimer/demo2.png)\n\n## 結語\n\nTTtiemr 亦有存在問題，目前我個人也不知道該如何解決。TTtimer 似乎在重複開啟太多任務後，會導致手機效能降低，吃掉太多CPU或記憶體。但此部分已經超過我對 Andriod APP 的認知，需要更專業的技術。但 TTtimer 所使用的技術，除了連線的需求之外，能滿足絕大部份的 APP 開發。這次的 Andriod APP - TTtimer 分享希望能幫助到大家，如果有任何問題也可以 [Facebook](https://www.facebook.com/profile.php?id=100001317746154) 敲我或是寄信給我詢問細節，但請標明是誰詢問與相關的問題資訊。","slug":"003_TTtimerForOIT","published":1,"updated":"2015-08-19T08:49:31.000Z","layout":"post","photos":[],"link":"","_id":"ciyk03v46001h0bu0bvw5r9mb"},{"title":"淺談前端框架未來，Angular, React, 還是...？","date":"2015-08-02T01:13:44.000Z","comments":0,"_content":"\n> 本篇文上是本人Andrew Chen為[JSDC 2015](http://jsdc.tw)撰寫\n> 感謝[Caeser Chi](https://www.facebook.com/clonncd?fref=ts)給予指導\n\n![前端框架未來？React, Angular or ..?](http://cdn.xenyomedia.com/sites/default/files/blog/rwd.png)\n\n前端入坑深似海，一入宅門出不來。這肯定是許多前端工程師可以體認到的共同感觸，前端真可以說是一個坑，維繫大家能夠持續學習的動機，除了熱情，應該就還是熱情吧。\n\n## 淺談前端框架\n\n隨著前端應用變化越來越多，因此許多前端框架不斷的推陳出新，從早期大家所熟知的 [batman.js](http://batmanjs.org), [backbone.js](http://backbonejs.org), [emberjs](http://emberjs.com) 在中期也開始出現了許多不同框架，其中到了 Google 踏進 Angular.js 之後前端框架正式熱門起來，也掀起另外一波大戰。\n\n隨著世代的轉移，JavaScript 漸漸語法轉移到 ES6，語法不同，開始有了不同應用，也因此又出現了令人亮眼的新秀：[Aurelia](http://aurelia.io)。\n\n由於前端框架的世界更新相當迅速，不斷有新的Framwork出現，各家開發者對自己熟悉的框架各執其詞，其實相當難定義何者叫好。\n\n## 前端框架未來？React, Angular ?\n\n[React](http://facebook.github.io/react/) 和 [Angular](http://aurelia.io) 目前為前端兩大流行的框架，兩者的風格迥異。\n\nReact 主打 Single Source of True 和 Flux 的單項資料流，重新以元件的思維角度去設計 WebApp，最後又採用相同思維可以進行開發 iOS, Android native 程式框架 - React Native 讓大家眼睛為之一亮。\n\n而在Angular目前的情況較為不明朗，相當多的開發者正在使用能穩定運作的 1.x 版本，但是 Angular 2.x 的版本卻面臨了相當大的改版，而且並沒有支援 1.x 的部分。 Angular 最大亮點在雙向資料綁定，簡潔的資料綁定和監控配上快節奏的開發技巧時，產生令人驚豔的開發速度。\n\nReact 跟 Angular 整體的核心思維是相當不同的，React 特色在於簡化的開發邏輯與資料流，單純的單項資料流讓開發流程和除錯都容易了許多，React 的結構設計也讓抽取元件變得直觀與單純，React 傾向於將開發簡化，在設計好架構與資料結構後就減少犯錯的機會。\n\n但從另一個角度來說，React針對單一的操作，要撰寫的程式碼多出了許多，整個架構也變得龐大。而 Angular 則相反，Angular 在處理資料時相當快速且方便，雙向的資料綁定讓開者並不需要思考太多元件對應的關係，但也因此最終可能會讓整個專案陷入混亂，Angular 在抽取元件時比 React 需要更多的開發技巧，對整體團隊的開發素質要求也相對的更高。\n\n## 新的選擇 - Aurelia\n\nAurelia 或許可以說介於 React 和 Angular 兩者之間，Aurelia 目前為相當新秀的開發框架，他本身與 Angular 的資料綁定方式相當類似，不僅僅對 Angular 的開發者相當容易上手，安插在 HTML5 中的屬性也更加語意化。\n\nAurelia 的核心圍繞在模板上，因此他似乎同時擁有了 React 類似元件的觀念，又同時有 Angular 綁定資料的手法，算是相當多元，除此之外 Aurelia 對 ES6, ES7 擁有更高的支援度。\n\n當然目前 Aurelia 還在持續開發中，雖然版本尚未穩定，但是已經是個值得注目的前端框架，可以開始試著去執行，了解 Aurelia ，或許在現今 Single Page App 爆炸性成長的階段，Aurelia 能在未來佔有一席之地。\n\n也許未來 JavaScript 真的能夠做到前後端統一程式碼進行開發，也有可能踏入 hardware 開發領域，這都需要時間來證明，當然也需要各位的投入，就讓我們持續關注這個世代的變化吧。","source":"_posts/002_AngularReactOrOther.md","raw":"title: 淺談前端框架未來，Angular, React, 還是...？\ndate: 2015-08-02 09:13:44\ntags:\n- 社群活動\n- JavaScript\n- Angular.js\n- React.js\ncategories: 社群活動\ncomments: false\n---\n\n> 本篇文上是本人Andrew Chen為[JSDC 2015](http://jsdc.tw)撰寫\n> 感謝[Caeser Chi](https://www.facebook.com/clonncd?fref=ts)給予指導\n\n![前端框架未來？React, Angular or ..?](http://cdn.xenyomedia.com/sites/default/files/blog/rwd.png)\n\n前端入坑深似海，一入宅門出不來。這肯定是許多前端工程師可以體認到的共同感觸，前端真可以說是一個坑，維繫大家能夠持續學習的動機，除了熱情，應該就還是熱情吧。\n\n## 淺談前端框架\n\n隨著前端應用變化越來越多，因此許多前端框架不斷的推陳出新，從早期大家所熟知的 [batman.js](http://batmanjs.org), [backbone.js](http://backbonejs.org), [emberjs](http://emberjs.com) 在中期也開始出現了許多不同框架，其中到了 Google 踏進 Angular.js 之後前端框架正式熱門起來，也掀起另外一波大戰。\n\n隨著世代的轉移，JavaScript 漸漸語法轉移到 ES6，語法不同，開始有了不同應用，也因此又出現了令人亮眼的新秀：[Aurelia](http://aurelia.io)。\n\n由於前端框架的世界更新相當迅速，不斷有新的Framwork出現，各家開發者對自己熟悉的框架各執其詞，其實相當難定義何者叫好。\n\n## 前端框架未來？React, Angular ?\n\n[React](http://facebook.github.io/react/) 和 [Angular](http://aurelia.io) 目前為前端兩大流行的框架，兩者的風格迥異。\n\nReact 主打 Single Source of True 和 Flux 的單項資料流，重新以元件的思維角度去設計 WebApp，最後又採用相同思維可以進行開發 iOS, Android native 程式框架 - React Native 讓大家眼睛為之一亮。\n\n而在Angular目前的情況較為不明朗，相當多的開發者正在使用能穩定運作的 1.x 版本，但是 Angular 2.x 的版本卻面臨了相當大的改版，而且並沒有支援 1.x 的部分。 Angular 最大亮點在雙向資料綁定，簡潔的資料綁定和監控配上快節奏的開發技巧時，產生令人驚豔的開發速度。\n\nReact 跟 Angular 整體的核心思維是相當不同的，React 特色在於簡化的開發邏輯與資料流，單純的單項資料流讓開發流程和除錯都容易了許多，React 的結構設計也讓抽取元件變得直觀與單純，React 傾向於將開發簡化，在設計好架構與資料結構後就減少犯錯的機會。\n\n但從另一個角度來說，React針對單一的操作，要撰寫的程式碼多出了許多，整個架構也變得龐大。而 Angular 則相反，Angular 在處理資料時相當快速且方便，雙向的資料綁定讓開者並不需要思考太多元件對應的關係，但也因此最終可能會讓整個專案陷入混亂，Angular 在抽取元件時比 React 需要更多的開發技巧，對整體團隊的開發素質要求也相對的更高。\n\n## 新的選擇 - Aurelia\n\nAurelia 或許可以說介於 React 和 Angular 兩者之間，Aurelia 目前為相當新秀的開發框架，他本身與 Angular 的資料綁定方式相當類似，不僅僅對 Angular 的開發者相當容易上手，安插在 HTML5 中的屬性也更加語意化。\n\nAurelia 的核心圍繞在模板上，因此他似乎同時擁有了 React 類似元件的觀念，又同時有 Angular 綁定資料的手法，算是相當多元，除此之外 Aurelia 對 ES6, ES7 擁有更高的支援度。\n\n當然目前 Aurelia 還在持續開發中，雖然版本尚未穩定，但是已經是個值得注目的前端框架，可以開始試著去執行，了解 Aurelia ，或許在現今 Single Page App 爆炸性成長的階段，Aurelia 能在未來佔有一席之地。\n\n也許未來 JavaScript 真的能夠做到前後端統一程式碼進行開發，也有可能踏入 hardware 開發領域，這都需要時間來證明，當然也需要各位的投入，就讓我們持續關注這個世代的變化吧。","slug":"002_AngularReactOrOther","published":1,"updated":"2015-08-03T11:29:32.000Z","layout":"post","photos":[],"link":"","_id":"ciyk03v48001q0bu0tfbxhegy"}],"PostAsset":[],"PostCategory":[{"post_id":"ciyk03v3200000bu0hyj7jtak","category_id":"ciyk03v3800010bu0amduskpg","_id":"ciyk03v3a00040bu0dttdi6zk"},{"post_id":"ciyk03v3k000b0bu0up3f7hbx","category_id":"ciyk03v3l000c0bu01egt5igl","_id":"ciyk03v3l000f0bu0p2llw9k5"},{"post_id":"ciyk03v3m000j0bu0gsl3vjwh","category_id":"ciyk03v3l000c0bu01egt5igl","_id":"ciyk03v3n000k0bu0sf5k6vk0"},{"post_id":"ciyk03v3p000o0bu0udhfp3xb","category_id":"ciyk03v3l000c0bu01egt5igl","_id":"ciyk03v3q000p0bu0ia6jlnj7"},{"post_id":"ciyk03v3r000t0bu0az42vrz7","category_id":"ciyk03v3l000c0bu01egt5igl","_id":"ciyk03v3s000u0bu0zq1il1de"},{"post_id":"ciyk03v3u000y0bu0pd61xv2q","category_id":"ciyk03v3l000c0bu01egt5igl","_id":"ciyk03v3v000z0bu0zqkj10wd"},{"post_id":"ciyk03v3x00130bu0ssd6tvfy","category_id":"ciyk03v3l000c0bu01egt5igl","_id":"ciyk03v3y00140bu0kr5iduhl"},{"post_id":"ciyk03v3z00180bu0t3puvowv","category_id":"ciyk03v4000190bu0hkaaiwei","_id":"ciyk03v41001c0bu0egeq16hc"},{"post_id":"ciyk03v43001d0bu0257o281t","category_id":"ciyk03v43001e0bu0esac1dpc","_id":"ciyk03v44001g0bu0dyy59l1h"},{"post_id":"ciyk03v46001h0bu0bvw5r9mb","category_id":"ciyk03v46001i0bu0ap5md7kd","_id":"ciyk03v47001l0bu00cwdgvwu"},{"post_id":"ciyk03v48001q0bu0tfbxhegy","category_id":"ciyk03v3800010bu0amduskpg","_id":"ciyk03v4a001r0bu0mg5wap69"}],"PostTag":[{"post_id":"ciyk03v3200000bu0hyj7jtak","tag_id":"ciyk03v3800020bu0c6viv7oa","_id":"ciyk03v3b00060bu0jck1l632"},{"post_id":"ciyk03v3200000bu0hyj7jtak","tag_id":"ciyk03v3a00030bu0ggxv1gka","_id":"ciyk03v3b00070bu0ai9xkvo3"},{"post_id":"ciyk03v3200000bu0hyj7jtak","tag_id":"ciyk03v3b00050bu07z79nc3o","_id":"ciyk03v3b00080bu08kpepwvj"},{"post_id":"ciyk03v3k000b0bu0up3f7hbx","tag_id":"ciyk03v3l000d0bu0ss2vx1jd","_id":"ciyk03v3l000g0bu0oev2y7or"},{"post_id":"ciyk03v3k000b0bu0up3f7hbx","tag_id":"ciyk03v3l000e0bu0zu9b6z4g","_id":"ciyk03v3l000h0bu08fopxx5j"},{"post_id":"ciyk03v3k000b0bu0up3f7hbx","tag_id":"ciyk03v3a00030bu0ggxv1gka","_id":"ciyk03v3l000i0bu0r0oq42o1"},{"post_id":"ciyk03v3m000j0bu0gsl3vjwh","tag_id":"ciyk03v3l000d0bu0ss2vx1jd","_id":"ciyk03v3o000l0bu04a1y7ewe"},{"post_id":"ciyk03v3m000j0bu0gsl3vjwh","tag_id":"ciyk03v3l000e0bu0zu9b6z4g","_id":"ciyk03v3o000m0bu0zx505xm4"},{"post_id":"ciyk03v3m000j0bu0gsl3vjwh","tag_id":"ciyk03v3a00030bu0ggxv1gka","_id":"ciyk03v3o000n0bu02s1eky5y"},{"post_id":"ciyk03v3p000o0bu0udhfp3xb","tag_id":"ciyk03v3l000d0bu0ss2vx1jd","_id":"ciyk03v3q000q0bu0xp2wbuim"},{"post_id":"ciyk03v3p000o0bu0udhfp3xb","tag_id":"ciyk03v3l000e0bu0zu9b6z4g","_id":"ciyk03v3q000r0bu0yign2r56"},{"post_id":"ciyk03v3p000o0bu0udhfp3xb","tag_id":"ciyk03v3a00030bu0ggxv1gka","_id":"ciyk03v3q000s0bu0f4fx8le1"},{"post_id":"ciyk03v3r000t0bu0az42vrz7","tag_id":"ciyk03v3l000d0bu0ss2vx1jd","_id":"ciyk03v3t000v0bu0nwxpc1da"},{"post_id":"ciyk03v3r000t0bu0az42vrz7","tag_id":"ciyk03v3l000e0bu0zu9b6z4g","_id":"ciyk03v3t000w0bu02nz089te"},{"post_id":"ciyk03v3r000t0bu0az42vrz7","tag_id":"ciyk03v3a00030bu0ggxv1gka","_id":"ciyk03v3t000x0bu0zp9job3u"},{"post_id":"ciyk03v3u000y0bu0pd61xv2q","tag_id":"ciyk03v3l000d0bu0ss2vx1jd","_id":"ciyk03v3v00100bu0d49d1vpi"},{"post_id":"ciyk03v3u000y0bu0pd61xv2q","tag_id":"ciyk03v3l000e0bu0zu9b6z4g","_id":"ciyk03v3v00110bu0tlkwd2ls"},{"post_id":"ciyk03v3u000y0bu0pd61xv2q","tag_id":"ciyk03v3a00030bu0ggxv1gka","_id":"ciyk03v3w00120bu05sh0deo8"},{"post_id":"ciyk03v3x00130bu0ssd6tvfy","tag_id":"ciyk03v3l000d0bu0ss2vx1jd","_id":"ciyk03v3y00150bu008s399h4"},{"post_id":"ciyk03v3x00130bu0ssd6tvfy","tag_id":"ciyk03v3l000e0bu0zu9b6z4g","_id":"ciyk03v3y00160bu0a60ox0kk"},{"post_id":"ciyk03v3x00130bu0ssd6tvfy","tag_id":"ciyk03v3a00030bu0ggxv1gka","_id":"ciyk03v3y00170bu0dey6uxp2"},{"post_id":"ciyk03v3z00180bu0t3puvowv","tag_id":"ciyk03v3l000d0bu0ss2vx1jd","_id":"ciyk03v40001a0bu0rvcdfeul"},{"post_id":"ciyk03v3z00180bu0t3puvowv","tag_id":"ciyk03v3a00030bu0ggxv1gka","_id":"ciyk03v41001b0bu053lyalkx"},{"post_id":"ciyk03v43001d0bu0257o281t","tag_id":"ciyk03v3a00030bu0ggxv1gka","_id":"ciyk03v44001f0bu0h9c8vnbv"},{"post_id":"ciyk03v46001h0bu0bvw5r9mb","tag_id":"ciyk03v46001j0bu02jevoqag","_id":"ciyk03v47001n0bu0r7u7gpy8"},{"post_id":"ciyk03v46001h0bu0bvw5r9mb","tag_id":"ciyk03v47001k0bu0qnc1c86o","_id":"ciyk03v47001o0bu0gnxgbjuf"},{"post_id":"ciyk03v46001h0bu0bvw5r9mb","tag_id":"ciyk03v47001m0bu02fjn2fe2","_id":"ciyk03v47001p0bu09kly9bt2"},{"post_id":"ciyk03v48001q0bu0tfbxhegy","tag_id":"ciyk03v3800020bu0c6viv7oa","_id":"ciyk03v4b001u0bu0vk530p35"},{"post_id":"ciyk03v48001q0bu0tfbxhegy","tag_id":"ciyk03v3a00030bu0ggxv1gka","_id":"ciyk03v4b001v0bu036csq4pr"},{"post_id":"ciyk03v48001q0bu0tfbxhegy","tag_id":"ciyk03v4a001s0bu0lsehk1c7","_id":"ciyk03v4b001w0bu00kcc0oik"},{"post_id":"ciyk03v48001q0bu0tfbxhegy","tag_id":"ciyk03v4a001t0bu0aoab7fqy","_id":"ciyk03v4b001x0bu0vff17qn7"}],"Tag":[{"name":"社群活動","_id":"ciyk03v3800020bu0c6viv7oa"},{"name":"JavaScript","_id":"ciyk03v3a00030bu0ggxv1gka"},{"name":"ES6","_id":"ciyk03v3b00050bu07z79nc3o"},{"name":"Node.js","_id":"ciyk03v3l000d0bu0ss2vx1jd"},{"name":"Node.js 從零開始","_id":"ciyk03v3l000e0bu0zu9b6z4g"},{"name":"Android","_id":"ciyk03v46001j0bu02jevoqag"},{"name":"Java","_id":"ciyk03v47001k0bu0qnc1c86o"},{"name":"作品集","_id":"ciyk03v47001m0bu02fjn2fe2"},{"name":"Angular.js","_id":"ciyk03v4a001s0bu0lsehk1c7"},{"name":"React.js","_id":"ciyk03v4a001t0bu0aoab7fqy"}]}}